<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let o;o=a?e.attr(a):e.html();let i=t[removeHtml(o)];if(null!=i&&i.length){t=retHtml(o);let n=0;t&&t.forEach(function(e,t){var a=i.replace("{"+n+"}",e);i=a===i?i.replace("{}",e):a,n++}),a?e.attr(a,i):e.html(i)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={'"{}buffer_id{}" - the buffer ID for the {}buffer{}&nbsp;that is no longer being played from.':'"{}buffer_id{}"-不再播放的{}缓冲区{}的缓冲区ID。','"{}buffer_id{}" - the {}buffer{}&nbsp;that is no longer being played from.':'"{}buffer_id{}"-不再播放的{}buffer{}。','"{}queue_id{}" - the queue index for the queue that has finished playing, as returned by the function {}{}audio_create_play_queue(){}{}.':'"{}queue_id{}"- 已完成播放的队列的队列索引，由函数返回 {}{}audio_create_play_queue(){}{}.','"{}queue_shutdown{}" - this is set to 0 during normal playback and 1 when the event is received because {}{}audio_free_play_queue(){}{}&nbsp;has been called. When this is set to 1, you don\'t want to queue up any further data.':'"{}queue_shutdown{}"-在正常播放期间设置为0，在接收到事件时设置为1，因为{}{}audio_free_play_queue(){}{}被称为。当此值设置为1时，您不希望排队等待任何进一步的数据。',"Audio Playback":"音频回放","Every game step now that the recording is detected will trigger an asynchronous Audio Recording event where you can deal with the recorded input something like this:":"现在检测到录音的每个游戏步骤都会触发一个异步音频录制事件，您可以在其中处理录制的输入，如下所示：","Here we check the queue ID and if it's the one we want, we then check the buffer ID to see which buffer has finished being played. We also then set a local var to that index value for checking later and set the buffer back to the start for that sound. Once our local variable reaches 9, indicating that the queue has finished, we stop the sound playing and free the queue.":"在这里，我们检查队列ID，如果它是我们想要的，我们然后检查缓冲区ID以查看哪个缓冲区已完成播放。然后，我们还将本地变量设置为该索引值以供稍后检查，并将缓冲区设置回初始值声音。一旦我们的局部变量达到9，表明队列已经完成，我们就停止声音播放并释放队列。",'Here we check the queue ID and if it\'s the one we want, we then check the value in the "buffer_id" key to get the buffer that has finished playing. We also then set a local var to that index value for checking later and set the buffer back to the start for that sound. Once our local variable reaches 9, indicating that the queue has finished, we stop the sound playing and free the queue.':'在这里我们检查队列ID，如果它是我们想要的，我们检查"buffer_id"键中的值以获得已完成播放的缓冲区。然后我们还将局部变量设置为该索引值以供稍后检查，并将缓冲区设置回该声音的起始位置。一旦我们的局部变量达到9，表明队列已完成，我们停止声音播放并释放队列。',"In the example of use given below we will create an audio queue with 10 buffered audio sounds added to it and then play the queue:":"在下面给出的使用示例中，我们将创建一个音频队列，其中添加了10个缓冲的音频声音，然后播放队列：",'Since an audio queue can be created from multiple buffers, this event can be triggered multiple times for one queue as the end of each section of buffered audio is reached, hence the "buffer_id" key.':'由于可以从多个缓冲区创建音频队列，因此当到达缓冲音频的每个部分的末尾时，可以为一个队列多次触发此事件，因此使用"buffer_id"键。',"The following keys will be available in the DS map:":"以下键将在DS地图中可用：","{}Audio Playback{}":"{}音频播放{}","{}NOTE{}: The variable {}async_load{}&nbsp; is only valid in the asynchronous events, as the DS map that is points to is created at the start of the event, then deleted again at the end, with this variable being reset to a value of -1. However, all further data-structures created from the event must be cleaned up using the appropriate functions.":"{}注意{}：变量 {}async_load{} 仅在异步事件中有效，因为指向的 DS 映射是在事件开始时创建的，然后在最后再次删除，使用这个变量被重置为 -1 的值。但是，必须使用相应的函数清理从该事件中创建的所有其他数据结构。","{}This event can only be triggered by the {}audio queue{} play functions&nbsp;and will return a {}DS Map{}&nbsp;stored in the variable {} {}async_load{}{}, containing different key/value pairs relating to the audio queue that has triggered the event. The event is triggered by a&nbsp;{}callback{}&nbsp;when you have selected an audio queue to playback and a buffer in that audio queue is finished playing.":"{}此事件只能由{}音频队列{}播放函数触发，并将返回存储在变量 {}{}async_load{}{} 中的 {3}DS Map{4}，包含与触发事件的音频队列相关的不同键 / 值对。当你选择了要播放的音频队列和时，该事件由 {}回调{} 触发该音频队列中的缓冲区已播放完毕。","{}This event can only be triggered by the {}audio queue{} play functions&nbsp;and will return a {}DS Map{}&nbsp;stored in the variable {}{}async_load{}{}, containing different key/value pairs relating to the audio queue that has triggered the event. The event is triggered by a&nbsp;{}callback{}&nbsp;when you have selected an audio queue to playback and a buffer in that audio queue has finished playing.":"{}此事件只能由{}音频队列{}播放函数触发，并将返回存储在变量 {}{}async_load{}{} 中的 {3}DS Map{4}，包含与触发事件的音频队列相关的不同键 / 值对。当你选择了要播放的音频队列和时，该事件由 {}回调{} 触发该音频队列中的缓冲区已播放完毕。","{}{}NOTE{}{}&nbsp;The variable&nbsp;{}{}async_load{}{} is only valid in the asynchronous events, as the DS map that it points to is created at the start of the event, then deleted again at the end, with this variable being reset to a value of {}-1{}. However, all further data structures created from the event must be cleaned up using the appropriate functions.":"{}{}注意{}{}：变量 {}{}async_load{}{} 仅在异步事件中有效，因为指向的 DS 映射是在事件开始时创建的，然后在最后再次删除，使用这个变量被重置为 {}-1{} 的值。但是，必须使用相应的函数清理从该事件中创建的所有其他数据结构。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="6.3.1.2.0_1"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Audio Playback</title><meta name="generator" content="Adobe RoboHelp 2022"><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page detailing the Audio Playback async event."><meta name="rh-index-keywords" content="Objects - Async Audio Playback Event"><meta name="search-keywords" content="Audio Playback,ev_async_audio_playback"><link rel="stylesheet" type="text/css" href="../../../assets/css/default.css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="brsnext" value="The_Asset_Editors/Object_Properties/Async_Events/Audio_Playback_Ended.htm"><meta name="brsprev" value="The_Asset_Editors/Object_Properties/Async_Events.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Audio Playback"><span>Audio Playback</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Audio Playback</span></h1><p><img alt="Audio Playback Event" class="center" src="../../../assets/Images/Asset_Editors/Async_AudioPlayback.png">This event can only be triggered by the <a href="../../../GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/Audio_Buffers.htm">audio queue</a> play functions&nbsp;and will return a <a href="../../../GameMaker_Language/GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">DS Map</a>&nbsp;stored in the variable <span class="inline2"><a href="../../../GameMaker_Language/GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span>, containing different key/value pairs relating to the audio queue that has triggered the event. The event is triggered by a&nbsp;<a class="tooltip" title="A callback is simply a function that runs and then triggers another function (or code block) when it has finished doing whatever it was assigned to do. For example, the funtion sprite_add() will trigger a callback in the asynchronous Image Loaded event when the sprite has been loaded.">callback</a>&nbsp;when you have selected an audio queue to playback and a buffer in that audio queue has finished playing.</p><p>The following keys will be available in the DS map:</p><ul class="dropspotlist"><li class="dropspot">"<span class="inline">queue_id</span>" - the queue index for the queue that has finished playing, as returned by the function <a href="../../../GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/audio_create_play_queue.htm"><span class="inline">audio_create_play_queue()</span></a>.</li><li class="dropspot">"<span class="inline">buffer_id</span>" - the <a href="../../../GameMaker_Language/GML_Reference/Buffers/Buffers.htm">buffer</a>&nbsp;that is no longer being played from.</li><li class="dropspot">"<span class="inline">queue_shutdown</span>" - this is set to 0 during normal playback and 1 when the event is received because <a href="../../../GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/audio_free_play_queue.htm"><span class="inline">audio_free_play_queue()</span></a>&nbsp;has been called. When this is set to 1, you don't want to queue up any further data.</li></ul><p>Since an audio queue can be created from multiple buffers, this event can be triggered multiple times for one queue as the end of each section of buffered audio is reached, hence the "buffer_id" key.</p><p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;The variable&nbsp;<span class="inline2"><a href="../../../GameMaker_Language/GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span> is only valid in the asynchronous events, as the DS map that it points to is created at the start of the event, then deleted again at the end, with this variable being reset to a value of <span class="inline2">-1</span>. However, all further data structures created from the event must be cleaned up using the appropriate functions.</p><p>In the example of use given below we will create an audio queue with 10 buffered audio sounds added to it and then play the queue:</p><p class="code">audio_queue = audio_create_play_queue(buffer_s16, 11052, audio_mono);<br>for (var i = 0; i &lt; 10; i++;)<br>&nbsp; &nbsp;{<br>&nbsp; &nbsp;audio_queue_sound(audio_queue, audio_buffer[i], 0, buffer_get_size(audio_buffer[i]));<br>&nbsp; &nbsp;}<br>audio_play_sound(audio_queue, 0, true);</p><p>Every game step now that the recording is detected will trigger an asynchronous Audio Recording event where you can deal with the recorded input something like this:</p><p class="code">var queue = async_load[? "queue_id"];<br>var num = 0;<br>if (queue == audio_queue)<br>&nbsp; &nbsp;{<br>&nbsp; &nbsp;for (var i = 0; i &lt; 10; i++;)<br>&nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; if async_load[? "buffer_id"] == audio_buffer[i]<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;buffer_seek(audio_buffer[i], buffer_seek_start, 0);<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;num = i;<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp;if (num == 9)<br>&nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; audio_stop_sound(audio_queue);<br>&nbsp; &nbsp; &nbsp; audio_free_play_queue(audio_queue);<br>&nbsp; &nbsp; &nbsp; }<br>&nbsp;}</p><p>Here we check the queue ID and if it's the one we want, we then check the value in the "buffer_id" key to get the buffer that has finished playing. We also then set a local var to that index value for checking later and set the buffer back to the start for that sound. Once our local variable reaches 9, indicating that the queue has finished, we stop the sound playing and free the queue.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../Async_Events.htm">Async Events</a></div><div style="float:right">Next:&nbsp;<a href="Audio_Playback_Ended.htm">Audio Playback Ended</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>