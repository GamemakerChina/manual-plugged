<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(t){return t=(t=(t=(t=t.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(t){return t.match(/(<([^>]+)>)/gi)},setTranslator=function(t,e,a){let o;o=a?t.attr(a):t.html();let i=e[removeHtml(o)];if(null!=i&&i.length){e=retHtml(o);let n=0;e&&e.forEach(function(t,e){var a=i.replace("{"+n+"}",t);i=a===i?i.replace("{}",t):a,n++}),a?t.attr(a,i):t.html(i)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var t=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(t):($(".topic-header").append(t),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(t){return t.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={'"{}buffer_id{}" - the ID of the temporary {}buffer{}&nbsp;you can use to retrieve the audio data':'"{}buffer_id{}"- 可用于检索音频数据的临时{}缓冲区{}的 ID ','"{}channel_index{}" - the recording channel index as returned by the calling function that this data came from':'"{}channel_index{}"- 此数据来自的调用函数返回的录制频道索引','"{}data_len{}" - the length of data (in bytes) you\'ve received':'"{}data_len{}"- 您收到的数据长度(以字节为单位)',"Audio Recording":"音频录制","Every game step now that the recording is detected will trigger an asynchronous Audio Recording event where you can deal with the recorded input something like this:":"现在检测到录音的每个游戏步骤都会触发一个异步音频录制事件，您可以在其中处理录制的输入，如下所示：",'Here we simply check the "channel_index" key to make sure it matches the value returned when we started recording, and if it does we copy the contents of the temporary buffer created for this event into our custom buffer. After that you can do what you want with the custom buffer - you could play it using the dedicated buffer audio functions, you could process it and send it over the network, you could save it to disk... Once you have your recorded audio in a buffer, you can do basically anything you want.':'在这里，我们只需检查 "channel_index" 键以确保它与我们开始录制时返回的值匹配，如果匹配，我们将为此事件创建的临时缓冲区的内容复制到我们的自定义缓冲区中。之后你就可以用自定义缓冲区做你想做的 —— 你可以使用专用的缓冲区音频功能播放它，你可以处理它并通过网络发送它，你可以把它保存到磁盘上…一旦你在缓冲区中录制了音频，你基本上可以做到任何你想要的。',"In the usage example below we will create a custom buffer to store our recorded audio, and also set our game to record from input source 0:":"在下面的使用示例中，我们将创建一个自定义缓冲区来存储我们录制的音频，并将我们的游戏设置为从输入源0录制：","The following keys will be available in the ds_map:":"ds_map中将提供以下密钥：","{}Audio Recording{}":"{}录音{}","{}NOTE{}: As mentioned at the start of this page, the variable {}async_load {}is only valid in the asynchronous events, as the DS map that is points to is created at the start of the event, then deleted again at the end. However, note that the temporary buffer in which all audio is stored with the map will also be removed at the end of the event so you should copy it to a custom buffer if you want to keep it for later use.":"{}注意{}：如本页开头所述，变量 {}async_load{} 仅在异步事件中有效，因为指向的 DS 映射是在事件开始时创建的，然后在最后再次删除。但是，请注意，所有音频与映射一起存储的临时缓冲区也将在事件结束时被删除，因此如果您想保留它以供以后使用，您应该将其复制到自定义缓冲区。","{}This event can only be triggered by the {}{}audio_start_recording(){}{}&nbsp;function and will return a {}DS Map{}&nbsp;stored in the variable {}{}async_load{}{}, containing different key/value pairs depending on the {}callback{} from the function that has triggered the event.":"{}此事件只能由{}{}audio_start_recoring(){}{} 函数触发，并将返回存储在变量 {}{}async_load{}{} 中的 {5}DS映射{6}，它包含不同的键 / 值对，具体取决于触发该事件的函数的{}回调{}。","{}This event can only be triggered by the&nbsp;{}{}audio_start_recording{}{} function and will return a {}DS Map{}&nbsp;stored in the variable {}{}async_load{}{}, containing different key/value pairs depending on the {}callback{} from the function that has triggered the event.":"{}此事件只能由{}{}audio_start_recoring(){}{} 函数触发，并将返回存储在变量 {}{}async_load{}{} 中的 {5}DS映射{6}，它包含不同的键 / 值对，具体取决于触发该事件的函数的{}回调{}。","{}{}NOTE{}{}&nbsp;As mentioned at the start of this page, the variable&nbsp;{}{}async_load{}{} is only valid in the asynchronous events, as the DS map that is points to is created at the start of the event, then deleted again at the end. However, note that the temporary buffer in which all audio is stored with the map will also be removed at the end of the event so you should copy it to a custom buffer if you want to keep it for later use.":"{}{}注意{}{}：如本页开头所述，变量 {}{}async_load{}{} 仅在异步事件中有效，因为指向的 DS 映射是在事件开始时创建的，然后在最后再次删除。但是，请注意，所有音频与映射一起存储的临时缓冲区也将在事件结束时被删除，因此如果您想保留它以供以后使用，您应该将其复制到自定义缓冲区。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(t){json_global=t}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="6.3.1.2.0_3"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Audio Recording</title><meta name="generator" content="Adobe RoboHelp 2022"><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page detailing the Audio Recording async event."><meta name="rh-index-keywords" content="Objects - Async Audio Recording Event"><meta name="search-keywords" content="Audio Recording,ev_async_audio_recording"><link rel="stylesheet" type="text/css" href="../../../assets/css/default.css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="brsnext" value="The_Asset_Editors/Object_Properties/Async_Events/Cloud.htm"><meta name="brsprev" value="The_Asset_Editors/Object_Properties/Async_Events/Audio_Playback_Ended.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Audio Recording"><span>Audio Recording</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Audio Recording</span></h1><p><img alt="Audio Recording Event" class="center" src="../../../assets/Images/Asset_Editors/Async_AudioRecording.png">This event can only be triggered by the&nbsp;<span class="inline3_func"><a href="../../../GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/audio_start_recording.htm">audio_start_recording</a></span> function and will return a <a href="../../../GameMaker_Language/GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">DS Map</a>&nbsp;stored in the variable <span class="inline2"><a href="../../../GameMaker_Language/GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span>, containing different key/value pairs depending on the <a class="tooltip" title="A callback is simply a function that runs and then triggers another function (or code block) when it has finished doing whatever it was assigned to do. For example, the funtion sprite_add() will trigger a callback in the asynchronous Image Loaded event when the sprite has been loaded.">callback</a> from the function that has triggered the event.</p><p>The following keys will be available in the ds_map:</p><ul class="dropspotlist"><li class="dropspot">"<span class="inline">buffer_id</span>" - the ID of the temporary <a href="../../../GameMaker_Language/GML_Reference/Buffers/Buffers.htm">buffer</a>&nbsp;you can use to retrieve the audio data</li><li class="dropspot">"<span class="inline">channel_index</span>" - the recording channel index as returned by the calling function that this data came from</li><li class="dropspot">"<span class="inline">data_len</span>" - the length of data (in bytes) you've received</li></ul><p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;As mentioned at the start of this page, the variable&nbsp;<span class="inline2"><a href="../../../GameMaker_Language/GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span> is only valid in the asynchronous events, as the DS map that is points to is created at the start of the event, then deleted again at the end. However, note that the temporary buffer in which all audio is stored with the map will also be removed at the end of the event so you should copy it to a custom buffer if you want to keep it for later use.</p><p>In the usage example below we will create a custom buffer to store our recorded audio, and also set our game to record from input source 0:</p><p class="code">channel_index = audio_start_recording(0);<br>audio_buffer = buffer_create(len, buffer_fast, 1);</p><p>Every game step now that the recording is detected will trigger an asynchronous Audio Recording event where you can deal with the recorded input something like this:</p><p class="code">var channel = async_load[? "channel_index"];<br>if (channel == channel_index)<br>&nbsp; &nbsp;{<br>&nbsp; &nbsp;len = async_load[? "data_len"];<br>&nbsp; &nbsp;buffer_copy(async_load[? "buffer_id"], 0, len, audio_buffer, 0);<br>&nbsp; &nbsp;}</p><p>Here we simply check the "channel_index" key to make sure it matches the value returned when we started recording, and if it does we copy the contents of the temporary buffer created for this event into our custom buffer. After that you can do what you want with the custom buffer - you could play it using the dedicated buffer audio functions, you could process it and send it over the network, you could save it to disk... Once you have your recorded audio in a buffer, you can do basically anything you want.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../Async_Events.htm">Async Events</a></div><div style="float:right">Next: <a href="Cloud.htm">Cloud</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>