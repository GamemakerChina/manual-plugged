<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(t){return t=(t=(t=(t=t.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(t){return t.match(/(<([^>]+)>)/gi)},setTranslator=function(t,n,a){let e;e=a?t.attr(a):t.html();let l=n[removeHtml(e)];if(null!=l&&l.length){n=retHtml(e);let o=0;n&&n.forEach(function(t,n){var a=l.replace("{"+o+"}",t);l=a===l?l.replace("{}",t):a,o++}),a?t.attr(a,l):t.html(l)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){$(".header").length&&$(".header").append(`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`)},removeExtensionFromHash=function(t){return t.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")},$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption,blockquote").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption,.expandtext").each(function(){setTranslator($(this),json)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="6.3.1.2.0_3"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Audio Recording</title><meta name="generator" content="Adobe RoboHelp 2022"><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page detailing the Audio Recording async event."><meta name="rh-index-keywords" content="Objects - Async Audio Recording Event"><meta name="search-keywords" content="Audio Recording,ev_async_audio_recording"><link rel="stylesheet" type="text/css" href="../../../assets/css/default.css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="brsnext" value="The_Asset_Editors/Object_Properties/Async_Events/Cloud.htm"><meta name="brsprev" value="The_Asset_Editors/Object_Properties/Async_Events/Audio_Playback_Ended.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Audio Recording"><span>Audio Recording</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Audio Recording</span></h1><p><img alt="Audio Recording Event" class="center" src="../../../assets/Images/Asset_Editors/Async_AudioRecording.png">This event can only be triggered by the&nbsp;<span class="inline3_func"><a href="../../../GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/audio_start_recording.htm">audio_start_recording</a></span> function and will return a <a href="../../../GameMaker_Language/GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">DS Map</a>&nbsp;stored in the variable <span class="inline2"><a href="../../../GameMaker_Language/GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span>, containing different key/value pairs depending on the <a class="tooltip" title="A callback is simply a function that runs and then triggers another function (or code block) when it has finished doing whatever it was assigned to do. For example, the funtion sprite_add() will trigger a callback in the asynchronous Image Loaded event when the sprite has been loaded.">callback</a> from the function that has triggered the event.</p><p>The following keys will be available in the ds_map:</p><ul class="dropspotlist"><li class="dropspot">"<span class="inline">buffer_id</span>" - the ID of the temporary <a href="../../../GameMaker_Language/GML_Reference/Buffers/Buffers.htm">buffer</a>&nbsp;you can use to retrieve the audio data</li><li class="dropspot">"<span class="inline">channel_index</span>" - the recording channel index as returned by the calling function that this data came from</li><li class="dropspot">"<span class="inline">data_len</span>" - the length of data (in bytes) you've received</li></ul><p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;As mentioned at the start of this page, the variable&nbsp;<span class="inline2"><a href="../../../GameMaker_Language/GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span> is only valid in the asynchronous events, as the DS map that is points to is created at the start of the event, then deleted again at the end. However, note that the temporary buffer in which all audio is stored with the map will also be removed at the end of the event so you should copy it to a custom buffer if you want to keep it for later use.</p><p>In the usage example below we will create a custom buffer to store our recorded audio, and also set our game to record from input source 0:</p><p class="code">channel_index = audio_start_recording(0);<br>audio_buffer = buffer_create(len, buffer_fast, 1);</p><p>Every game step now that the recording is detected will trigger an asynchronous Audio Recording event where you can deal with the recorded input something like this:</p><p class="code">var channel = async_load[? "channel_index"];<br>if (channel == channel_index)<br>&nbsp; &nbsp;{<br>&nbsp; &nbsp;len = async_load[? "data_len"];<br>&nbsp; &nbsp;buffer_copy(async_load[? "buffer_id"], 0, len, audio_buffer, 0);<br>&nbsp; &nbsp;}</p><p>Here we simply check the "channel_index" key to make sure it matches the value returned when we started recording, and if it does we copy the contents of the temporary buffer created for this event into our custom buffer. After that you can do what you want with the custom buffer - you could play it using the dedicated buffer audio functions, you could process it and send it over the network, you could save it to disk... Once you have your recorded audio in a buffer, you can do basically anything you want.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../Async_Events.htm">Async Events</a></div><div style="float:right">Next: <a href="Cloud.htm">Cloud</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>