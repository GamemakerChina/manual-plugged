<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../assets/import/layer/layer.js"></script><script type="text/javascript" src="../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let r;r=a?e.attr(a):e.html();let o=t[removeHtml(r)];if(null!=o&&o.length){t=retHtml(r);let n=0;t&&t.forEach(function(e,t){var a=o.replace("{"+n+"}",e);o=a===o?o.replace("{}",e):a,n++}),a?e.attr(a,o):e.html(o)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"A complete overview of how shaders really work and what place they have in the graphics pipeline is outside the scope of this, but you can find a brief guide here:":"关于着色器如何真正工作以及它们在图形管道中的地位的完整概述超出了本文的范围，但你可以在这里找到一个简短的指南：","A shader is basically a two-part program that runs directly on the graphics card itself, making it very fast since the GPU is doing all the work and freeing up CPU cycles for your game code. The full shader is comprised of a vertex shader program, and a fragment shader program (also known as a pixel shader). Both of these tiny programs work together in order to manipulate what the graphics card renders to the screen. This then permits you to manipulate in real time, the position, colour and alpha values that are actually&nbsp;{}rendered{}&nbsp;onto the&nbsp;{}display buffer{}.":"着色器基本上是一个由两部分组成的程序，直接在显卡本身上运行，由于GPU在做所有的工作，所以速度非常快，并为你的游戏代码释放出CPU周期。完整的着色器由一个顶点着色器程序和一个片段着色器程序（也被称为像素着色器）组成。这两个小程序一起工作，以操纵显卡渲染到屏幕上的内容。这样，你就可以实时操作实际{}渲染{}到{}显示缓冲区{}的位置、颜色和阿尔法值","All target platforms":"所有目标平台","Asset Browser":"资源浏览器","Creating a Shader":"创建一个着色器","For further details relating to shader functions and how they can be used in {}GameMaker{} please see the following pages:":"有关着色器函数的更多细节以及如何在{}GameMaker{}中使用它们，请参见以下页面：","Guide To Using Shaders":"着色器使用指南","It is worth noting that you can use GLSL ES shaders on {}all {}target platforms, but for them to work on the&nbsp;{}HTML5 {}target platform you must have enabled WebGL in the {}HTML5 Game Options{}&nbsp;otherwise they will not work.":"值得注意的是，你可以在{}所有{}目标平台上使用GLSL ES着色器，但要让它们在&nbsp;{}HTML5{}目标平台上工作，你必须在{}HTML5游戏选项{}&nbsp中启用WebGL，否则它们将无法工作。","Language Support":"语言支持","Mac and Ubuntu (Linux)":"Mac 和 Ubuntu (Linux)","Shader Constants":"着色器常量","Shader Functions":"着色器函数",'The Fragment Shader is the programmable shader stage in the rendering pipeline that deals with "fragments" - the interpolated pixels used to texture any given polygon - and they are responsible for outputting the final pixel colour of each rendered triangle pixel. Basically it works like this: the Fragment Shader receives as its input all those fragments (the individual pixels of the triangle being rendered) that have been passed along the pipeline by the Vertex Shader. It can then process these fragments to change the colour and alpha of the final destination pixel that will be drawn to the screen.':'片段着色器是渲染管道中的可编程着色器阶段，用于处理 "片段"--用于对任何给定的多边形进行纹理的插值像素--它们负责输出每个渲染的三角形像素的最终颜色。基本上，它是这样工作的：片段着色器接收所有由顶点着色器沿管道传递的片段（正在渲染的三角形的单个像素）作为其输入。然后，它可以处理这些片段，以改变将被绘制到屏幕上的最终目标像素的颜色和透明度。',"The Shader Editor":"着色器编辑器",'The Vertex Shader is the programmable shader stage in the rendering pipeline that handles the processing of individual vertices (the points of the triangles used to render any image), and when you are rendering a geometry - like a sprite or a surface - {}GameMaker{} creates a stream of vertices -&nbsp;called a {}Vertex Buffer&nbsp;{}- that defines&nbsp;the geometry of these triangles. A sprite for example would have a geometry of two triangles (normally called {}polygons{}) rendered together to form a "quad". This vertex stream from the Vertex Buffer is fed as an input to the Vertex Shader, which can process the vertices data in a programmable way. The Vertex Shader output is used by the GPU to assemble triangles, which are then properly clipped and culled to the view port and view camera, and then sent on to the rasterizer block of the GPU which generates a new output stream, constituted by something called {}Fragments{}. These are tiny data structures, each of which is relative to a single pixel that appears on the screen.':'顶点着色器是渲染管道中的可编程着色器阶段，它处理单个顶点（用于渲染任何图像的三角形的点），当你正在渲染一个几何体--如精灵或表面--{}GameMaker{}创建一个顶点流--&nbsp;称为{}Vertex Buffer&nbsp;{}--定义&nbsp;这些三角形的几何。例如，一个精灵会有一个由两个三角形（通常称为{}多边形{}）组成的几何体，并被渲染成一个 "四边形"。这个来自顶点缓冲器的顶点流被作为输入输入到顶点着色器，它可以以可编程的方式处理顶点数据。顶点着色器的输出被GPU用来组装三角形，然后对其进行适当的剪裁，并对视图端口和视图相机进行剪裁，然后被发送到GPU的光栅化器块，该块产生一个新的输出流，由称为{}Fragments{}的东西组成。这些都是微小的数据结构，每一个都是相对于出现在屏幕上的一个像素的。',"To create a shader resource, simply right click {}&nbsp;inside the&nbsp;{}Asset Browser{} and select {}Create -&gt;&nbsp;Shader{}. Once you have created the base shader, you can then use the right mouse {}&nbsp;menu on the new resource to select the shader type before continuing to edit the code:":"要创建一个着色器资源，只需在{1}Asset Browser{2}内右击{}&nbsp;，选择{}Create -&gt;&nbsp;Shader{}。一旦你创建了基础着色器，你就可以在新资源上使用鼠标右键{}菜单来选择着色器类型，然后继续编辑代码：","When writing GLSL ES shaders, it is recommended to follow the {}official language specification{}&nbsp;as closely as possible to avoid errors&nbsp;as some target platforms&nbsp;can be stricter&nbsp;than others (such as the HTML5 and GX.games targets, which can be more restrictive than&nbsp;other platforms such as Windows, macOS, etc. when it comes to language limitations).":"在编写GLSL ES着色器时，建议尽可能地遵循{}官方语言规范{}&nbsp;，以避免错误&nbsp;，因为一些目标平台&nbsp;可能比其他平台更严格&nbsp;（例如HTML5和GX.games目标，在涉及语言限制时可能比&nbsp;其他平台如Windows、macOS等更严格）。","Windows and Xbox":"Windows 和 Xbox","{}Fragment Shader{}{}Fragment Shader{}":"{}片段着色器{}{}片段着色器{}","{}GLSL ES 1.0 Specifications{} - PDF file for the OpenGL ES 1.0 Shader Language that {}GameMaker{} uses.":"{}GLSL ES 1.0 Specifications{} - {}GameMaker{}使用的OpenGL ES 1.0 Shader Language的PDF文件","{}GameMaker{} supports the following shader languages:":"{}GameMaker{}支持以下着色器语言：","{}HLSL Language Reference{} - The Microsoft reference pages for using HLSL.":"{}HLSL语言参考{} - 微软HLSL的参考页。","{}PSSL Language Presentation{} - Overview of the PSSL language in presentation format.":"{}PSSL语言演示{} - PSSL语言的演示格式概述","{}Shader Constants{}&nbsp;- The constants built in to {}GameMaker{} that can be used when writing shaders.":"{}Shader Constants{}&nbsp;- {}GameMaker{}内置的常量，可以在编写着色器时使用。","{}Shader Functions{}&nbsp;- The GML reference section for shaders.":"{}Shader Functions{}&nbsp;- GML的着色器参考部分。","{}Shaders are a very powerful tool that can be used to manipulate the graphics that your game renders to the screen, permitting incredibly fast effects that can range from, for example, adding a subtle colour hue to a sprite, right up to full screen distortion effects. But what is a shader?":"{}着色器是一个非常强大的工具，它可以用来操纵你的游戏渲染到屏幕上的图形，允许令人难以置信的快速效果，范围包括，例如，为精灵添加一个微妙的颜色色调，直到全屏的扭曲效果。但什么是着色器？","{}The Shader Editor{}":"{}着色器编辑器{}",'{}The code editor itself is split into two the "programs" - Vertex and Fragment - when you create a new shader, with each one being available from tabs at the top of the editor. Both are created at once because you {}cannot create a shader without both parts{}. Even if you wish to only use the fragment shader you will have to have created a "pass through" vertex shader first, which is why by default any new shader being created will have a vertex and fragment pass through shader already coded for you (in the screen shot at the top of the page, you can see that we have used the code editor pane view to show the two side by side... useful when working on both the shader programs together).':'{}当你创建一个新的着色器时，代码编辑器本身被分成两个 "程序"--顶点（Vertex）和片段（Fragment），每个程序都可以从编辑器顶部的标签中获得。这两个程序都是同时创建的，因为你{}不能在没有这两个部分的情况下创建一个着色器{}。即使你只想使用片段着色器，你也必须先创建一个 "通过 "顶点着色器，这就是为什么在默认情况下，任何新的着色器都会有一个已经为你编码的顶点和片段通过着色器（在页面顶部的截图中，你可以看到我们使用了代码编辑器窗格视图来显示这两个并排的程序...在一起处理两个着色器程序时非常有用）。',"{}Vertex Shader{}{}Vertex Shader{}":"{}顶点着色器{}{}顶点着色器{}"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="..",gTopicId="6.7_1"</script><script type="text/javascript" src="../template/scripts/rh.min.js"></script><script type="text/javascript" src="../template/scripts/common.min.js"></script><script type="text/javascript" src="../template/scripts/topic.min.js"></script><script type="text/javascript" src="../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>The Shader Editor</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../assets/css/default.css" type="text/css"><script src="../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page detailing how the shader editor works"><meta name="rh-index-keywords" content="Shader Editor"><meta name="search-keywords" content="shaders,shader,open GL,open GL ES"><meta name="brsnext" value="The_Asset_Editors/Sounds.htm"><meta name="brsprev" value="The_Asset_Editors/Sequence_Properties/Broadcast_Messages.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="The Shader Editor"><span>The Shader Editor</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">The Shader Editor</span></h1><p><img alt="Shader Editor" class="center" src="../assets/Images/Asset_Editors/Editor_Shaders.png">Shaders are a very powerful tool that can be used to manipulate the graphics that your game renders to the screen, permitting incredibly fast effects that can range from, for example, adding a subtle colour hue to a sprite, right up to full screen distortion effects. But what is a shader?</p><p>A shader is basically a two-part program that runs directly on the graphics card itself, making it very fast since the GPU is doing all the work and freeing up CPU cycles for your game code. The full shader is comprised of a vertex shader program, and a fragment shader program (also known as a pixel shader). Both of these tiny programs work together in order to manipulate what the graphics card renders to the screen. This then permits you to manipulate in real time, the position, colour and alpha values that are actually&nbsp;<a class="tooltip" title="When something is rendered in GameMaker Studio 2, it generally means that it has simply been 'drawn to the display buffer' or 'drawn to a surface'.  Rendering can also refer to the process of turning some kind of vector source (like a font) into a bitmap image,.">rendered</a>&nbsp;onto the&nbsp;<a class="tooltip" title="The display buffer is the 'canvas' where everything is finally drawn. Some events target this directly (like the Pre Draw event), while others will first draw to the application surface and then draw that to the display buffer.">display buffer</a>.</p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"><span data-open-text="true" data-skip-index="true">Vertex Shader</span><span data-close-text="true">Vertex Shader</span></a></p><div class="droptext" data-targetname="drop-down"><p class="dropspot">The Vertex Shader is the programmable shader stage in the rendering pipeline that handles the processing of individual vertices (the points of the triangles used to render any image), and when you are rendering a geometry - like a sprite or a surface - <span data-keyref="GameMaker Name">GameMaker</span> creates a stream of vertices -&nbsp;called a <strong>Vertex Buffer&nbsp;</strong>- that defines&nbsp;the geometry of these triangles. A sprite for example would have a geometry of two triangles (normally called <em>polygons</em>) rendered together to form a "quad". This vertex stream from the Vertex Buffer is fed as an input to the Vertex Shader, which can process the vertices data in a programmable way. The Vertex Shader output is used by the GPU to assemble triangles, which are then properly clipped and culled to the view port and view camera, and then sent on to the rasterizer block of the GPU which generates a new output stream, constituted by something called <strong>Fragments</strong>. These are tiny data structures, each of which is relative to a single pixel that appears on the screen.</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span data-open-text="true" data-skip-index="true">Fragment Shader</span><span data-close-text="true">Fragment Shader</span></a></p><div class="droptext" data-targetname="drop-down1"><p class="dropspot">The Fragment Shader is the programmable shader stage in the rendering pipeline that deals with "fragments" - the interpolated pixels used to texture any given polygon - and they are responsible for outputting the final pixel colour of each rendered triangle pixel. Basically it works like this: the Fragment Shader receives as its input all those fragments (the individual pixels of the triangle being rendered) that have been passed along the pipeline by the Vertex Shader. It can then process these fragments to change the colour and alpha of the final destination pixel that will be drawn to the screen.</p></div><p>&nbsp;</p><p>A complete overview of how shaders really work and what place they have in the graphics pipeline is outside the scope of this, but you can find a brief guide here:</p><ul class="colour"><li><a href="../Additional_Information/Guide_To_Using_Shaders.htm">Guide To Using Shaders</a></li></ul><p>&nbsp;</p><h2>Language Support</h2><p><span data-keyref="GameMaker Name">GameMaker</span> supports the following shader languages:</p><table><tbody><tr><th>Shader Language</th><th>Target Platform</th></tr><tr><td><strong>GLSL ES 1.0</strong></td><td>All target platforms</td></tr><tr><td><strong>GLSL</strong></td><td>Mac and Ubuntu (Linux)</td></tr><tr><td><strong>HLSL 11</strong></td><td>Windows and Xbox</td></tr><tr><td><strong>PSSL</strong></td><td>PlayStation 4 &amp; 5</td></tr></tbody></table><p>When writing GLSL ES shaders, it is recommended to follow the <a href="https://www.khronos.org/registry/OpenGL/specs/es/2.0/GLSL_ES_Specification_1.00.pdf" title="GLSL ES 1.0 Specification">official language specification</a>&nbsp;as closely as possible to avoid errors&nbsp;as some target platforms&nbsp;can be stricter&nbsp;than others (such as the HTML5 and GX.games targets, which can be more restrictive than&nbsp;other platforms such as Windows, macOS, etc. when it comes to language limitations).</p><p>&nbsp;</p><h2>Creating a Shader</h2><p>To create a shader resource, simply right click <img alt="RMB Icon" class="icon" src="../assets/Images/Icons/Icon_RMB.png">&nbsp;inside the&nbsp;<a href="../Introduction/The_Asset_Browser.htm">Asset Browser</a> and select <em>Create -&gt;&nbsp;Shader</em>. Once you have created the base shader, you can then use the right mouse <img alt="RMB Icon" class="icon" src="../assets/Images/Icons/Icon_RMB.png">&nbsp;menu on the new resource to select the shader type before continuing to edit the code:</p><p><img alt="Shader Editor RMB Menu" class="center" src="../assets/Images/Asset_Editors/Editor_Shader_RMBMenu.png">The code editor itself is split into two the "programs" - Vertex and Fragment - when you create a new shader, with each one being available from tabs at the top of the editor. Both are created at once because you <em>cannot create a shader without both parts</em>. Even if you wish to only use the fragment shader you will have to have created a "pass through" vertex shader first, which is why by default any new shader being created will have a vertex and fragment pass through shader already coded for you (in the screen shot at the top of the page, you can see that we have used the code editor pane view to show the two side by side... useful when working on both the shader programs together).</p><p>It is worth noting that you can use GLSL ES shaders on <em>all</em> target platforms, but for them to work on the&nbsp;<strong>HTML5</strong> target platform you must have enabled WebGL in the <a href="../Settings/Game_Options/HTML5.htm">HTML5 Game Options</a>&nbsp;otherwise they will not work.</p><p>For further details relating to shader functions and how they can be used in <span data-keyref="GameMaker Name">GameMaker</span> please see the following pages:</p><ul class="colour"><li><a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/Shaders.htm">Shader Functions</a>&nbsp;- The GML reference section for shaders.</li><li><a href="../GameMaker_Language/GML_Reference/Asset_Management/Shaders/Shader_Constants.htm">Shader Constants</a>&nbsp;- The constants built in to <span data-keyref="GameMaker Name">GameMaker</span> that can be used when writing shaders.</li><li><a href="https://www.khronos.org/registry/OpenGL/specs/es/2.0/GLSL_ES_Specification_1.00.pdf">GLSL ES 1.0 Specifications</a> - PDF file for the OpenGL ES 1.0 Shader Language that <span data-keyref="GameMaker Name">GameMaker</span> uses.</li><li><a href="https://docs.microsoft.com/en-us/windows/win32/direct3dhlsl/dx-graphics-hlsl-reference">HLSL Language Reference</a> - The Microsoft reference pages for using HLSL.</li><li><a href="http://twvideo01.ubm-us.net/o1/vault/gdceurope2013/Presentations/825424RichardStenson.pdf">PSSL Language Presentation</a> - Overview of the PSSL language in presentation format.</li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="The_Asset_Editors.htm">The Asset Editors</a></div><div style="float:right">Next:&nbsp;<a href="Sounds.htm">The Sound Editor</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>