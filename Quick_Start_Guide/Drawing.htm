<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../assets/import/layer/layer.js"></script><script type="text/javascript" src="../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let n;n=a?e.attr(a):e.html();let s=t[removeHtml(n)];if(null!=s&&s.length){t=retHtml(n);let o=0;t&&t.forEach(function(e,t){var a=s.replace("{"+o+"}",e);s=a===s?s.replace("{}",e):a,o++}),a?e.attr(a,s):e.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Add a number of instances of the object into the room editor and then press the Play button {}&nbsp; at the top of the IDE. You should see something like this:":"将该对象的多个实例添加到工作室编辑器中，然后按下 IDE 顶部的播放按钮 {} 。您应该会看到类似这样的内容：","Add a number of instances of the object into the room editor and then press the {}Play {}button {} at the top of the {}IDE{}. If all has gone correctly you should see something like this now:":"将该对象的多个实例添加到房间编辑器中，然后按下 {3}IDE{4} 顶部的 {} 播放 {} 按钮 {}。如果一切正常，您现在应该看到如下所示：","Add a single instance of this object to your room now and then press the {}Play {}button {}. When the game runs press and release the {}&lt;Space&gt;{} key and you should see the score value increase.":"立即将此对象的单个实例添加到您的房间，然后按{}播放{}按钮{}。当游戏运行时，按下并松开{}&lt;空格键&gt;{}，您应该会看到分数值增加。","Add an instance of this object to a room if you haven't already done so (only one, though!), and then press the {}Play {}button {}. Once the game is running press the {}&lt;Up Arrow&gt;{} and {}&lt;Down Arrow&gt;{} keys various times to see the health change.":"如果您尚未将此对象的实例添加到房间中(但只有一个！)，然后按下{}播放{}按钮{}。游戏运行后，按{}<向上箭头>{}和{}<向下箭头>{}键可查看健康状况的变化。","All this does is tell&nbsp;{}GameMaker{} to choose one of the listed names and assign it to a variable, as well as generate a random number from 0 to 100 for each instance of the object. We want to draw these values to the screen, and so for that you need to now add a {}Draw Event{} and in it add the following GML Visual or GML:":"所做的只是告诉 {}GameMaker{} 从列出的名称中选择一个并将其赋给一个变量，并为该对象的每个实例生成一个从 0 到 100 的随机数。我们希望将这些值绘制到屏幕上，因此您现在需要添加一个 {} 绘制事件 {}，并在其中添加以下 GML 可视或 GML：","Another of the properties that we can change for our sprite is the {}scale {}value, permitting us to draw it bigger or smaller whenever we want. Scale is caculated independently along the X and Y axis by two seperate variables, the {}image_xscale{} variable and the {}image_yscale{} variable. By default these are set to 1, and they act like {}multipliers{}, so a value of 0.5 would be half scale and a value of 2 would be double the scale.":"我们可以为精灵更改的另一个属性是 {} 比例 {} 值，允许我们随时根据需要将其绘制得更大或更小。比例是由两个独立的变量沿 X 和 Y 轴独立计算的，即 {}image_xscale{} 变量和 {}image_yscale{} 变量。默认情况下，这些值设置为 1，它们的作用类似于 {} 倍增 {}，因此值 0.5 将是比例的一半，值 2 将是比例的两倍。","Before going any further, you might want to make a new project (either GML or GML Visual) from the {}Start Page{}, and add (or create) a few sprites as well as an object or two, as we'll be giving you some code that you can test using these. Even a white square will work for now as the sprite for our object!":"在继续之前，您可能希望从 {} 开始页 {} 创建一个新项目 (GML 或 GML 可视化)，并添加 (或创建) 几个精灵以及一个或两个对象，因为我们将提供一些代码，您可以使用这些代码进行测试。即使是白色正方形现在也可以作为我们的对象的精灵！","Before we leave this example, let's just tweak it a little bit and instead of having \" {}spr_Two{}\" simply rotate, we'll make it point towards the mouse position. For that we need to change the Draw Event GML Visual or GML to look like this:":'在我们离开这个例子之前，让我们稍微调整一下，让它指向鼠标位置，而不是简单地旋转 "{}spr_Two{}"。为此，我们需要将绘制事件 GML 可视化或 GML 更改为如下所示：',"Before you leave this example, you should experiment with the number of lives and see what happens. At the moment it's set to 3, but change the Create Event and the Key Pressed event to set the value to 5, or 10... if you've done everything right, then the code should adapt and draw them all correctly!":"在您离开这个例子之前，您应该试验一下生命的数量，看看会发生什么。目前它设置为 3，但更改创建事件和按键事件以将值设置为 5 或 10...。如果你做的每件事都是正确的，那么代码应该会调整并正确地绘制它们！",Drawing:"绘制","Finally, let's draw the score value in the Draw GUI event, like this:":"最后，让我们在绘制 GUI 事件中绘制分数值，如下所示：",'Finally, we need to draw the sprites to the display. For this we\'ll be using a " {}for{}" loop (information using GML {}here{}&nbsp;and for GML Visual {}here{}), along with the GUI width variable to position everything in the top right corner of the screen. So, add this into the Draw Gui Event (after any other actions that it may have from previous examples):':'最后，我们需要将精灵画到显示器上。为此，我们将使用 "{}for{}" 循环 (使用 GML{} 在这里 {} 和 GML 可视化 {} 在这里 {} 的信息)，以及将所有内容放置在屏幕右上角的图形用户界面宽度变量。因此，将其添加到绘制 GUI 事件中 (在前面的示例中可能具有的任何其他操作之后)：','For this example, you\'ll need two sprites and one object. Call the sprites " {}spr_One{}" and " {}spr_Two{}", and then set the " {}spr_One{}" origin to the center and for " {}spr_Two{}" set its origin to the middle-left:':'在本例中，您需要两个精灵和一个对象。调用精灵 "{}spr_One{}" 和 "{}spr_Two{}"，然后将 "{}spr_One{}" 原点居中，对于 "{}spr_Two{}"，将其原点设置为左中：',"Here we're using the maths function {}{}dsin(){}{}&nbsp;to generate a value between -1 and 1 using the timer variable, and then applying that to the scale variables. After placing some instances into a room and pressing the {}Play {}button {}, you should see how the instances scale up and down from a scale of 0 to a scale of 2 and then back again.":"在这里，我们使用数学函数 {}{}dsin(){}{} 通过定时器变量生成一个介于 -1 和 1 之间的值，然后将其应用于刻度变量。在将一些实例放置到房间中并按下 {} 播放 {} 按钮 {} 后，您应该会看到这些实例是如何从 0 的比例缩放到 2 的比例，然后再缩放回来的。","If you haven't already added an instance of this object to a room, go ahead and add it now (only one!), then press the {}Play {}button {}. Once the game is running press the {}&lt;Enter&gt;{} key various times to see the lives change.":"如果您尚未将此对象的实例添加到房间，请立即添加它(只有一个！)，然后按{}播放{}按钮{}。游戏运行后，按下{}<回车>{}键不同的次数即可看到生活的变化。","Image alpha is calculated as a value from 0 to 1, where 0 is fully transparent and 1 is fully opaque (by default it's set to 1). So in this example, all we're doing is setting the image alpha to a random decimal value from 0 to 1. Place a few instances of this object in a room, and then click the {}Play {}button {}&nbsp;at the top of the IDE.":"图像 Alpha 的计算范围为 0 到 1 之间的值，其中 0 表示完全透明，1 表示完全不透明 (默认情况下设置为 1)。因此，在本例中，我们要做的就是将图像 Alpha 设置为从 0 到 1 的随机十进制值。将此对象的几个实例放置在房间中，然后单击 IDE 顶部的{}播放{}按钮 {} 。","In all the examples so far we've been drawing the sprite assigned to the instance, but that doesn't always have to be the case. {}You can draw anything you want{} in the draw event, regardless of the sprite assigned. To illustrate this point, we'll change the code that we have currently by removing the {}draw_self(){} call and replace with a function to draw a coloured ellipse, like this:":"在到目前为止的所有示例中，我们都绘制了分配给实例的精灵，但情况并不总是如此。{}您可以在绘制事件中绘制任何您想要的内容{}，而不管指定的精灵是什么。为了说明这一点，我们将更改当前拥有的代码，方法是删除 {}draw_self(){} 调用，并替换为绘制彩色椭圆的函数，如下所示：","In this Key Down Event, add the following GML Visual or GML:":"在此按下键事件中，添加以下 GML 可视或 GML：","In this code we initialise a variable for the player lives, but we also create a variable to hold the width of the GUI layer, so that we can position things correctly relative to the right of the screen. We could just hardcode a value into the code and use that, but that would mean that if we make any changes to the size of the room, or if we add cameras etc... later, then we'd need to go through the code and change the value everywhere. Using the {}{}display_get_gui_width(){}{}&nbsp;function instead means that we don't need to worry about any future changes like that as the code will adapt automatically to whatever size the GUI layer ends up.":"在这段代码中，我们为 player_lives 初始化了一个变量，但我们还创建了一个变量来保持 GUI 层的宽度，这样我们就可以相对于屏幕的右侧正确地定位东西。我们可以只将一个值硬编码到代码中并使用它，但这意味着如果我们对房间的大小进行任何更改，或者如果我们添加摄像头等……。稍后，我们需要遍历代码并在任何地方更改值。相反，使用 {}{}display_get_gui_width(){}{} 函数意味着我们不需要担心任何类似的未来更改，因为代码将自动适应图形用户界面层最终的大小。","In this event add the following:":"在这种情况下，添加以下内容：","In this example, we are going to use the GUI layer to draw some sprites. The most obvious use for this is to draw the players lives, so lets go ahead and do just that! You'll need a sprite for this example - which should be about 64x64 pixels - but it shouldn't be assigned to the object, as we'll be drawing it ourselves.":"在本例中，我们将使用图形用户界面层来绘制一些精灵。最明显的用处是画出玩家的生活，所以让我们继续这样做吧！在本例中，您需要一个精灵 -- 它应该大约是 64x64 像素 -- 但是它不应该被分配给对象，因为我们将自己绘制它。","In this example, we're going to blend different colours with the sprite while a key is pressed and held down, and so you'll need to open (or create) an object, assign it a sprite, and then give the object a {}Key Down &lt;Space&gt; Event{}.":"在本例中，我们将在按住某个键的同时将不同的颜色与精灵混合，因此您需要打开(或创建)一个对象，为其指定一个精灵，然后为该对象指定一个{}按下键&lt;空格&gt;事件{}。","In this example, we're going to use some simple maths to make an instance scale the sprite up and down in a loop. To start with, open (or create) an object, assign it a sprite, and then give the object a {}Create Event{}. In this event add the following:":"在本例中，我们将使用一些简单的数学运算来使一个实例在循环中上下缩放精灵。首先，打开(或创建)一个对象，为其指定一个精灵，然后为该对象指定一个{}创建事件{}。在这种情况下，添加以下内容：","In this section we're going to concentrate on simply drawing information to the screen, both as text and as images, and also explain a bit more about the different {}Draw Events{}, specifically, the main {}Draw{}&nbsp;event and the {}Draw GUI {}event (note that in some of the examples you will be required to add other events, but we'll explain these as we come to them).":"在本节中，我们将专注于将信息以文本和图像的形式简单地绘制到屏幕上，还将更多地解释不同的{}绘制事件{}，特别是主{}绘制{} 事件和{}绘制图形用户界面{}事件(请注意，在某些示例中，您将需要添加其他事件，但我们将在介绍这些事件时对其进行解释)。","Let's look at some examples:":"让我们来看一些例子：","Next we want to add a {}Keyboard Pressed &lt;Enter&gt; Event{} to the object, as we'll be using that to change the number of lives every time the Enter key is pressed:":"接下来，我们要向对象添加一个{}按下键盘回车的事件{}，因为我们将使用该事件来更改每次按下回车键时的生命数：","Now add a {}Step Event{} to the object with this:":"现在向对象添加一个{}步事件{}，如下所示：","Now, as mentioned in the section on {}Objects And Instances{}, if you don't add a Draw Event to the object, then {}GameMaker{} will default draw, meaning that if the object has a sprite assigned to it this sprite will be drawn, complete with any transforms that have been added. What do we mean by transforms? Well, each object has a number of built-in&nbsp;{}variable{}{}s{} that will control how an instance of the object draws its sprite when default drawing, and you can change these variables as the game runs to change the way the sprite is drawn.":"现在，正如在{}对象和实例{}一节中提到的，如果您不将绘制事件添加到对象，则{}GameMaker{}将默认绘制，这意味着如果为对象指定了一个精灵，则将绘制该精灵，并完成已添加的所有变换。我们所说的变形是什么意思？嗯，每个对象都有许多内置的{}变量{}{}{}，它们将控制对象的实例在默认绘制时如何绘制其精灵，您可以在游戏运行时更改这些变量来更改绘制精灵的方式。","One important thing to note about this, is that even though we aren't drawing the assigned sprite, {}it will still be used for collision detection{}. So, while you may be drawing one thing, collisions will still be calculated based on the assigned sprite as if it was placed in the room along with the instance, even if it's not visible. This is quite handy actually, as it means you can draw different sprites, but maintain a single {}collision mask{} based on the assigned sprite. Also note that you can still apply the different transforms like X/Y scale, and collisions will be based on the changed size, even though there is nothing being drawn to show this.":"需要注意的一点是，即使我们没有绘制指定的精灵，{}它仍将用于碰撞检测{}。因此，虽然您可能正在绘制一件东西，但碰撞仍将基于指定的精灵计算，就像它与实例一起放置在房间中一样，即使它不可见。这实际上很方便，因为这意味着你可以绘制不同的精灵，但基于指定的精灵维护一个单一的{}碰撞遮罩{}。还请注意，您仍然可以应用不同的变换，如X/Y比例，碰撞将基于更改的大小，即使没有绘制任何内容来显示这一点。",'One last thing... change the " {}image_yscale{}" section to " {}1 - _val{}" and see what happens!':'最后一件事 ..。将 "{}image_yscale{}" 部分更改为 "{}1-_val{}"，看看会发生什么！',"Place a few instances of this object in a room, and then click the Play button {} at the top of the IDE, and test holding down and releasing the {}Space {}key. You should see that each instance will change it's colour rapidly while the key is held down, and stop changing when it is released:":"将此对象的几个实例放置在房间中，然后单击IDE顶部的播放按钮 {}，并测试按住并松开{}空格{}键。您应该会看到，按住按键的同时，每个实例都会快速更改其颜色，并在释放时停止更改：","Run the project again and this time you'll see something very different!":"再次运行该项目，这一次您将看到非常不同的东西！","Run the project again and you should see this:":"再次运行该项目，您应该会看到以下内容：","The GUI Layer":"GUI 层","The above examples illustrate just some of the many ways that you can manipulate the object sprite when {}GameMaker{} is default drawing, but what about if you want to draw more than one thing for an object? In those cases you need to use the {}Draw Event{} to explicitly tell {}GameMaker{} what to draw, which is what we'll do in the following examples.":"上面的例子只是说明了当 {}GameMaker{} 是默认绘制时，您可以操作对象精灵的许多方法中的一部分，但是如果您想要为一个对象绘制多个东西怎么办？在这些情况下，您需要使用 {} 绘制事件 {} 来显式地告诉 {}GameMaker{} 要绘制什么，这就是我们将在以下示例中执行的操作。","The following examples are all going to be using the {}Draw GUI{} event, so you'll need to create an object and add that event to it. Note that the object doesn't need a sprite assigned, as we are not wanting to default draw anything, nor do we need it to detect collisions. Objects like this, that are only designed for drawing things or controlling certain aspects of the game are often called {}Controller Objects{}. Also note that we will be using the same object for all the examples, so we recommend that you go through them one after the other (although this is not strictly necessary).":"下面的示例都将使用{}绘制图形用户界面{}事件，因此您需要创建一个对象并将该事件添加到其中。注意，对象不需要指定精灵，因为我们不想默认绘制任何东西，也不需要它来检测碰撞。像这样只为绘制东西或控制游戏某些方面而设计的对象通常被称为{}控制器对象{}。还要注意，我们将对所有示例使用相同的对象，因此我们建议您逐一查看它们(尽管这并不是绝对必要的)。","The {}alpha {}value is what controls the transparency of what's being drawn, and in {}GameMaker{}, you can use the {}image_alpha{} built-in variable to change how transparent the assigned sprite is. To see how this works, open (or create) an object, assign it a sprite, and then give the object a {}Create Event{}. In the Create Event, simply add the following GML Visual or GML:":"{}Alpha{} 值控制正在绘制的内容的透明度，在 {}GameMaker{} 中，您可以使用内置变量 {}image_alpha{} 更改指定的精灵的透明度。要了解这是如何工作的，请打开 (或创建) 一个对象，为其指定一个精灵，然后为该对象指定一个 {} 创建事件 {}。在创建事件中，只需添加以下 GML 可视或 GML：","This final example covers drawing a healthbar to the GUI layer. There are a number of ways that this can be done, but {}GameMaker{} has a built in function specifically for doing healthbars, so that's what we'll be using here, although you can create your own using sprites or shapes too. To start with, as before, we need to initialise a varaible to hold the health value, so add the following GML Visual or GML into the {}Create Event{} of the object (after any other code that may already be there):":"最后一个示例介绍如何将健康条绘制到 GUI 层。有很多方法可以做到这一点，但 {}GameMaker{} 有一个专门用于制作健康条的内置功能，所以这就是我们在这里使用的，尽管你也可以使用精灵或形状来创建自己的功能。首先，与前面一样，我们需要初始化一个变量来保存健康值，因此将以下 GML 可视或 GML 添加到对象的 {} 创建事件 {} 中 (在可能已经存在的任何其他代码之后)：","This section (and the following section on {}Movement and Controls{}) is aimed at giving you practical examples of GML or GML Visual to enable you to get started as quickly as possible making your first game projects. We won't be explaining things in too much depth as we want you to get started making stuff as quickly as possible, so we encourage you to explore any links as you go along and to use the \"search\" function of the manual to look for additional information on anything you aren't sure about.":'本部分 (以及下一节关于{}运动和控制{}的内容) 旨在为您提供 GML 或 GML 可视化的实用示例，使您能够尽快开始制作您的第一个游戏项目。我们不会太深入地解释事情，因为我们希望你尽快开始制作东西，所以我们鼓励你在进行过程中探索任何链接，并使用手册的 " 搜索 " 功能来寻找关于任何你不确定的东西的额外信息。',"To start with, we need to add some new variables to the object in the {}Create Event{} (if you've done the previous example, add the following below what's already there):":"首先，我们需要向{}创建事件{}中的对象添加一些新变量(如果您已经完成了前面的示例，请在下面添加已有的内容)：","We also want to add a {}Keyboard Down &lt;Space&gt; Event{} to the object, as we'll be using that to increment the score every time you press the Space key.":"我们还希望向对象添加一个{}键盘按下&lt;空格键&gt;事件{}，因为每次按空格键时，我们都会使用该事件来增加分数。",'We are going to use this variable to rotate " {}spr_Two{}" over time, and draw it overlayed on the sprite assigned to the object (" {}spr_One{}"). To do this we need to add a {}Draw Event {}to the object. By doing this we are telling {}GameMaker{} that we want to take over what the instance draws, which means that our code will include a call to the {}{}draw_self(){}{}&nbsp;function or {}{}Draw Self{}{}&nbsp;action. This action simply replicates what the object does when no Draw Event is present and it is default drawing the assigned sprite. We\'ll then draw the second sprite that we want to use as the overlay sprite that is rotating. The GML Visual and GML looks like this:':'我们将使用该变量随时间旋转 "{}spr_Two{}"，并将其绘制在分配给对象的精灵上 ("{}spr_One{}")。为此，我们需要向对象添加一个 {} 绘制事件 {}。通过这样做，我们告诉 {}GameMaker{} 我们希望接管实例绘制的内容，这意味着我们的代码将包括对 {}{}draw_self(){}{} 函数或 {}{} 绘制自身 {}{} 操作的调用。此操作只是复制对象在不存在绘制事件时所做的操作，并且它是默认绘制指定的精灵。然后，我们将绘制第二个精灵，我们希望将其用作旋转的叠加精灵。GML 可视和 GML 如下所示：',"We hope that after doing these examples you have a bit more confidence when using {}GameMaker{} and a bit more understanding of how it all works. The next section will explore how to get these things you've been drawing to move around the room as well as accept - and respond to - user input.":"我们希望在做完这些例子之后，你在使用 {}GameMaker{} 时会有更多的信心，对它的工作原理有更多的了解。下一节将探讨如何让这些你一直在画的东西在房间里移动，以及接受和响应用户的输入。","We mentioned at the top of the page that we'd be talking about the {}Draw GUI Event{} as well as the Draw Event, so let's look at that now. The Draw GUI Event works on something called the {} {}GUI{} Layer{}, which is a special drawing layer of a fixed width and height that is drawn over the instances in the room. The great thing about the GUI layer is that {} it doesn't move with the room camera{}, so it's the ideal place to add static GUI items, like scores, healthbars and other information that your game requires to communicate to the user. You can find out more information on the GUI layer from the {}Draw Events{}&nbsp;section of the manual.":"我们在页面顶部提到，我们将讨论 {} 绘制 GUI 事件 {} 以及绘制事件，现在让我们来看看这一点。绘制图形用户界面事件作用于名为 {}{} 图形用户界面{}层{} 的东西，它是在房间中的实例上绘制的具有固定宽度和高度的特殊绘制层。GUI 层的好处是{}它不会随着房间摄像头移动{}，所以它是添加静态图形用户界面项目的理想位置，比如分数、健康条和其他你的游戏需要与用户交流的信息。您可以从手册的 {} 绘制事件 {} 部分找到有关图形用户界面层的更多信息。","We want to use the arrow keys to change the health value up or down depending on which arrow key is pressed, and we could do that by adding in two {}Keyboard Pressed &lt;Arrow&gt;{} events, however it's probably easier to use a {}Step Event{} and some code to check for the keys, so go ahead and add a {}Step Event{} now with the following GML Visual or GML:":"我们希望使用箭头键根据按下的箭头键来向上或向下更改健康值，我们可以通过添加两个按下键盘的 {} 箭头 {} 事件来实现这一点，但是使用 {} 步事件 {} 和一些代码来检查按键可能更容易，所以现在使用以下 GML 可视化或 GML 继续添加一个 {} 步事件 {}：","When drawing to the GUI layer, the top-left corner is the origin position, and to the right is +X and down is +Y. This makes positioning text and graphics very easy, as you'll see in this example. All we're going to do here is draw a value that represents the player score, so in our object we'll need to add a {}Create Event {}to initialise a variable to hold this value, like this:":"当绘制到图形用户界面层时，左上角是原点位置，右上角是 +X，下是 +Y。这使得定位文本和图形非常容易，如您将在本例中看到的。我们在这里要做的就是提取一个表示球员得分的值，因此在我们的对象中，我们需要添加一个 {} 创建事件 {} 来初始化一个变量来保存该值，如下所示：","When your object is default drawing a sprite, this sprite is actually being drawn {}blended {}(or {}tinted{}) with a colour, and this colour value is stored in the {}image_blend{} built-in variable. By default this colour is white, which essentially means that no colour will be added to the sprite when it is shown on the screen. However, you can use other colours to achieve special effects, for example, use red to show the instance has received some damage.":"当您的对象是默认绘制一个精灵时，这个精灵实际上是用一种颜色来绘制的 {} 混合 {}( 或 {} 着色 {})，并且该颜色值存储在 {}image_blend{} 内置变量中。默认情况下，此颜色为白色，这基本上意味着当精灵显示在屏幕上时，不会添加任何颜色。但是，您可以使用其他颜色来实现特殊效果，例如，使用红色来表示实例受到了一些损害。","With that done, we can actually get around to drawing the healthbar, which is done in the Draw GUI event, adding the following (after anything else that is already there):":"完成这些工作后，我们实际上可以开始绘制健康条，这是在绘制 GUI 事件中完成的，添加以下内容 (在已有的任何内容之后)：","You can draw things in the Draw Event other than sprites too, like text, or shapes. In this example, we'll use the GML Visual or GML {}draw_self(){}&nbsp;function to draw the object sprite, but we'll also draw some other stuff, starting with some {}text{}. For this example, you'll need a sprite and an object (with the sprite assigned to it). In the object, first add a {}Create Event{} with this GML Visual or GML:":"您也可以在绘制事件中绘制精灵以外的对象，如文本或形状。在本例中，我们将使用 GML 可视化或 GML {}draw_self(){} 函数来绘制对象精灵，但我们还将绘制一些其他内容，从一些 {} 文本 {} 开始。在本例中，您将需要一个精灵和一个对象 (为其指定了精灵)。在对象中，首先使用此 GML 可视化或 GML 添加一个 {} 创建事件 {}：","You should see that each instance of the object draws its sprite with a different transparency, eg:":"您应该看到该对象的每个实例使用不同的透明度绘制其精灵，例如：","You'll notice how we've&nbsp;used {}hard-coded{}&nbsp;(or fixed) values for the x/y position of the text to be drawn, since we don't need it to be relative to any instance as we are drawing to the GUI layer. We've also used the \"set colour\" function to change the colour of the text, as well as the \"transformed\" fucntion to make the actual score value larger, which illustrates how you can go about customising text elements in your own games.":'您将注意到我们如何使用{}硬编码{}(或固定的)值来表示要绘制的文本的 X/Y 位置，因为在绘制到图形用户界面层时，我们不需要它相对于任何实例。我们还使用了"设置颜色"功能来更改文本的颜色，以及使用"转换"功能来使实际的得分值更大，这说明了如何在自己的游戏中自定义文本元素。','You\'ll notice in the above code that we use the {}{}string(){}{}&nbsp;function or {}{}Number To String{}{}&nbsp;action on the "number " variable that we want to draw. This is because all text has to be made up of {}characters{}, not values, and so we need to use this function/action to convert the number value into those characters that we want to draw. In this case we are taking the random number we generated and turning it into a "string" of characters that can be drawn. Also note that we set the text {}alignment{}. This simply tells {}GameMaker{} where to start drawing the text relative to the given position, and in this case we want the text to be centered along the x-axis.':'您会注意到，在上面的代码中，我们使用 {}{}string(){}{} 函数或 {}{} 数值转字符串 {}{} 对要绘制的 "number" 变量进行字符串操作。这是因为所有文本都必须由 {} 字符 {} 组成，而不是值，因此我们需要使用此函数 / 操作将数值转换为我们想要绘制的字符。在本例中，我们将获取我们生成的随机数，并将其转换为可以绘制的 " 字符串"。另请注意，我们设置了文本 {} 对齐方式 {}。这只是告诉 {}GameMaker{} 相对于给定位置从哪里开始绘制文本，在本例中，我们希望文本沿 x 轴居中。','{}Assign the first sprite (" {}spr_One{}" with the center origin) to the object you have created and then add a {}Create Even{}t. In the Create Event add the following GML Visual or GML:':'{}将第一个精灵 ("{}spr_one{}"，中心原点) 分配给您创建的对象，然后添加一个 {} 创建事件 {}。在创建事件中添加以下 GML 可视化或 GML：',"{}Changing Alpha (Transparency){}{}Changing Alpha (Transparency){}":"{}更改 Alpha (透明度){}{}更改 Alpha (透明度){}","{}Changing Colour Blend (Tinting){}{}Changing Colour Blend (Tinting){}":"{}更改颜色混合(调色){}{}更改颜色混合(调色){}","{}Changing Scale{}{}Changing Scale{}":"{}更改比例{}{}更改比例{}","{}Drawing A Healthbar{}{}Drawing A Healthbar{}":"{}绘制健康条{}{}绘制健康条{}","{}Drawing Sprites{}{}Drawing Sprites{}":"{}绘制精灵{}{}绘制精灵{}","{}Drawing Text{}{}Drawing Text{}":"{}绘制文本{}{}绘制文本{}","{}Drawing Things Other Than Sprites{}{}Drawing Things Other Than Sprites{}":"{}绘制精灵以外的东西{}{}绘制精灵以外的东西{}","{}Drawing Two (or more) Sprites Together{}{}Drawing Two (or more) Sprites Together{}":"{}将两个(或更多)精灵绘制在一起{}{}将两个(或更多)精灵绘制在一起{}","{}IMPORTANT! {}Changing the assigned sprite scale using these variables {}will also change the size of the bounding box to match{}, which means that the collision detection area for the sprite will also scale.":"{}重要！{} 使用这些变量更改指定的精灵比例{}也会更改边界框的大小以匹配{}，这意味着精灵的碰撞检测区域也将缩放。","{}NOTE{}: Rooms can be larger than the screen size, so you can have large levels for the player to move around in. This means that in the Room Editor (or in code) you need to define a {}camera {}that follows the action of your game. This is basically a way of setting up a fixed area of the screen to display different parts of the larger room based on - for example - the player position in the room, and is used in a lot of games. Think of the way that the view always follows the main character in classic games like Mario or Zelda. That's done with cameras. For more information see the section {}Room Properties{} on the Room Editor&nbsp;section of the manual.":"{}注意{}：房间可以比屏幕大，所以你可以有很大的关卡供玩家走动。这意味着在房间编辑器中(或在代码中)，您需要定义一个跟随游戏动作的{}相机{}。这基本上是一种根据玩家在房间中的位置来设置屏幕的固定区域来显示较大房间的不同部分的方式，并在许多游戏中使用。想想看，在马里奥或塞尔达这样的经典游戏中，人们的视角总是跟随着主角。这是用相机完成的。有关更多信息，请参阅手册的房间编辑器部分中的{}房间属性{}一节。","{}NOTE{}: You can find a list of all the built in variables that can be used for transforming instance sprites {}here{}. GML Visual users have some dedicated actions that affect these variables, which you can find {}here{}, and you can also use the actual variables themselves along with the {}Get Instance Variable{}&nbsp;and {}Set Instance Variable{}&nbsp;actions.":"{}注意{}：您可以在{}此处{}找到可用于转换实例精灵的所有内置变量的列表。GML 可视化用户有一些影响这些变量的专用操作，您可以在{}此处{}找到这些操作，您还可以将实际变量本身与{}获取实例变量{}和{}设置实例变量{}操作一起使用。","{}The sprite now points towards the mouse regardless of where you move it to! As you can see, layering sprites is a great way to add details to an object or to have something move independently of the \"base\" sprite assigned to the object, and it's a powerful tool that you'll probably use a lot in your own projects.":"{}精灵现在指向鼠标，无论你将它移动到哪里！正如你所看到的，分层精灵是一种很好的方法来给对象添加细节，或者让一些东西独立于指定给对象的基础精灵移动，这是一个强大的工具，你可能会在你自己的项目中大量使用。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="..",gTopicId="2.0_8"</script><script type="text/javascript" src="../template/scripts/rh.min.js"></script><script type="text/javascript" src="../template/scripts/common.min.js"></script><script type="text/javascript" src="../template/scripts/topic.min.js"></script><script type="text/javascript" src="../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Drawing</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../assets/css/default.css" type="text/css"><script src="../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Some basic code to show people how things are drawn."><meta name="rh-index-keywords" content="Quick Start - Drawing"><meta name="search-keywords" content="drawing,draw event,GUI layer"><meta name="robots" content="NOODP"><meta name="brsnext" value="Quick_Start_Guide/Movement_And_Controls.htm"><meta name="brsprev" value="Quick_Start_Guide/Rooms.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Drawing"><span>Drawing</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>Drawing</h1><p>This section (and the following section on <a href="Movement_And_Controls.htm">Movement and Controls</a>) is aimed at giving you practical examples of GML or GML Visual to enable you to get started as quickly as possible making your first game projects. We won't be explaining things in too much depth as we want you to get started making stuff as quickly as possible, so we encourage you to explore any links as you go along and to use the "search" function of the manual to look for additional information on anything you aren't sure about.</p><p>In this section we're going to concentrate on simply drawing information to the screen, both as text and as images, and also explain a bit more about the different <strong>Draw Events</strong>, specifically, the main <strong>Draw</strong>&nbsp;event and the <strong>Draw GUI</strong> event (note that in some of the examples you will be required to add other events, but we'll explain these as we come to them).</p><p><img alt="The Draw Events" class="center" height="378" src="../assets/Images/QS_Guide/QS_DrawEvents.png" width="268"></p><p>Before going any further, you might want to make a new project (either GML or GML Visual) from the <a href="../Introduction/The_Start_Page.htm">Start Page</a>, and add (or create) a few sprites as well as an object or two, as we'll be giving you some code that you can test using these. Even a white square will work for now as the sprite for our object!</p><p>Now, as mentioned in the section on <a href="Objects_And_Instances.htm">Objects And Instances</a>, if you don't add a Draw Event to the object, then <span data-keyref="GameMaker Name">GameMaker</span> will default draw, meaning that if the object has a sprite assigned to it this sprite will be drawn, complete with any transforms that have been added. What do we mean by transforms? Well, each object has a number of built-in&nbsp;<a class="tooltip" title="A variable is a named value within a program which can be modified, stored and displayed whenever required. For example, if we have an integer variable with a name XYZ and it stores a value 10, we can then do things like A = XYZ + 10, which will set the value of the variable A to 20, since XYZ is 10 and we are adding 10 to it. You can also change variable values using operators, so doing XYZ = XYZ + 100 would modify the value of our XYZ variable to be equal to 110. Variables can also be used to store identifiers and references to different assets.">variable</a><span class="glossextra">s</span> that will control how an instance of the object draws its sprite when default drawing, and you can change these variables as the game runs to change the way the sprite is drawn.</p><p class="note"><strong>NOTE</strong>: You can find a list of all the built in variables that can be used for transforming instance sprites <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/Sprite_Instance_Variables.htm">here</a>. GML Visual users have some dedicated actions that affect these variables, which you can find <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Drawing/Drawing_Actions.htm">here</a>, and you can also use the actual variables themselves along with the <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Get_Instance_Variable.htm">Get Instance Variable</a>&nbsp;and <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Instance/Set_Instance_Variable.htm">Set Instance Variable</a>&nbsp;actions.</p><p>Let's look at some examples:</p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down" href="#"><span data-open-text="true" data-skip-index="true">Changing Alpha (Transparency)</span><span data-close-text="true">Changing Alpha (Transparency)</span></a></p><div class="droptext" data-targetname="drop_down"><p class="dropspot">The <strong>alpha</strong> value is what controls the transparency of what's being drawn, and in <span data-keyref="GameMaker Name">GameMaker</span>, you can use the <span class="inline">image_alpha</span> built-in variable to change how transparent the assigned sprite is. To see how this works, open (or create) an object, assign it a sprite, and then give the object a <strong>Create Event</strong>. In the Create Event, simply add the following GML Visual or GML:</p><p class="dropspot"><img alt="GML VisualDraw Example For Transparency" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_1.png"></p><p class="code">var _val = random(1);<br>image_alpha = _val;</p><p class="dropspot">Image alpha is calculated as a value from 0 to 1, where 0 is fully transparent and 1 is fully opaque (by default it's set to 1). So in this example, all we're doing is setting the image alpha to a random decimal value from 0 to 1. Place a few instances of this object in a room, and then click the <strong>Play</strong> button <img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png">&nbsp;at the top of the IDE.</p><p class="dropspot">You should see that each instance of the object draws its sprite with a different transparency, eg:</p><p class="dropspot"><img alt="Example Of Sprites Drawn With Different Alpha Values" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_1.png"></p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down1" href="#"><span data-open-text="true" data-skip-index="true">Changing Colour Blend (Tinting)</span><span data-close-text="true">Changing Colour Blend (Tinting)</span></a></p><div class="droptext" data-targetname="drop_down1"><p class="dropspot">When your object is default drawing a sprite, this sprite is actually being drawn <strong>blended</strong> (or <strong>tinted</strong>) with a colour, and this colour value is stored in the <span class="inline">image_blend</span> built-in variable. By default this colour is white, which essentially means that no colour will be added to the sprite when it is shown on the screen. However, you can use other colours to achieve special effects, for example, use red to show the instance has received some damage.</p><p class="dropspot">In this example, we're going to blend different colours with the sprite while a key is pressed and held down, and so you'll need to open (or create) an object, assign it a sprite, and then give the object a <strong>Key Down &lt;Space&gt; Event</strong>.</p><p class="dropspot"><img alt="Add Key Down Event" class="center" src="../assets/Images/QS_Guide/QS_Add_SpaceKeyPressEvent.png"></p><p class="dropspot">In this Key Down Event, add the following GML Visual or GML:</p><p class="dropspot"><img alt="GML VisualExample Using Key Down Event" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_2.png"></p><p class="code">var _col = choose(c_red, c_green, c_blue, c_yellow, c_fuchsia, c_orange);<br>image_blend = _col;</p><p class="dropspot">Place a few instances of this object in a room, and then click the Play button <img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png"> at the top of the IDE, and test holding down and releasing the <em>Space</em> key. You should see that each instance will change it's colour rapidly while the key is held down, and stop changing when it is released:</p><p class="dropspot"><img alt="Example Showing Colour Blending" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_2.png"></p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down2" href="#"><span data-open-text="true" data-skip-index="true">Changing Scale</span><span data-close-text="true">Changing Scale</span></a></p><div class="droptext" data-targetname="drop_down2"><p class="dropspot">Another of the properties that we can change for our sprite is the <strong>scale</strong> value, permitting us to draw it bigger or smaller whenever we want. Scale is caculated independently along the X and Y axis by two seperate variables, the <span class="inline">image_xscale</span> variable and the <span class="inline">image_yscale</span> variable. By default these are set to 1, and they act like <strong>multipliers</strong>, so a value of 0.5 would be half scale and a value of 2 would be double the scale.</p><p class="note"><strong>IMPORTANT!</strong> Changing the assigned sprite scale using these variables <strong>will also change the size of the bounding box to match</strong>, which means that the collision detection area for the sprite will also scale.</p><p class="dropspot">In this example, we're going to use some simple maths to make an instance scale the sprite up and down in a loop. To start with, open (or create) an object, assign it a sprite, and then give the object a <strong>Create Event</strong>. In this event add the following:</p><p class="dropspot"><img alt="GML VisualSet Variable Example" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_3_1.png"></p><p class="code">timer = 0;</p><p class="dropspot">Now add a <strong>Step Event</strong> to the object with this:</p><p class="dropspot"><img alt="GML VisualActions To Change Sprite Scale" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_3_2.png"></p><p class="code">timer = timer + 1;<br>var _val = dsin(timer);<br>image_xscale = 1 + _val;<br>image_yscale = 1 + _val;</p><p class="dropspot">Here we're using the maths function <a href="../GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/dsin.htm"><span class="inline">dsin()</span></a>&nbsp;to generate a value between -1 and 1 using the timer variable, and then applying that to the scale variables. After placing some instances into a room and pressing the <strong>Play</strong> button <img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png">, you should see how the instances scale up and down from a scale of 0 to a scale of 2 and then back again.</p><p class="dropspot"><img class="center" src="../assets/Images/QS_Guide/QS_DrawExample_3.gif" title="Animation Showing Sprite Scaling"></p><p class="dropspot">One last thing... change the " <span class="inline">image_yscale</span>" section to " <span class="inline">1 - _val</span>" and see what happens!</p><p class="dropspot">&nbsp;</p></div><p>&nbsp;</p><p>The above examples illustrate just some of the many ways that you can manipulate the object sprite when <span data-keyref="GameMaker Name">GameMaker</span> is default drawing, but what about if you want to draw more than one thing for an object? In those cases you need to use the <strong>Draw Event</strong> to explicitly tell <span data-keyref="GameMaker Name">GameMaker</span> what to draw, which is what we'll do in the following examples.</p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down3" href="#"><span data-open-text="true" data-skip-index="true">Drawing Two (or more) Sprites Together</span><span data-close-text="true">Drawing Two (or more) Sprites Together</span></a></p><div class="droptext" data-targetname="drop_down3"><p class="dropspot">For this example, you'll need two sprites and one object. Call the sprites " <span class="inline">spr_One</span>" and " <span class="inline">spr_Two</span>", and then set the " <span class="inline">spr_One</span>" origin to the center and for " <span class="inline">spr_Two</span>" set its origin to the middle-left:</p><p class="dropspot"><img alt="Show Origins For Sprites" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_1.png">Assign the first sprite (" <span class="inline">spr_One</span>" with the center origin) to the object you have created and then add a <strong>Create Even</strong>t. In the Create Event add the following GML Visual or GML:</p><p class="dropspot"><img alt="Set Draw Angle Variable In DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_1.png"></p><p class="code">draw_angle = 0;</p><p class="dropspot">We are going to use this variable to rotate " <span class="inline">spr_Two</span>" over time, and draw it overlayed on the sprite assigned to the object (" <span class="inline">spr_One</span>"). To do this we need to add a <strong>Draw Event</strong> to the object. By doing this we are telling <span data-keyref="GameMaker Name">GameMaker</span> that we want to take over what the instance draws, which means that our code will include a call to the <a href="../GameMaker_Language/GML_Reference/Drawing/Sprites_And_Tiles/draw_self.htm"><span class="inline">draw_self()</span></a>&nbsp;function or <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Drawing/Draw_Self.htm"><strong>Draw Self</strong></a>&nbsp;action. This action simply replicates what the object does when no Draw Event is present and it is default drawing the assigned sprite. We'll then draw the second sprite that we want to use as the overlay sprite that is rotating. The GML Visual and GML looks like this:</p><p class="dropspot"><img alt="Draw Two Sprites With DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_2.png"></p><p class="code">draw_self();<br>draw_angle = draw_angle + 0.5;<br>draw_sprite_ext(spr_Two, 0, x, y, 1, 1, draw_angle, c_red, 1);</p><p class="dropspot">Add a number of instances of the object into the room editor and then press the <strong>Play</strong> button <img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png"> at the top of the <a class="tooltip" title="The IDE, or Integrated Development Environment, is a software application that provides comprehensive facilities to computer programmers for software development. In this case, the entire frontend of GameMaker Studio 2 is considered the IDE, and includes sections to create graphics, add sounds, and add code to make your games.">IDE</a>. If all has gone correctly you should see something like this now:</p><p class="dropspot"><img alt="Animation Drawing Two Sprites Together" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_2.gif"></p><p class="dropspot">Before we leave this example, let's just tweak it a little bit and instead of having " <span class="inline">spr_Two</span>" simply rotate, we'll make it point towards the mouse position. For that we need to change the Draw Event GML Visual or GML to look like this:</p><p class="dropspot"><img alt="Edited Draw Code For Drawing Two Sprites With DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_4_3.png"></p><p class="code">draw_self();<br>draw_angle = point_direction(x, y, mouse_x, mouse_y);<br>draw_sprite_ext(spr_Two, 0, x, y, 1, 1, draw_angle, c_red, 1);</p><p class="dropspot">Run the project again and this time you'll see something very different!</p><p class="dropspot"><img alt="Animation Drawing Two Sprites Pointing At Mouse" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_4_3.gif">The sprite now points towards the mouse regardless of where you move it to! As you can see, layering sprites is a great way to add details to an object or to have something move independently of the "base" sprite assigned to the object, and it's a powerful tool that you'll probably use a lot in your own projects.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down4" href="#"><span data-open-text="true" data-skip-index="true">Drawing Things Other Than Sprites</span><span data-close-text="true">Drawing Things Other Than Sprites</span></a></p><div class="droptext" data-targetname="drop_down4"><p class="dropspot">You can draw things in the Draw Event other than sprites too, like text, or shapes. In this example, we'll use the GML Visual or GML <span class="inline">draw_self()</span>&nbsp;function to draw the object sprite, but we'll also draw some other stuff, starting with some <strong>text</strong>. For this example, you'll need a sprite and an object (with the sprite assigned to it). In the object, first add a <strong>Create Event</strong> with this GML Visual or GML:</p><p class="dropspot"><img alt="Setting Variables Using DnD" class="center" height="506" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_1_1.png" width="317"></p><p class="code">name = choose("Fred", "Jonas", "Sharon", "Kate", "Frank", "John", "Monica", "Amanda");<br>number = irandom(100);</p><p class="dropspot">All this does is tell&nbsp;<span data-keyref="GameMaker Name">GameMaker</span> to choose one of the listed names and assign it to a variable, as well as generate a random number from 0 to 100 for each instance of the object. We want to draw these values to the screen, and so for that you need to now add a <strong>Draw Event</strong> and in it add the following GML Visual or GML:</p><p class="dropspot"><img alt="Drawing Text Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_1.png"></p><p class="code">draw_self();<br>draw_set_halign(fa_center);<br>draw_text(x, y + 32, "My name is " + name);<br>draw_text(x, y + 48, "My number is " + string(number));</p><p class="dropspot">You'll notice in the above code that we use the <a href="../GameMaker_Language/GML_Reference/Strings/string.htm"><span class="inline">string()</span></a>&nbsp;function or <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Data_Types/Number_To_String.htm"><strong>Number To String</strong></a>&nbsp;action on the "number " variable that we want to draw. This is because all text has to be made up of <em>characters</em>, not values, and so we need to use this function/action to convert the number value into those characters that we want to draw. In this case we are taking the random number we generated and turning it into a "string" of characters that can be drawn. Also note that we set the text <strong>alignment</strong>. This simply tells <span data-keyref="GameMaker Name">GameMaker</span> where to start drawing the text relative to the given position, and in this case we want the text to be centered along the x-axis.</p><p class="dropspot">Add a number of instances of the object into the room editor and then press the Play button <img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png">&nbsp; at the top of the IDE. You should see something like this:</p><p class="dropspot"><img alt="Sprites Being Drawn Along With Text" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_5_1.png"></p><p class="dropspot">In all the examples so far we've been drawing the sprite assigned to the instance, but that doesn't always have to be the case. <strong>You can draw anything you want</strong> in the draw event, regardless of the sprite assigned. To illustrate this point, we'll change the code that we have currently by removing the <span class="inline">draw_self()</span> call and replace with a function to draw a coloured ellipse, like this:</p><p class="dropspot"><img alt="Drawing Shapes Along With Text Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_5_2.png"></p><p class="code">draw_ellipse_colour(x - 50, y - 32, x + 50, y + 32, c_fuchsia, c_lime, false);<br>draw_set_halign(fa_center);<br>draw_text(x, y + 32, "My name is " + name);<br>draw_text(x, y + 48, "My number is " + string(number));</p><p class="dropspot">Run the project again and you should see this:</p><p class="dropspot"><img alt="Example Of Drawing Shapes And Text Together" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_5_2.png"></p><p class="dropspot">One important thing to note about this, is that even though we aren't drawing the assigned sprite, <strong>it will still be used for collision detection</strong>. So, while you may be drawing one thing, collisions will still be calculated based on the assigned sprite as if it was placed in the room along with the instance, even if it's not visible. This is quite handy actually, as it means you can draw different sprites, but maintain a single <strong>collision mask</strong> based on the assigned sprite. Also note that you can still apply the different transforms like X/Y scale, and collisions will be based on the changed size, even though there is nothing being drawn to show this.</p></div><p>&nbsp;</p><p>&nbsp;</p><h1>The GUI Layer</h1><p>We mentioned at the top of the page that we'd be talking about the <strong>Draw GUI Event</strong> as well as the Draw Event, so let's look at that now. The Draw GUI Event works on something called the <strong><a class="tooltip" title="Short for 'Graphical User Interface', which is a user interface that includes graphical elements, such as windows, icons and buttons. In GameMaker you have a specific set of object events (Draw GUI Events) that can draw to this layer specifically designed for things like score, lives, inventories, etc...">GUI</a> Layer</strong>, which is a special drawing layer of a fixed width and height that is drawn over the instances in the room. The great thing about the GUI layer is that <em>it doesn't move with the room camera</em>, so it's the ideal place to add static GUI items, like scores, healthbars and other information that your game requires to communicate to the user. You can find out more information on the GUI layer from the <a href="../The_Asset_Editors/Object_Properties/Draw_Events.htm">Draw Events</a>&nbsp;section of the manual.</p><p class="note"><strong>NOTE</strong>: Rooms can be larger than the screen size, so you can have large levels for the player to move around in. This means that in the Room Editor (or in code) you need to define a <strong>camera</strong> that follows the action of your game. This is basically a way of setting up a fixed area of the screen to display different parts of the larger room based on - for example - the player position in the room, and is used in a lot of games. Think of the way that the view always follows the main character in classic games like Mario or Zelda. That's done with cameras. For more information see the section <a href="../The_Asset_Editors/Room_Properties/Room_Properties.htm">Room Properties</a> on the Room Editor&nbsp;section of the manual.</p><p>The following examples are all going to be using the <strong>Draw GUI</strong> event, so you'll need to create an object and add that event to it. Note that the object doesn't need a sprite assigned, as we are not wanting to default draw anything, nor do we need it to detect collisions. Objects like this, that are only designed for drawing things or controlling certain aspects of the game are often called <strong>Controller Objects</strong>. Also note that we will be using the same object for all the examples, so we recommend that you go through them one after the other (although this is not strictly necessary).</p><p><img alt="Draw GUI Event In An Object" class="center" src="../assets/Images/QS_Guide/QS_DrawGUIObject.png"> <a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down5" href="#"><span data-open-text="true" data-skip-index="true">Drawing Text</span><span data-close-text="true">Drawing Text</span></a></p><div class="droptext" data-targetname="drop_down5"><p class="dropspot">When drawing to the GUI layer, the top-left corner is the origin position, and to the right is +X and down is +Y. This makes positioning text and graphics very easy, as you'll see in this example. All we're going to do here is draw a value that represents the player score, so in our object we'll need to add a <strong>Create Event</strong> to initialise a variable to hold this value, like this:</p><p class="dropspot"><img alt="Defining A Variable Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_1.png"></p><p class="code">player_score = 0;</p><p class="dropspot">We also want to add a <strong>Keyboard Down &lt;Space&gt; Event</strong> to the object, as we'll be using that to increment the score every time you press the Space key.</p><p class="dropspot"><img alt="Adding A Space Key Pressed Event" class="center" src="../assets/Images/QS_Guide/QS_Add_SpaceKeyPressEvent.png"></p><p class="dropspot">In this event add the following:</p><p class="dropspot"><img alt="GML VisualActions In The Space Key Event" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_2.png"></p><p class="code">var _val = irandom(100);<br>player_score = player_score + _val;</p><p class="dropspot">Finally, let's draw the score value in the Draw GUI event, like this:</p><p class="dropspot">In this event add the following:</p><p class="dropspot"><img alt="Drawing Text To The GUI Layer Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_6_3.png"></p><p class="code">draw_set_halign(fa_left);<br>draw_set_colour(c_yellow);<br>draw_text(32, 32, "SCORE:");<br>draw_set_colour(c_white);<br>var _str = string(player_score);<br>draw_text_transformed(32, 48, _str, 2, 2, 0);</p><p class="dropspot">You'll notice how we've&nbsp;used <a class="tooltip" title="In computer programming, the term hard-coded is used to describe code that is considered fixed and not likely to change. Hardcoded features are built into hardware or software in such a way that they cannot be modified later on. For example, if you are making a game and 'hard-code' the player health to 10, then you would be using the value 10 throughout the game code rather than using a variable.">hard-coded</a>&nbsp;(or fixed) values for the x/y position of the text to be drawn, since we don't need it to be relative to any instance as we are drawing to the GUI layer. We've also used the "set colour" function to change the colour of the text, as well as the "transformed" fucntion to make the actual score value larger, which illustrates how you can go about customising text elements in your own games.</p><p class="dropspot">Add a single instance of this object to your room now and then press the <strong>Play</strong> button <img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png">. When the game runs press and release the <span class="inline">&lt;Space&gt;</span> key and you should see the score value increase.</p><p class="dropspot"><img alt="Animation Showing Text Being Drawn To The GUI Layer" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_6.gif"></p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down6" href="#"><span data-open-text="true" data-skip-index="true">Drawing Sprites</span><span data-close-text="true">Drawing Sprites</span></a></p><div class="droptext" data-targetname="drop_down6"><p class="dropspot">In this example, we are going to use the GUI layer to draw some sprites. The most obvious use for this is to draw the players lives, so lets go ahead and do just that! You'll need a sprite for this example - which should be about 64x64 pixels - but it shouldn't be assigned to the object, as we'll be drawing it ourselves.</p><p class="dropspot">To start with, we need to add some new variables to the object in the <strong>Create Event</strong> (if you've done the previous example, add the following below what's already there):</p><p class="dropspot"><img alt="Defining Variables Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_7_1.png"></p><p class="code">player_lives = 3;<br>gui_w = display_get_gui_width();</p><p class="dropspot">In this code we initialise a variable for the player lives, but we also create a variable to hold the width of the GUI layer, so that we can position things correctly relative to the right of the screen. We could just hardcode a value into the code and use that, but that would mean that if we make any changes to the size of the room, or if we add cameras etc... later, then we'd need to go through the code and change the value everywhere. Using the <a href="../GameMaker_Language/GML_Reference/Cameras_And_Display/display_get_gui_width.htm"><span class="inline">display_get_gui_width()</span></a>&nbsp;function instead means that we don't need to worry about any future changes like that as the code will adapt automatically to whatever size the GUI layer ends up.</p><p class="dropspot">Next we want to add a <strong>Keyboard Pressed &lt;Enter&gt; Event</strong> to the object, as we'll be using that to change the number of lives every time the Enter key is pressed:</p><p class="dropspot"><img alt="Adding An Enter Key Pressed Event" class="center" src="../assets/Images/QS_Guide/QS_Add_EnterKeyPressEvent.png"></p><p class="dropspot">In this event add the following:</p><p class="dropspot"><img alt="GML VisualIn The Enter Key Down Event" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_7_2.png"></p><p class="code">player_lives = player_lives - 1;<br><br>if (player_lives &lt; 0)<br>{<br>player_lives = 3;<br>}</p><p class="dropspot">Finally, we need to draw the sprites to the display. For this we'll be using a " <span class="inline">for</span>" loop (information using GML <a href="../GameMaker_Language/GML_Overview/Language_Features/for.htm">here</a>&nbsp;and for GML Visual <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Loops/For.htm">here</a>), along with the GUI width variable to position everything in the top right corner of the screen. So, add this into the Draw Gui Event (after any other actions that it may have from previous examples):</p><p class="dropspot"><img alt="GML VisualActions To Draw Sprites To The GUI Layer" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_7_3.png"></p><p class="code">for (var i = 0; i &lt; player_lives; i += 1)<br>{<br>var _xx = gui_w - 48 - (i * 70);<br>draw_sprite(spr_Heart, 0, _xx, 48);<br>}</p><p class="dropspot">If you haven't already added an instance of this object to a room, go ahead and add it now (only one!), then press the <strong>Play</strong> button <img alt="Play Icon" class="icon" height="24" src="../assets/Images/Icons/Icon_PlayGame.png" width="24">. Once the game is running press the <span class="inline">&lt;Enter&gt;</span> key various times to see the lives change.</p><p class="dropspot"><img alt="Animation Drawing Sprites To The GUI Layer" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_7.gif"></p><p class="dropspot">Before you leave this example, you should experiment with the number of lives and see what happens. At the moment it's set to 3, but change the Create Event and the Key Pressed event to set the value to 5, or 10... if you've done everything right, then the code should adapt and draw them all correctly!</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop_down7" href="#"><span data-open-text="true" data-skip-index="true">Drawing A Healthbar</span><span data-close-text="true">Drawing A Healthbar</span></a></p><div class="droptext" data-targetname="drop_down7"><p class="dropspot">This final example covers drawing a healthbar to the GUI layer. There are a number of ways that this can be done, but <span data-keyref="GameMaker Name">GameMaker</span> has a built in function specifically for doing healthbars, so that's what we'll be using here, although you can create your own using sprites or shapes too. To start with, as before, we need to initialise a varaible to hold the health value, so add the following GML Visual or GML into the <strong>Create Event</strong> of the object (after any other code that may already be there):</p><p class="dropspot"><img alt="Defining A Variable Using DnD" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_8_1.png"></p><p class="code">player_health = 100;</p><p class="dropspot">We want to use the arrow keys to change the health value up or down depending on which arrow key is pressed, and we could do that by adding in two <strong>Keyboard Pressed &lt;Arrow&gt;</strong> events, however it's probably easier to use a <strong>Step Event</strong> and some code to check for the keys, so go ahead and add a <strong>Step Event</strong> now with the following GML Visual or GML:</p><p class="dropspot"><img alt="Step Event GML VisualActions" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_8_2.png"></p><p class="code">if (keyboard_check(vk_up))<br>{<br>&nbsp; &nbsp; if (player_health &lt; 100)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; player_health = player_health + 1;<br>&nbsp; &nbsp; }<br>}<br><br>if (keyboard_check(vk_down))<br>{<br>&nbsp; &nbsp; if (player_health &gt; 0)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; player_health = player_health - 1;<br>&nbsp; &nbsp; }<br>}</p><p class="dropspot">With that done, we can actually get around to drawing the healthbar, which is done in the Draw GUI event, adding the following (after anything else that is already there):</p><p class="dropspot"><img alt="GML VisualFor The Draw GUI Event To Draw A Healthbar" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_DnD_8_3.png"></p><p class="code">var _xx = display_get_gui_width() / 2;<br><br>draw_healthbar(_xx - 50, 24, _xx + 50, 40, player_health, c_black, c_red, c_lime, 0, true, true);</p><p class="dropspot">Add an instance of this object to a room if you haven't already done so (only one, though!), and then press the <strong>Play</strong> button <img alt="Play Icon" class="icon" src="../assets/Images/Icons/Icon_PlayGame.png">. Once the game is running press the <span class="inline">&lt;Up Arrow&gt;</span> and <span class="inline">&lt;Down Arrow&gt;</span> keys various times to see the health change.</p><p class="dropspot"><img alt="Animation Of Drawing A Healthbar" class="center" src="../assets/Images/QS_Guide/QS_DrawExample_8.gif"></p></div><p>&nbsp;</p><p>We hope that after doing these examples you have a bit more confidence when using <span data-keyref="GameMaker Name">GameMaker</span> and a bit more understanding of how it all works. The next section will explore how to get these things you've been drawing to move around the room as well as accept - and respond to - user input.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../Content.htm">Index</a></div><div style="float:right">Next: <a href="Movement_And_Controls.htm">Movement And Controls</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>