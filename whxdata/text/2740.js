rh._.exports({"0":[[" ","json_parse"]],"1":[["json_parse"]],"2":[["json_parse"]],"3":[[" ","json_parse"]],"4":[[" ","This function parses a JSON string and converts it into a collection of nested arrays and structs. An array is the equivalent of a JSON array and a struct is the equivalent of a JSON object."," ","The JSON should be either previously created using ","json_stringify"," or should come from any other valid source."," ","You supply the string to parse, and the function will return the top-level array or struct which can then be used in your code. If you are not sure of the contents of the JSON, you can use the different ","Variable Functions"," (like ","typeof"," and ","struct_get_names"," in case of a struct) to check the returned contents."],[" ","Trying to parse an invalid value (i.e.: not a string, or invalid JSON) will throw an exception error."," ","This function only allows you to load JSON files with a maximum nesting limit of ","128","."," ","Data conversions:\n      "," ","null"," values are parsed as ","undefined","."," ","Any runtime values serialised by ","json_stringify"," will be converted back to runtime values (e.g. ","handles"," and values like ","int64",", ","NaN"," and ","infinity","), however this conversion can be disabled by passing ","true"," into the optional ","inhibit_string_convert"," argument, meaning these will remain as strings."," ","See ","Data Conversions"," for a full overview."," ","See ","Guide To Using JSON"," for more information on how ","GameMaker"," interacts with the JSON format."," ","NOTE"," See ","Guide To Using JSON"," for detailed information on how to work with JSON in ","GameMaker","."],[" ","The function optionally takes a ","Function",", which runs once for each value in the structure, including all nested structs/arrays and all the values inside them."," ","It takes two arguments ","(key, value)"," where ","key"," is the struct key name (","String",") or array index (","Real","), and ","value"," is what's stored in that key/index."," ","The filter function must always return a value. It can return a new value, which replaces the key's value in the final converted format returned by ","json_parse",". If no new value should be returned for a particular key, the function must return the original ","value","."," ","NOTE"," When overriding a key's value in the filter function (using ","return","), make sure you check its type first, as the filter function runs for the root structure and any nested structures as well, meaning accidentally overriding them will result in a broken final structure. See ","Example 3"," at the bottom."],[" ","json_parse","(json, [filter_func], [inhibit_string_convert])"," ","Argument"," ","Type"," ","Description"," ","json"," ","String"," ","The JSON string to parse"," ","filter_func"," ","Function"," ","OPTIONAL"," Filter function that processes each item. Don't pass a value or set this to ","undefined"," if you only want to set ","inhibit_string_convert",". Syntax: ","function(key, value) -> new_value"," ","inhibit_string_convert"," ","Boolean"," ","OPTIONAL"," Set this to ","true"," to disable converting strings into runtime references. Default value: ","false"],[" ","Struct"," or ","Array"],[" ","var json = \"{\\\"myObj\\\": { \\\"apples\\\":10, \\\"oranges\\\":12, \\\"potatoes\\\":100000, \\\"avocados\\\":0 }, \\\"myArray\\\":[0, 1, 2, 2, 4, 0, 1, 5, 1]}\";"," ","\n    var data = json_parse(json);","\n    show_debug_message(data);\n  "," ","The above code creates a new string containing valid JSON, and then calls ","json_parse"," to convert that string into a GML struct. It then prints the result to the debug log."," ","NOTE"," You will notice that the JSON string contains a backslash (","\\",") before every double quote (","\"",") inside it:"," ","json = \"{ ","\\\" ","myObj"," ","\n    This is to ensure that the double quote is read as an actual character within the string, instead of being read as part of the code and closing the string prematurely. This way we are using a backslash to \"escape\" the double quote."," ","\n    If you are loading JSON from an external file however, there is no need to escape characters in that file.\n  "," ","After parsing the JSON string above, if you know its structure, you can use various ","Variable Functions"," to check and read its contents:"," ","var data = json_parse(json);"," ","\n    // Check if the struct has myObj variable","\n    if (variable_struct_exists(data, \"myObj\"))","\n    {","\n        // Check if it's a struct","\n        if (is_struct(data.myObj))","\n        {","\n            // Print all struct members to the log","\n            var _names = variable_struct_get_names(data.myObj);","\n            var _str = \"\";","\n            for (var i = 0; i < array_length(_names); i++;)","\n            {","\n                _str = _names[i] + \": \" + string(variable_struct_get(data.myObj, _names[i]));","\n                show_debug_message(_str);","\n            }","\n        }","\n    }"," ","\n    // Check if the struct has myArray variable","\n    if (variable_struct_exists(data, \"myArray\"))","\n    {","\n        // Check if it's an array","\n        if (is_array(data.myArray))","\n        {","\n            show_debug_message(data.myArray);","\n        }","\n    }\n  "," ","The above code will parse the given JSON string, generating the following console output:"," ","oranges: 12","\n    potatoes: 100000","\n    avocados: 0","\n    apples: 10","\n    [ 0,1,2,2,4,0,1,5,1 ]"],[" ","var json = \"{\\\"myObj\\\": { \\\"apples\\\":10, \\\"oranges\\\":12, \\\"potatoes\\\":100000, \\\"avocados\\\":0 }, \\\"myArray\\\":[0, 1, 2, 2, 4, 0, 1, 5, 1]}\";"," ","\n    var data = json_parse(json, function (key, value)","\n    {","\n        show_debug_message($\"Key: {key}, Value: {value}\");","\n        return value;","\n    });\n  "," ","The above code takes the same JSON string from the previous example, and converts it into a GML struct, however this time it uses a filter function."," ","The filter function prints the key and value of each item to the Output Log:"," ","Key: apples, Value: 10","\n    Key: oranges, Value: 12","\n    Key: potatoes, Value: 100000","\n    Key: avocados, Value: 0","\n    Key: myObj, Value: { apples : 10, oranges : 12, potatoes : 100000, avocados : 0 }","\n    Key: 8, Value: 1","\n    Key: 7, Value: 5","\n    Key: 6, Value: 1","\n    Key: 5, Value: 0","\n    Key: 4, Value: 4","\n    Key: 3, Value: 2","\n    Key: 2, Value: 2","\n    Key: 1, Value: 1","\n    Key: 0, Value: 0","\n    Key: myArray, Value: [ 0,1,2,2,4,0,1,5,1 ]","\n    Key: , Value: { myObj : { apples : 10, oranges : 12, potatoes : 100000, avocados : 0 }, myArray : [ 0,1,2,2,4,0,1,5,1 ] }"," ","Note how the filter function runs on the struct (","myObj",") and array (","myArray",") in the JSON and then also on each item inside the struct and array. It also runs on the root structure with the key set to an empty string (here, seen on the last line)."],[" ","var json = \"{\\\"prices\\\": [2, 5, 1, 2, 4, 5]}\";"," ","\n    var data = json_parse(json, function (key, value)","\n    {","\n        return is_real(value) ? value * 1000 : value;","\n    });"," ","\n    show_debug_message(data);\n  "," ","The above code takes a JSON string containing an array inside a struct. Then ","json_parse"," is run with a filter function that multiplies each value with 1000, only when it's a ","Real",". Otherwise it simply returns the value itself."," ","The resulting structure looks like this:"," ","{ prices : [ 2000,5000,1000,2000,4000,5000 ] }"," ","Back: ","File Encoding"," ","Next: ","base64_encode"]],"5":[[" ","Syntax:"],[" ","Returns:"],[" ","Example 1:"],[" ","Example 2: Filter Function"],[" ","Example 3: Overriding Values"]],"6":[[" ","© Copyright YoYo Games Ltd. 2024 All Rights Reserved"]],"7":[[" ","Usage Notes"],[" ","Filter Function ","OPTIONAL"]],"id":"2740"})