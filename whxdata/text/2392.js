rh._.exports({"0":[[" ","tilemap_set_global_mask"]],"1":[["tilemap_set_global_mask,tile_rotate,tile_mirror,tile_flip,tile_index_mask"]],"2":[["tilemap_set_global_mask,tile_rotate,tile_mirror,tile_flip,tile_index_mask"]],"3":[[" ","tilemap_set_global_mask"]],"4":[[" ","This function sets the ","Tile Map Bit Mask"," for all tile maps in the game."," ","The idea is that if you have, for example, pretty small tile sets of 16 x 16 tiles then you'll have a total of 256 different tiles in each tile set, which only uses up 8 bits of your index in the "," "," (from an available ","19"," bits of data). These bits can be \"masked\" and then the rest of the tile data can be used to store additional values. See ","Calculating the Mask Bits","."," ","Tile map bit masking is an advanced feature and allows you to use bits of the tile data \"blob\" for your own use. For example, the user could reserve a bit to mean \"solid\" in the tile-data structure and then this can be checked for fast collisions. Basically, the bit mask is \"and\"-ed against the tile data when the tile map is ","drawn"," (so it doesn't affect any of the other functionality), meaning that bits which aren't in the mask are ignored, but can still be read and written to by the user for their own purposes."," ","IMPORTANT"," You should make sure to always have at least the same bits set in the global mask to make the per tile map masks (","tilemap_set_mask",") work the way you'd expect. For example, a global mask of ","0b0000111111111101"," will force bit 1 to 0 in any tile map mask because of the \"and\"-ing of the two masks, no matter if the bit is set there or not."],[" ","tilemap_set_global_mask","(mask);"," ","Argument"," ","Type"," ","Description"," ","mask"," ","Real"," ","The mask value to use"],[" ","N/A"],[" ","var _mask = tile_mirror | tile_flip | tile_rotate | 255;","\n    tilemap_set_global_mask(_mask);"," ","The above code sets the global tile map bit mask to 8bits (binary ","0b11111111",", i.e. the value ","255","), while also preserving the flip, mirror, and rotate values."],[" ","var _transform_bits = tile_mirror | tile_flip | tile_rotate;","\n    var _mask_global = _transform_bits | 0b11111111;","\n    var _mask_small_ts = _transform_bits | 0b1111;","\n    tilemap_set_global_mask(_mask_global);"," ","\n    var _lay_id = layer_get_id(\"Tiles_sky\");","\n    var _map_id = layer_tilemap_get_id(_lay_id);","\n    tilemap_set_mask(_map_id, _mask_small_ts);\n  "," ","The above code sets the global tile map bit mask using ","tilemap_set_global_mask",". 8 bits can be used for the tile index and the mirror, flip and rotate bits are preserved. For the tile map at a layer named \"Tiles_sky\" a custom mask is set that allows only 4 bits for the tile index. The transform bits are, however, also preserved."," ","Back: ","Tile Map Elements"," ","Next: ","tilemap_set_width"]],"5":[[" ","Syntax:"],[" ","Returns:"],[" ","Example 1: Basic Use"],[" ","Example 2: Combining Global and Tile Map Mask"]],"6":[[" ","© Copyright YoYo Games Ltd. 2024 All Rights Reserved"]],"id":"2392"})