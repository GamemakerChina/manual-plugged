<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../assets/import/layer/layer.js"></script><script type="text/javascript" src="../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,o){let r;r=o?e.attr(o):e.html();let i=t[removeHtml(r)];if(null!=i&&i.length){t=retHtml(r);let a=0;t&&t.forEach(function(e,t){var o=i.replace("{"+a+"}",e);i=o===i?i.replace("{}",e):o,a++}),o?e.attr(o,i):e.html(i)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"3D Position":"3D Position 3D位置","An example of a single triangle primitive being built is shown in the following code:":"下面的代码显示了构建单个三角形图元的示例:","And here's a chunk of code which sets up a vertex format compatible with this shader:":"下面是一段代码，它建立了与这个着色器兼容的顶点格式:","And now the associated shader attributes:":"现在是相关的着色器属性:","And the shader code would look something like this:":"着色器代码应该是这样的:",'Any primitives that you build are held in a {}vertex buffer{}. This must be created beforehand and then referenced by the functions that are used to build your primitive. The vertex buffer can be re-used as many times as necessary to create different primitives, or it can be "frozen" to maintain a specific primitive type for the duration of your game or level (which is the fastest approach, so if you know that a primitive you build will not change then you should always use this option).':"你构建的任何图元都保存在{}顶点缓冲区{}中。这必须事先创建，然后由用于构建图元的函数引用。顶点缓冲区可以根据需要多次重用以创建不同的图元，或者它可以“冻结”以在你的游戏或关卡期间保持特定的图元类型(这是最快的方法，所以如果你知道你所构建的图元不会改变，那么你应该总是使用这个选项)。",'Any primitives that you build are held in a {}vertex buffer{}. This must be created beforehand and then referenced by the functions that are used to build your primitive. The vertex buffer can be reused as many times as necessary to create different primitives, or it can be "frozen" to maintain a specific primitive type for the duration of your game or level (which is the fastest approach, so if you know that a primitive you build will not change then you should always use this option).':"您构建的任何基元都保存在{}顶点缓冲区{}中。 必须事先创建它，然后由用于构建原语的函数引用。 顶点缓冲区可以根据需要多次重复使用以创建不同的图元，或者可以“冻结”它以在游戏或关卡持续时间内维护特定的图元类型（这是最快的方法，因此如果您知道 您构建的原语不会改变，那么您应该始终使用此选项）。","As we have already mentioned above, vertex formats are built up by using together the following 5 attribute types (added via the appropriate {}vertex_format_add_*{} function):":"正如我们在上面已经提到的，顶点格式是通过同时使用以下 5 种属性类型构建的（通过适当的 {}vertex_format_add_*{} 函数添加）：","As we have already mentioned above, vertex formats are built up by using together the following 5 attribute types (added via the appropriate {}vertex_format_add_*{}&nbsp;function):":"正如我们上面已经提到的，顶点格式是通过一起使用以下5种属性类型(通过适当的{}vertex_format_add_*{}函数添加)构建的：",Colour:"Colour 颜色","Guide To Primitives And Vertex Building":"图元和顶点构建指南",'Here we have first create&nbsp;our&nbsp;vertex buffer in the Create Event of the instance, then we begin the definition of the different vertices that make up our triangle primitive, giving the position, the colour, and the texture UV coordinate for each of the three points that we want to use. We then end the vertex definition, and we know that the vertex buffer with this vertex data is stored in the variable "v_buff".&nbsp;&nbsp;':'在这里，我们首先在实例的创建事件中创建了我们的顶点缓冲区，然后我们开始定义组成我们的三角形图元的不同顶点，为我们想要使用的三个点中的每个点提供位置、颜色和纹理UV坐标。然后结束顶点定义，我们知道包含这个顶点数据的顶点缓冲区存储在变量"v_buff"中。','Here we have first created our&nbsp;vertex buffer in the Create Event of the instance, then we begin the definition of the different vertices that make up our triangle primitive, giving the position, the colour, and the texture UV coordinate for each of the three points that we want to use. We then end the vertex definition, and we know that the vertex buffer with this vertex data is stored in the variable "v_buff".&nbsp;&nbsp;':'在这里，我们首先在实例的创建事件中创建了顶点缓冲区，然后开始定义组成三角形图元的不同顶点，为要使用的三个点中的每一个点提供位置、颜色和纹理UV坐标。然后结束顶点定义，并且我们知道具有该顶点数据的顶点缓冲存储在变量"v_buff"中。',"However, if you are only using (for example) a shader to manipulate the position of the vertex, then there would be no need to pass through colour or texture data. In this case you would create your own format as follows:&nbsp;":"然而，如果你只是使用(例如)着色器来操纵顶点的位置，那么就不需要传递颜色或纹理数据。在这种情况下，你可以创建自己的格式，如下所示：","However, if you are only using (for example) a shader to manipulate the position of the vertex, then there would be no need to pass through colour or texture data. In this case you would create your own format as so:":"然而，如果你只是使用(例如)着色器来操作顶点的位置，那么就不需要传递颜色或纹理数据了。在这种情况下，你将创建自己的格式如下:","In general when you start working with 3D, special effects, complex drawing processes or shaders you don't need not worry too much about the vertex format being used, since {}GameMaker{} will automatically set up and pass through the {}vertex{} data for you. However, sometimes it is necessary to create your own vertex data and format it to suit, especially when you need to boost speed, or wish to pass in extra information. For example the standard vertex format includes an x, y, z 3D position, colour (with alpha), and UV texture coordinates, which, if you were creating it yourself, would look something like:":"一般来说，当您开始使用 3D、特效、复杂的绘制过程或着色器时，您不必太担心所使用的顶点格式，因为 {}GameMaker{} 会自动设置并通过{}顶点 {} 数据。 然而，有时需要创建您自己的顶点数据并对其进行格式化以适应，尤其是当您需要提高速度或希望传递额外信息时。 例如，标准顶点格式包括 x、y、z 3D 位置、颜色（带 alpha）和 UV 纹理坐标，如果您自己创建它，将类似于：","In general when you start working with 3D, special effects, complex drawing processes or shaders you don't need to worry too much about the vertex format being used, since {}GameMaker{} will automatically set up and pass through the {}vertex{} data for you. However, sometimes it is necessary to create your own vertex data and format it to suit, especially when you need to boost speed, or wish to pass in extra information. For example the standard vertex format includes an x, y, z 3D position, colour (with alpha), and UV texture coordinates, which, if you were creating it yourself, would look something like this:&nbsp;":"一般来说，当你开始使用3D，特效，复杂的绘图过程或着色器时，你不需要太担心使用的顶点格式，因为{}GameMaker{}会自动设置并传递{}顶点{}数据。但是，有时需要创建自己的顶点数据并将其格式化，特别是当你需要提高速度时，或者希望传递额外的信息。例如，标准顶点格式包括x，y，z 3D位置，颜色(带alpha)和UV纹理坐标，如果您自己创建它，看起来像这样：","In general you must&nbsp;{}always{}&nbsp;provide position or 3D position as part of the format, but all the others are optional.":"通常情况下，您必须{} 始终 {}提供位置或3D位置作为格式的一部分，但其他所有都是可选的。","In this case {}in_Colour0{} maps to the first {}vertex_format_add_colour(){} and {}in_Colour1{} maps to the second.":"在这种情况下，{}in_Colour0{} 映射到第一个 {}vertex_format_add_colour(){}，{}in_Colour1{} 映射到第二个。","In this example, {}in_myTexcoord{}, {}in_TextureCoord{} and {}in_Something{} map to the three successive texture coordinate attributes defined in the vertex format.":"在此示例中，{}in_myTexcoord{}、{}in_TextureCoord{} 和 {}in_Something{} 映射到顶点格式中定义的三个连续纹理坐标属性。","In total there are five different vertex attributes that you can use when defining a vertex format:":"在定义顶点格式时，总共可以使用五种不同的顶点属性:",Normal:"Normal 法线","Now, how does the shader attribute get matched to the vertex format type? It's just based on the naming convention:":"现在，shader 属性是如何与顶点格式类型匹配的? 它只是基于变数命名原则:",'Now, this might look odd as it seems that we can specify more attribute kinds in our vertex format than we can in the vertex shader. However, in the shader {}Position{} and {}3D Position{} are treated as the {}same {}attribute, except that {}Position{} is expected to have only "x" and "y" coordinates whereas {}3D Position{} has “x”, “y” and “z” coordinates. So how do you map what\'s in your vertex format to how you define attributes in your shader? Let\'s start by looking at a typical set of attributes from the default shader:':"现在，这可能看起来很奇怪，因为我们似乎可以在顶点格式中指定比在顶点着色器中更多的属性种类。 但是，在着色器中，{}Position{} 和 {}3D Position{} 被视为{}相同的{}属性，除了 {}Position{} 预计只有“x”和“y”坐标，而 {}3D 位置{}具有“x”、“y”和“z”坐标。 那么如何将顶点格式中的内容映射到着色器中定义属性的方式呢？ 让我们从默认着色器的一组典型属性开始：","One final important point to note when using your own vertex buffers in this way is how it affects the vertex batches that are sent to the GPU. When you create a vertex buffer you are creating the lowest level of graphics data, so when you draw all that happens is that {}GameMaker{} sends your buffer directly to the graphics card. Because of this, if you want better batching, you must work it out yourself and store the things you want to batch inside the same buffer.":"以这种方式使用您自己的顶点缓冲区时要注意的最后一点是它如何影响发送到 GPU 的顶点批次。 创建顶点缓冲区时，您创建的是最低级别的图形数据，因此当您绘制时，{}GameMaker{} 会将您的缓冲区直接发送到显卡。 因此，如果你想要更好的批处理，你必须自己解决并将你想要批处理的东西存储在同一个缓冲区中。",Position:"Position 位置","Primitives&nbsp;And Vertex Formats":"图元和顶点格式","Texture coordinate":"Texture coordinate 纹理坐标","Texture coordinates are handled slightly differently to colour. Basically, anything which isn't called {}in_Position{}, {}in_Normal{} or one of the {}in_Colour[0 ... ]{} attributes is treated as a texture coordinate. The order they are defined in, in the list of attributes in the shader, is what denotes which attribute in the vertex format they map to. See the following GML example:":"纹理坐标的处理方式与颜色略有不同。 基本上，任何未称为 {}in_Position{}、{}in_Normal{} 或 {}in_Colour[0 ... ]{} 属性之一的都被视为纹理坐标。 它们在着色器的属性列表中定义的顺序表示它们映射到顶点格式中的哪个属性。 请参阅以下 GML 示例：","Texture coordinates are handled slightly differently to colour. Basically, anything which isn't called {}in_Position{}, {}in_Normal{} or one of the {}in_Colour[0 ... ]{} attributes is treated as a texture coordinate. The order they are defined in, in the list of attributes in the shader, is what denotes which attribute in the vertex format they map to. See the following&nbsp;{}GML Code{} example:":"纹理坐标的处理与颜色略有不同。基本上，任何不被称为{}in_Position{}，{}in_Normal{}或{}in_Colour[0...]{}属性之一的东西都被视为纹理坐标。它们在着色器中的属性列表中定义的顺序，表示它们映射到顶点格式中的哪个属性。请参见以下{}GML代码{}示例：","This guide briefly covers how to build and use {}primitives{} using custom {}vertex formats{} and {}vertex buffers{}.":"本指南简要介绍如何使用自定义{}顶点格式{}和{}顶点缓冲区{}构建和使用{0}图元{1}(primitives,原语,基元)。","This guide briefly covers how to build and use {}primitives{} using custom {}vertex formats{} and {}vertex buffers{}.&nbsp;":"本指南简要介绍了如何使用自定义{}顶点格式{}和{}顶点缓冲区{}构建和使用{}图元{}。",'We then draw the contents of the vertex buffer in the Draw Event using a shader. This is a very simple example, and is basically how {}GameMaker{} works internally, i.e.: When you draw a sprite, {}GameMaker{}&nbsp;creates a vertex buffer with four vertices creating two triangles (which make a square, also called a "quad"), and textures these two triangles with the sprite image. When we draw this sprite, we are submitting the vertex buffer which draws its contents to the screen.':'然后我们使用着色器在绘制事件中绘制顶点缓冲区的内容。这是一个非常简单的示例，基本上是{}GameMaker{}内部的工作方式，即：绘制精灵时，{}GameMaker{}会创建一个顶点缓冲区，其中四个顶点可创建两个三角形(这使得一个正方形，也被称为"四边形")，并纹理这两个三角形与精灵图像。当我们绘制这个精灵，我们提交的顶点缓冲区，其中绘制其内容到屏幕上。','We then draw the contents of the vertex buffer in the Draw Event using a shader. This is a very simple example, and is basically how {}GameMaker{} works internally, ie: When you draw a sprite, GameMaker creates a vertex buffer with four vertices creating two triangles (which make a square, also called a "quad"), and textures these two triangles with the sprite image. When we draw this sprite, we are submitting the vertex buffer and its contents are drawn to the screen.':"然后我们使用着色器在绘制事件中绘制顶点缓冲区的内容。这是一个非常简单的例子，基本上就是{}GameMaker{}内部工作的方式，例如:当你绘制一个精灵时，GameMaker创建一个顶点缓冲区，四个顶点创建两个三角形(构成一个正方形，也称为“quad”)，并将这两个三角形与精灵图像纹理化。当我们绘制这个精灵时，我们提交了顶点缓冲区，它的内容被绘制到屏幕上。","When adding additional colour attributes to your shader, a number needs to be added to the end of the shader attribute to indicate which particular entry in the vertex format the attribute maps to. Here's an example - first the vertex format:":"向着色器添加其他颜色属性时，需要在着色器属性的末尾添加一个数字，以指示该属性映射到顶点格式中的哪个特定条目。 这是一个示例 - 首先是顶点格式：","Within the GLSL ES shader, these kinds are recognised using the following 4 attributes:":"在 GLSL ES 着色器中，使用以下4个属性可以识别这些类型:","You can find a full list of all the functions required to create vertex formats, vertex buffers and primitives from the following page:":"您可以从以下页面找到创建顶点格式、顶点缓冲区和图元所需的所有函数的完整列表：","You should note that once you have created your vertex format, the order in which you have defined the vertex attributes&nbsp;{}must be honoured{} when building your {}primitives{}. So, if you have defined a vertex format as position, colour, and texture coordinate, then {}you {}must{} add these attributes to the primitive in the same order otherwise you will get an error{}. Also note that like any other dynamic resource, a vertex format requires memory and therefore should be removed when not needed using the function {}{}vertex_format_delete(){}{}.":"您应该注意，一旦创建了顶点格式，在构建{2}图元{3}时，{}必须遵守{}定义顶点属性的顺序。所以，如果你已经定义了一个顶点格式作为位置，颜色和纹理坐标，那么{}你{}必须{}以相同的顺序将这些属性添加到原语中，否则你将得到一个错误{}。还要注意，像任何其他动态资源一样，顶点格式需要内存，因此在不需要时应该使用函数{}{}vertex_format_delete(){}{}删除顶点格式。","You should note that once you have created your vertex format, the order in which you have defined the vertex attributes&nbsp;{}must be honoured{} when building your {}primitives{}. So, if you have defined a vertex format as position, colour, and texture coordinate, then {}you {}must{} add these attributes to the primitive in the same order otherwise you will get an error{}. Also note that like any other dynamic resource, a vertex format requires memory and therefore should be removed when not needed using the function {}{}vertex_format_delete{}{}.":"您应该注意，创建顶点格式后，在构建{}图元{}时{}必须遵守{}定义顶点属性的顺序。 因此，如果您已将顶点格式定义为位置、颜色和纹理坐标，则{}您{}必须{}以相同的顺序将这些属性添加到图元，否则您将收到错误{}。 另请注意，与任何其他动态资源一样，顶点格式需要内存，因此在不需要时应使用函数 {}{}vertex_format_delete{}{} 删除。","You'll notice when we submit the vertex buffer for drawing, we supply a primitive type. The type of primitive you use can be a point, a line list&nbsp;or strip, or a triangle list&nbsp;or strip, but you are {}not{} permitted triangle fans since most mobile hardware will not accept that primitive type. Don't forget to format your vertex buffer correctly for the type of primitive that is going to be used to draw it. For example, drawing a two triangle primitive as a triangle list requires 6 points, but as a triangle strip it only requires 4 points. Which type you use is up to you and will depend on what you are wanting to draw and the effect that you want to achieve.":"你会注意到，当我们提交绘制的顶点缓冲区时，我们提供了一个图元类型。你使用的图元类型可以是一个点，一个行列表或条，或一个三角形列表或条(point,line list or strip,triangle list or strip)，但是{} 不 {}允许使用三角扇形(triangle fans)，因为大量移动硬件不接受这种图元类型。不要忘记为将要用来绘制它的图元类型正确地格式化你的顶点缓冲区。例如，将两个三角形图元绘制为一个三角形列表需要6个点，但作为一个三角扇(triangle strip)只需要4个点。你使用哪种类型是由你自己决定的，这取决于你想要画什么和你想要达到的效果。","You'll notice when we submit the vertex buffer for drawing, we supply a primitive type. The type of primitive you use can be a point, a line list&nbsp;or strip, or a triangle list&nbsp;or strip, but you are {}not{} permitted triangle fans since most mobile hardware will not accept that primitive type. Don't forget to format your vertex buffer correctly for the type of primitive that is going to be used to draw it. For example, drawing a two triangle primitive as a triangle list requires 6 points, but as a triangle strip it only requires 4 points. Which type you use is up to you and will depend on what you want to draw and the effect that you want to achieve.":"你会注意到，当我们提交顶点缓冲区进行绘图时，我们提供了一个图元类型。你使用的图元类型可以是点、线条列表或条带，或者三角形列表或条带，但你不是因为大多数移动的硬件不接受这种基本类型，所以允许三角形风扇。不要忘记为将要用于绘制它的基本类型正确格式化顶点缓冲区。例如，将两个三角形的图元绘制为三角形列表需要6个点，而将其绘制为三角形条带只需要4个点。使用哪种类型取决于您，取决于您想要绘制的内容和想要达到的效果。",'{}"in_Colour"{} maps to {}{}vertex_format_add_colour(){}{}':'{}"in_Colour"{} 映射到 {}{}vertex_format_add_colour(){}{}','{}"in_Position"{} maps to {}{}vertex_format_add_position{}/{}_3d(){}{}':'{}"in_Position"{} 映射到 {}{}vertex_format_add_position{}/{}_3d(){}{}','{}"in_TextureCoord"{} maps to {}{}vertex_format_add_texcoord(){}{}':'{}"in_TextureCoord"{} 映射到 {}{}vertex_format_add_texcoord(){}{}',"{}Guide To Primitives And Vertex Building{}":"{}图元和顶点构建指南{}","{}NOTE{}: If the contents of the buffer are going to be updated constantly, the buffer would be created, given the vertex data, and then be destroyed again - after it's been drawn -&nbsp;all in the same step.":"{}注意{}：如果要不断更新缓冲区的内容，则会在给定顶点数据的情况下创建缓冲区，然后再次销毁 - 在绘制之后 - 所有这些都在同一步骤中进行。","{}{}NOTE{}{}&nbsp;If the contents of the vertex buffer are going to be updated constantly, it would be created, given the vertex data, and then be destroyed again - after it's been drawn -&nbsp;all in the same step.":"{}{}注意{}{}如果顶点缓冲区的内容将不断更新，它将被创建，给定顶点数据，然后再次被销毁-在它被绘制之后-所有这些都在同一步骤中。","{}{}{}{}{} {}Now, things get trickier when you have multiple attributes of the same kind, but things are still based on the same naming convention. We'll look at supplying additional {}colour{} and {}texture coordinates{} now, as there can only be {}one{} Position and {}one{} Normal attribute in the shader or vertex format, but there&nbsp;{}can{}&nbsp;be multiple colour or texture attributes.":"{}{}{}{}{} {}现在，当您拥有多个同类属性时，事情会变得更加棘手，但事情仍然基于相同的命名约定。 我们现在将考虑提供额外的{}颜色{}和{}纹理坐标{}，因为在着色器或顶点格式中只能有{}一个{}位置和{}一个{}法线属性，但有&nbsp; {}可以{}&nbsp;是多个颜色或纹理属性。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="..",gTopicId="7.0_9"</script><script type="text/javascript" src="../template/scripts/rh.min.js"></script><script type="text/javascript" src="../template/scripts/common.min.js"></script><script type="text/javascript" src="../template/scripts/topic.min.js"></script><script type="text/javascript" src="../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Guide To Primitives And Vertex Building</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../assets/css/default.css" type="text/css"><script src="../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page that explains how to set up and use primitives and vertex buffers"><meta name="rh-index-keywords" content="Guide To Primitives And Vertex Building"><meta name="search-keywords" content="primitive building,primitives,vertex,vertex buffers,vertex formats"><meta name="brsnext" value="Additional_Information/Guide_To_Using_Blendmodes.htm"><meta name="brsprev" value="Additional_Information/Guide_To_Using_Shaders.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Guide To Primitives And Vertex Building"><span>Guide To Primitives And Vertex Building</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Guide To Primitives And Vertex Building</span></h1><p>This guide briefly covers how to build and use <a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/Primitives_And_Vertex_Formats.htm">primitives</a> using custom <strong>vertex formats</strong> and <strong>vertex buffers</strong>.</p><p>In general when you start working with 3D, special effects, complex drawing processes or shaders you don't need to worry too much about the vertex format being used, since <span data-keyref="GameMaker Name">GameMaker</span> will automatically set up and pass through the <a class="tooltip" title="A vertex is the name given to a single point of a polygon that contains various characteristics that define it's position, its colour and its texture. In computer graphics, this usually means a corner of a triangle that is used to create a primitive, and a combination of such primitives is what makes the graphics on the screen.">vertex</a> data for you. However, sometimes it is necessary to create your own vertex data and format it to suit, especially when you need to boost speed, or wish to pass in extra information. For example the standard vertex format includes an x, y, z 3D position, colour (with alpha), and UV texture coordinates, which, if you were creating it yourself, would look something like this:&nbsp;</p><h4 id="passthrough_vertex_format">Passthrough Vertex Format:</h4><p class="code">vertex_format_begin();<br>vertex_format_add_position_3d();<br>vertex_format_add_colour();<br>vertex_format_add_texcoord();<br>my_format = vertex_format_end();</p><p>However, if you are only using (for example) a shader to manipulate the position of the vertex, then there would be no need to pass through colour or texture data. In this case you would create your own format as follows:&nbsp;</p><h4>Custom Vertex Format:</h4><p class="code">vertex_format_begin();<br>vertex_format_add_position_3d();<br>my_format = vertex_format_end();</p><p>In total there are five different vertex attributes that you can use when defining a vertex format:</p><ul class="colour"><li>Colour</li><li>Normal</li><li>Position</li><li>3D Position</li><li>Texture coordinate</li></ul><p>In general you must&nbsp;<em>always</em>&nbsp;provide position or 3D position as part of the format, but all the others are optional.</p><p>You should note that once you have created your vertex format, the order in which you have defined the vertex attributes&nbsp;<i>must be honoured</i> when building your <strong>primitives</strong>. So, if you have defined a vertex format as position, colour, and texture coordinate, then <b>you <i>must</i> add these attributes to the primitive in the same order otherwise you will get an error</b>. Also note that like any other dynamic resource, a vertex format requires memory and therefore should be removed when not needed using the function <span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_format_delete.htm">vertex_format_delete</a></span>.</p><p>Any primitives that you build are held in a <b>vertex buffer</b>. This must be created beforehand and then referenced by the functions that are used to build your primitive. The vertex buffer can be reused as many times as necessary to create different primitives, or it can be "frozen" to maintain a specific primitive type for the duration of your game or level (which is the fastest approach, so if you know that a primitive you build will not change then you should always use this option).</p><p>An example of a single triangle primitive being built is shown in the following code:</p><p class="code_heading">Create Event</p><p class="code">v_buff = vertex_create_buffer();<br>vertex_begin(v_buff, global.my_format);<br>vertex_position(v_buff, 10, 10);<br>vertex_colour(v_buff, c_white, 1);<br>vertex_texcoord(v_buff, 0, 0);<br>vertex_position(v_buff, 110, 10);<br>vertex_colour(v_buff, c_white, 1);<br>vertex_texcoord(v_buff, 1, 0);<br>vertex_position(v_buff, 110, 110);<br>vertex_colour(v_buff, c_white, 1);<br>vertex_texcoord(v_buff, 1, 1);<br>vertex_end(v_buff);</p><p class="code_heading">Draw Event</p><p class="code"><br>var tex = sprite_get_texture(spr_Background, 0);<br>shader_set(shd_shimmer);<br>vertex_submit(v_buff, pr_trianglelist, tex);<br>shader_reset();</p><p>Here we have first created our&nbsp;vertex buffer in the Create Event of the instance, then we begin the definition of the different vertices that make up our triangle primitive, giving the position, the colour, and the texture UV coordinate for each of the three points that we want to use. We then end the vertex definition, and we know that the vertex buffer with this vertex data is stored in the variable "v_buff".&nbsp;&nbsp;</p><p class="note"><span data-conref="../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;If the contents of the vertex buffer are going to be updated constantly, it would be created, given the vertex data, and then be destroyed again - after it's been drawn -&nbsp;all in the same step.</p><p>We then draw the contents of the vertex buffer in the Draw Event using a shader. This is a very simple example, and is basically how <span data-keyref="GameMaker Name">GameMaker</span> works internally, i.e.: When you draw a sprite, <span data-keyref="GameMaker Name">GameMaker</span>&nbsp;creates a vertex buffer with four vertices creating two triangles (which make a square, also called a "quad"), and textures these two triangles with the sprite image. When we draw this sprite, we are submitting the vertex buffer which draws its contents to the screen.</p><p>You'll notice when we submit the vertex buffer for drawing, we supply a primitive type. The type of primitive you use can be a point, a line list&nbsp;or strip, or a triangle list&nbsp;or strip, but you are <i>not</i> permitted triangle fans since most mobile hardware will not accept that primitive type. Don't forget to format your vertex buffer correctly for the type of primitive that is going to be used to draw it. For example, drawing a two triangle primitive as a triangle list requires 6 points, but as a triangle strip it only requires 4 points. Which type you use is up to you and will depend on what you want to draw and the effect that you want to achieve.</p><p>One final important point to note when using your own vertex buffers in this way is how it affects the vertex batches that are sent to the GPU. When you create a vertex buffer you are creating the lowest level of graphics data, so when you draw all that happens is that <span data-keyref="GameMaker Name">GameMaker</span> sends your buffer directly to the graphics card. Because of this, if you want better batching, you must work it out yourself and store the things you want to batch inside the same buffer.</p><p>As we have already mentioned above, vertex formats are built up by using together the following 5 attribute types (added via the appropriate <span class="inline3_func">vertex_format_add_*</span>&nbsp;function):</p><ul class="colour"><li>Colour</li><li>Normal</li><li>Position</li><li>3D Position</li><li>Texture coordinate</li></ul><p>Within the GLSL ES shader, these kinds are recognised using the following 4 attributes:</p><ul class="colour"><li>Colour</li><li>Normal</li><li>Position</li><li>Texture coordinate</li></ul><p>Now, this might look odd as it seems that we can specify more attribute kinds in our vertex format than we can in the vertex shader. However, in the shader <i>Position</i> and <i>3D Position</i> are treated as the <em>same</em> attribute, except that <i>Position</i> is expected to have only "x" and "y" coordinates whereas <i>3D Position</i> has “x”, “y” and “z” coordinates. So how do you map what's in your vertex format to how you define attributes in your shader? Let's start by looking at a typical set of attributes from the default shader:</p><p>&nbsp;</p><p class="code">attribute vec3 in_Position;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (x,y,z)<br>//attribute vec3 in_Normal;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (x,y,z) unused in this shader.<br>attribute vec4 in_Colour;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (r,g,b,a)<br>attribute vec2 in_TextureCoord;&nbsp;&nbsp;&nbsp;&nbsp;// (u,v)</p><p>And here's a chunk of code which sets up a vertex format compatible with this shader:</p><p class="code">vertex_format_begin();<br>vertex_format_add_position_3d();<br>vertex_format_add_colour();<br>vertex_format_add_texcoord();<br>my_format = vertex_format_end();</p><p>Now, how does the shader attribute get matched to the vertex format type? It's just based on the naming convention:</p><ul class="colour"><li><span class="inline">"in_Position"</span> maps to <span class="inline"><a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_format_add_position.htm">vertex_format_add_position</a>/<a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_format_add_position_3d.htm">_3d()</a></span></li><li><span class="inline">"in_Colour"</span> maps to <a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_format_add_colour.htm"><span class="inline">vertex_format_add_colour()</span></a></li><li><span class="inline">"in_TextureCoord"</span> maps to <a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_format_add_texcoord.htm"><span class="inline">vertex_format_add_texcoord()</span></a></li></ul><p><span class="inline"><span class="inline"><span class="inline"></span></span></span> Now, things get trickier when you have multiple attributes of the same kind, but things are still based on the same naming convention. We'll look at supplying additional <b>colour</b> and <b>texture coordinates</b> now, as there can only be <b>one</b> Position and <b>one</b> Normal attribute in the shader or vertex format, but there&nbsp;<em>can</em>&nbsp;be multiple colour or texture attributes.</p><p>When adding additional colour attributes to your shader, a number needs to be added to the end of the shader attribute to indicate which particular entry in the vertex format the attribute maps to. Here's an example - first the vertex format:</p><p class="code">vertex_format_begin();<br>vertex_format_add_position_3d();<br>vertex_format_add_colour();<br>vertex_format_add_colour();<br>vertex_format_add_texcoord();<br>my_format = vertex_format_end();</p><p>And now the associated shader attributes:</p><p class="code">attribute vec3 in_Position;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (x,y,z)<br>attribute vec4 in_Colour0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (r,g,b,a)<br>attribute vec4 in_Colour1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (r,g,b,a)<br>attribute vec2 in_TextureCoord;&nbsp;&nbsp;// (u,v)</p><p>In this case <span class="inline">in_Colour0</span> maps to the first <span class="inline">vertex_format_add_colour()</span> and <span class="inline">in_Colour1</span> maps to the second.</p><p>Texture coordinates are handled slightly differently to colour. Basically, anything which isn't called <span class="inline">in_Position</span>, <span class="inline">in_Normal</span> or one of the <span class="inline">in_Colour[0 ... ]</span> attributes is treated as a texture coordinate. The order they are defined in, in the list of attributes in the shader, is what denotes which attribute in the vertex format they map to. See the following&nbsp;<span data-keyref="GML_Code">GML Code</span> example:</p><p class="code">vertex_format_begin();<br>vertex_format_add_position_3d();<br>vertex_format_add_colour();<br>vertex_format_add_texcoord();<br>vertex_format_add_texcoord();<br>vertex_format_add_texcoord();<br>my_format = vertex_format_end();</p><p>And the shader code would look something like this:</p><p class="code">attribute vec3 in_Position;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (x,y,z)<br>attribute vec4 in_Colour;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (r,g,b,a)<br>attribute vec2 in_myTexcoord;&nbsp;&nbsp;&nbsp;&nbsp;// (u,v)<br>attribute vec2 in_TextureCoord;&nbsp;&nbsp;// (u,v)<br>attribute vec2 in_Something;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// (u,v)</p><p>In this example, <span class="inline">in_myTexcoord</span>, <span class="inline">in_TextureCoord</span> and <span class="inline">in_Something</span> map to the three successive texture coordinate attributes defined in the vertex format.</p><p>You can find a full list of all the functions required to create vertex formats, vertex buffers and primitives from the following page:</p><ul class="colour"><li><a href="../GameMaker_Language/GML_Reference/Drawing/Primitives/Primitives_And_Vertex_Formats.htm">Primitives&nbsp;And Vertex Formats</a></li></ul><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Additional_Information.htm">Additional Information</a></div><div style="float:right">Next: <a href="Guide_To_Using_Blendmodes.htm">Guide To Using Blendmodes</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>