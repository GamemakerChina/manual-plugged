<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../assets/import/layer/layer.js"></script><script type="text/javascript" src="../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let n;n=a?e.attr(a):e.html();let i=t[removeHtml(n)];if(null!=i&&i.length){t=retHtml(n);let o=0;t&&t.forEach(function(e,t){var a=i.replace("{"+o+"}",e);i=a===i?i.replace("{}",e):a,o++}),a?e.attr(a,i):e.html(i)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Also note that while the script editor permits you to fold code at each of the open/close brackets, you can use {}#region{} and {}#endregion{}&nbsp;tags to section off parts of your code and greatly enhance readability, especially when dealing with larger scripts which contain multiple functions. Regions can be commented, too - see the Editing section of this page in the manual):":"还要注意的是，虽然脚本编辑器允许你在每个开/闭括号处折叠代码，但你可以使用{}#region{}和{}#endregion{}标记来分割代码的一部分，并大大增强可读性，特别是在处理包含多个函数的大型脚本时。区域也可以注释-请参阅手册中本页的编辑部分)：","Alternatively, look into creating a{} tile-based collision system{}, which can be created using the {}tilemap functions{}&nbsp;or even a custom 2D array or DS grid. These will be very fast and will help boost your game's speed. However, if you are using irregular terrain or walls and objects that don't align to a grid they may not be appropriate. You can find a very simple tutorial on tilemap collisions from the following video link":"或者，考虑创建一个基于{}瓷砖的碰撞系统{}，可以使用{}瓷砖贴图函数{}甚至是自定义2D数组或DS网格来创建。这些都将非常快，并有助于提高游戏的速度。但是，如果你使用的是不规则的地形或墙，以及不与网格对齐的对象，它们可能不合适。你可以找到一个关于平铺地图冲突的非常简单的教程从以下视频链接","Another way to reduce these numbers is to disable the {}Separate Texture Page{} option for sprites unless absolutely necessary. Each image stored in this way is sent to its own texture page and batched differently, so having these images on a regular texture page is better. You can then get the UVS coordinates using the {}{}sprite_get_uvs(){}{}&nbsp;function and store them in variables for use later. It may be a small amount of extra code, but the boost you will get is worth it. Note that this method will not permit texture repeats!":"另一种减少这些数量的方法是禁用子画面的{}分离纹理页面{}选项，除非绝对必要。以这种方式存储的每个图像都被发送到自己的纹理页面，并以不同的方式进行批量处理，因此，将这些图像放在常规纹理页面上会更好。然后，您可以使用{}{}sprite_get_uvs(){}{}函数并将它们存储在变量中以备后用。这可能是一小部分额外的代码，但你将得到的提升是值得的。注意，这个方法不允许纹理重复！",'Apart from the main things mentioned above, there are other more general things that can help with performance and that are considered "good practices" too:':'除了上面提到的主要内容，还有其他更一般的内容可以帮助提高性能，也被认为是"良好实践"：',"As with all these tips, if it makes your life more difficult to change it and your game runs fine, don't worry about it too much...":"正如所有这些提示，如果它使你的生活更难改变它，你的游戏运行良好，不要太担心它。","Best Practices When Programming":"编程时的最佳实践","But, as we mentioned at the start of the page, all these optimisations are optional and if your game runs fine with 60 vertex batches, 80 texture swaps, additive blending, etc., then don't worry about it too much! Just keep these things in mind when programming your next game...":"但是，正如我们在页面开始时提到的，所有这些优化都是可选的，如果你的游戏在60个顶点批次，80个纹理交换，添加剂混合等情况下运行良好，那么不要太担心！在编写下一个游戏时记住这些事情。","Continuing on from the above point about programming style, one thing that a lot of beginners do is to cram as much into one line of code as possible. For example:":"从上面关于编程风格的观点继续，很多初学者做的一件事就是尽可能多地塞进一行代码中。例如：","Finally, we're going to touch briefly on using {}surfaces{}, as {}GameMaker{} has a fairly significant optimisation when using them in your games: the ability to switch on and off the {}depth buffer{}.":"最后，我们将简要介绍如何使用{}表面{}，因为{}GameMaker{}在您的游戏中使用表面时有相当重要的优化功能：能够打开和关闭{}深度缓冲区{}。","If you switch on the {}{}debug overlay{}{},&nbsp;you will see that there are two figures in brackets at the top of your screen when testing. The first is the number of {}texture swaps {}being done and the second is the number of {}vertex batches{}. A number of factors will influence these figures and you will never get them down to (0) (0) as the engine requires one or two of each every step, but you should aim to get these values down as low as possible.":"如果打开{}{}调试覆盖{}{}，在测试时，你会看到在屏幕顶部的括号中有两个数字。第一个是正在执行的{}纹理交换{}的数量，第二个是{}顶点批处理{}的数量。许多因素会影响这些数字，你永远不会让它们下降到(0)(0)因为发动机需要一个或两个每一步，但你的目标应该是让这些值尽可能低。","If your game runs fine and you are happy with things as they are, then {}don't rush to change everything just to squeeze a few extra FPS out{}. You have to strike a balance between readable, flexible and modular code with the time and energy required to change things, as well as the overall gain at the end. Basically, if it isn't broken, don't fix it and keep what you learn here for your next project.":"如果你的游戏运行得很好，你对它的现状很满意，那么{}不要急于改变一切，只是为了挤出一些额外的FPS{}。你必须在可读性、灵活性和模块化代码与改变东西所需的时间和精力以及最终的整体收益之间取得平衡。基本上，如果它没有被打破，别修改它把你在这里学到的东西留到下一个项目。","In this way, all the bullets will be drawn in the same batch. Judicious use of the functions {}{}gpu_set_blendenable(){}{}, {}{}gpu_set_alphatestref(){}{}, and {}{}gpu_set_alphatestenable(){}{}&nbsp;can greatly improve performance and can be enabled/disabled as required throughout your project code, although they may not be appropriate for all types of graphics or projects.":"这样，所有的子弹都会在同一批次中被抽取。 明智地使用函数 {}{}gpu_set_blendenable(){}{}、{}{}gpu_set_alphatestref(){}{} 和 {}{}gpu_set_alphatestenable(){}{} 可以极大地提高性能，并且可以启用/ 尽管它们可能并不适合所有类型的图形或项目，但可以根据需要在整个项目代码中禁用。","In {}GameMaker{} {}data structures{} have been optimised to be a lot faster than previous GameMaker versions. They still need to be cleaned up (destroyed) when not used to free memory, and they can still be slower than, say, arrays, but the ease of use and the extra functions for dealing with the data they contain can often out-weigh the minimal speed difference, so don't be afraid to use them in your games.":"在{}GameMaker{}中，{}数据结构{}已经优化，比以前的GameMaker版本快得多。它们仍然需要清理当不用于释放内存时，它们仍然可能比数组慢，但易用性和处理它们包含的数据的额外功能通常会超过最小的速度差异，所以不要害怕在游戏中使用它们。","It should be noted that of all the data structures, DS Maps in particular are lighting fast, both to read from and write to, making them an excellent option for all types of tasks.":"应该注意的是，在所有数据结构中，DS Maps特别快，无论是读取还是写入，都使其成为所有类型任务的绝佳选择。","Local variables are fast to process in-game, so make the most of them, and if an expression appears in a code block or script two or more times, think about creating a local variable for it. When using the {}YoYo Compiler (YYC){} targets, if you reference {}global{} or instance variables various times in a function or code block it is particularly beneficial to assign them to a local variable at the start of your code and then reference that local variable, as this will give much better performance.":"局部变量在游戏中处理速度很快，所以要充分利用它们，如果一个表达式在代码块或脚本中出现两次或更多次，考虑为它创建一个局部变量。当使用{}YoYo编译器(YYC){}目标时，如果引用{}global{}如果函数或代码块中多次出现局部变量或实例变量，则在代码开始时将它们赋给局部变量，然后引用该局部变量，因为这将提供给予更好的性能。","Note that on the non-WebGL HTML5 target, having multi-coloured, fading particles will require a lot of image caching and will be very slow. However, since particle sprites can be animated, you can create an animated sprite that has sub-images which change colour and then use that for the particle instead. It will still look like a gradual colour change, but not require the constant creation of cache images.":"请注意，在非WebGL HTML5目标上，具有多色，褪色的粒子将需要大量的图像缓存，并且将非常缓慢。然而，由于粒子精灵可以被动画化，因此您可以创建一个具有改变颜色的子图像的动画精灵，然后将其用于粒子。它仍然看起来像是逐渐的颜色变化，但不需要不断创建缓存图像。",'On this page we are going to cover some "best practices" when programming your game, and at the same time explain a little bit about the inner workings of {}GameMaker{}. Before continuing, however, it is worth noting two very important points:':'在本页中，我们将介绍游戏编程时的一些"最佳实践"，同时解释一下{}GameMaker{}的内部工作原理。然而，在继续之前，值得注意的是两个非常重要的要点：',"Previously we mentioned {}accessors{}&nbsp;for arrays, but they are also available for data structures, which can help clean up your code and make it much easier to read.":"前面我们提到了数组的{}访问器{}，但它们也可用于数据结构，这可以帮助清理代码并使其更容易阅读。","So, if you have a number of bullet instances that draw using the {}bm_add{} blend mode - for example - you will be creating a new vertex batch for each one, which is definitely a bad thing! Instead, have a controller object in your game that draws all the bullets instead, like this:":"因此，如果你有许多使用{}bm_add{}混合模式绘制的子弹实例-例如-你将为每一个创建一个新的顶点批处理，这绝对是一件坏事！相反，在你的游戏中有一个控制器对象来绘制所有的子弹，像这样：","That is not to say that you shouldn't use these functions, as they can be very handy. However, you should know which ones to use and when, as they all work slightly differently and will have different speeds. Rough rule of thumb is that the {}place_{} functions are faster than the {}instance_{} functions, which are faster than the {}collision_{} and {}point_{} functions, so read the pages in the manual for each of these types of functions and make sure to choose the most appropriate for every situation.":"这并不是说您不应该使用这些功能，因为它们非常方便。 但是，您应该知道使用哪些以及何时使用，因为它们的工作方式都略有不同，并且速度也不同。 粗略的经验法则是，{}place_{} 函数比 {2}instance_{3} 函数更快，而 instance_ 函数又比 {}collision_{} 和 {}point_{} 函数更快，因此请阅读手册中的页面以了解相关信息 每种类型的功能，并确保选择最适合每种情况的功能。","The memory and resources required to create those local variables are negligible, and are far outweighed by the instant benefit you (or anyone else reading the code later) gets from its clarity. The same idea should be applied to functions too, where you should assign sensible names to the input variables, and use clear formatting and local variables where required to make it as readable as possible.":"创建这些局部变量所需的内存和资源可以忽略不计，而且你(或任何其他阅读代码的人)从它的清晰度中获得的即时好处远远超过了它。同样的想法也应该应用于函数，你应该为输入变量分配合理的名称，并在需要的地方使用清晰的格式和局部变量，以使其尽可能可读。","There are many, many {}programming styles{}, and some would argue that theirs is the best one to use, but the truth is that almost any style is fine as long as you are {}consistent {}when using it and it is {}clear {}and {}obvious {}what everything is and does.":"有很多很多{}编程风格{}，有些人会争辩说他们的风格是最好的，但事实是，只要你在使用它时保持{}一致{}，并且一切都是{}清晰{}和{}明显{}的，几乎任何风格都是好的。","There are {}multiple ways to deal with collisions{} in {}GameMaker{}, and most of them come with a bit of extra CPU overhead attached. The {}collision_{} and {}point_{} functions, {}place_{} functions, and {}instance_{} functions all rely on {}bounding box{} checks with all instances of a given type within the room, and while there is some optimisation built in to the engine to limit these checks, collisions are never the most effecient thing to deal with. If you start to use precise collisions, performance will also get noticably worse, as not only will you be doing bounding box checks, but you will also be doing per-pixel checks, which is very slow indeed.":"{}GameMaker{} 中有{}多种处理冲突的方法{}，其中大多数都会带来一些额外的 CPU 开销。 {}collision_{} 和 {}point_{} 函数、{}place_{} 函数和 {}instance_{} 函数都依赖于{}边界框{}对房间内给定类型的所有实例进行检查，并且 虽然引擎内置了一些优化来限制这些检查，但碰撞从来都不是最有效的处理方式。 如果您开始使用精确碰撞，性能也会明显变差，因为您不仅要进行边界框检查，而且还要进行逐像素检查，这确实非常慢。",'This allocates the memory for it in one "chunk" with all array values being set to the default value of 0 and helps keep things fast, as otherwise every time you add a new value to the array the entire memory has to be re-allocated again.':'这将在一个"chunk"中为它分配内存，所有数组值都设置为默认值0，并有助于保持快速，否则每次向数组添加新值时，整个内存都必须重新分配。',"This function can be called before you create a surface to disable the depth buffer generation, and all surfaces created afterwards will not have a depth buffer created for them. You can enable/disable this function as required, and can even call it once at the start of the game to disable depth buffers for all subsequent surface calls (and in most 2D games this is fine). It won't give a major performance boost, but it's certainly something to keep in mind if your game relies heavily on surfaces and might stop your game running out of memory on lower-specced devices.":"这个函数可以在你创建一个表面之前调用，以禁用深度缓冲区的生成，之后创建的所有表面将不会有为它们创建的深度缓冲区。你可以根据需要启用/禁用这个函数，甚至可以在游戏开始时调用一次，以禁用所有后续表面调用的深度缓冲区。它不会给给予很大的性能提升，但如果你的游戏严重依赖于表面，这肯定是要记住的，可能会阻止你的游戏在低规格设备上耗尽内存。","This is a {}guide{}, and not the be-all-and-end-all-definitive-100%-perfect method to write your game! The things mentioned here are generally more on the organisational and micro-optimisation scale and should be incorporated into your programming habits when you feel comfortable with GML and think that they are appropriate.":"这是一个{}指南{}，而不是100%完美的编写游戏的方法！这里提到的东西通常更多的是组织和微观优化规模，当你对GML感到舒适并认为它们是合适的时，应该将其纳入你的编程习惯。",'Vertex information is sent in "batches" to the GPU for drawing, and in general the larger the batch the better. So "breaking" the batch should be avoided when drawing, as that will increase the number of vertex batches sent to the GPU. There are a number of things that will break the batch, with the main ones being {}blend modes{}, changing the&nbsp; {}shader{}, changing a uniform for a shader before drawing something, and drawing using&nbsp;the built-in shapes and primitives.':'顶点信息被"批量"发送到GPU进行绘制，通常批量越大越好。因此在绘制时应避免"破坏"批量，因为这会增加发送到GPU的顶点批量的数量。有很多事情会破坏批量，主要是{}混合模式{}，更改{}着色器{}，在绘制之前改变着色器的均匀性，以及使用内置的形状和图元进行绘制。',"When it comes to writing code everyone has a {}style{}. The style you program in is the way you place your brackets, how you indent the lines, and how you declare and name variables, etc., and is essential to making your code clear and readable to other people (and to your future self, when you have to come back to this project after a time on something else).":"在编写代码时，每个人都有一个{}风格{}。你编程时使用的风格是你放置括号的方式，你如何标记行，以及你如何声明和命名变量等，并且对于使你的代码清晰易读是必不可少的(当你不得不在其他事情上花费一段时间后回到这个项目时，对你未来的自己来说)。","When you just use surfaces as normal, {}GameMaker{} will actually create a surface and an accompanying depth buffer to ensure proper depth sorting when drawing anything in 3D. However, for most 2D games, this extra depth buffer is just not required and so is taking up extra memory space and processing time that could be used for other things. This is where the function {}{}surface_depth_disable(){}{}&nbsp;comes into play...":"当你只是正常使用表面时，{}GameMaker{}实际上会创建一个表面和一个附带的深度缓冲区，以确保在3D中绘制任何东西时正确的深度排序。然而，对于大多数2D游戏，这个额外的深度缓冲区是不需要的，因此占用了额外的内存空间和处理时间，可以用于其他事情。这就是函数{}{}surface_depth_disable(){}{}开始发挥作用...","While not completely unreadable, it is inefficient (the {}point_direction(){} function is called twice, for example) and it is messy and awkward to look at. It would be far better expressed as:":"虽然不是完全不可读，但它是低效的(例如，{}point_direction(){}函数被调用了两次)，而且看起来很混乱和笨拙。它会更好地表达为：","With that said, lets move on and look at some general tips for writing good GML code that you can apply at any time...":"说到这里，让我们继续前进，看看一些编写好的GML代码的一般技巧，你可以随时应用。","You can also free up the memory associated with an array by setting the variable used to equal 0. So, to clear the array from the code example above you would simply use:":"您还可以通过将变量used设置为等于0来释放与数组相关的内存。因此，要从上面的代码示例中清除数组，您只需使用用途：","You can find out more about particles from the page&nbsp;{}Guide To Using Particles{}.":"您可以从{}粒子使用指南{}页了解有关粒子的更多信息。","don't be afraid to use the trigonometric functions as (contrary to popular belief) they are pretty fast, especially when compared to particles, collisions, strings, etc...":"不要害怕使用三角函数，因为(与流行的观点相反)它们非常快，特别是与粒子，碰撞，弦等相比时。","don't put code that is not for drawing things in the Draw events":"不要在Draw事件中放置不用于绘制的代码","use an alarm to call any code that doesn't have to be called every step (rather than just adding this into the Step event anyway)":"使用alarm来调用任何不必在每一步都调用的代码(而不是将其添加到Step事件中)","{}Arrays{} are fast to use and require less memory than data-structures, but they can be optimised further still. When you create an array, memory is allocated to it based on its size, so you should try to initialise an array to its maximum size first, even if you don't plan on filling it until later on. For example, if you know you need an array to hold a maximum of 100 values, you would initialise it to 100 slots straight away, using the {}{}array_create(){}{}&nbsp;function:":"{}数组{}使用速度快，需要的内存比数据结构少，但它们还可以进一步优化。当你创建一个数组时，内存是根据它的大小分配给它的，所以你应该先尝试将数组初始化到它的最大大小，即使你不打算以后再填充它。例如，如果你知道你需要一个数组最多容纳100个值，你可以直接使用{}{}array_create(){}{}函数将其初始化为100个插槽：","{}Arrays{}{}Arrays{}":"{}数组{}{}数组{}","{}Collisions{}{}Collisions{}":"{}碰撞{}{}碰撞{}","{}Data Structures{}{}Data Structures{}":"{}数据结构{}{}数据结构{}","{}For texture swaps, the best and most efficient way to do this is to optimise how your sprites and backgrounds are stored on the texture page. This is done from the {}sprite properties{}, and you can create texture pages in the {}Texture Group Editor{}. If you have a number of images that are only used in the main menu (for example), then put them together on a separate {}texture page{}. The same if you have level-specific images, or the player and the enemies, etc. Basically, you want to group them by use so that the swaps are reduced as much as possible. Additionally, to help keep {}VRAM{} optimised you can then use the different {}prefetch and flush{} functions&nbsp;to load and remove textures from memory as required.":"{}对于纹理交换，最好、最有效的方法是优化精灵和背景在纹理页面上的存储方式。 这是通过{}精灵属性{}完成的，您可以在{}纹理组编辑器{}中创建纹理页面。 如果您有许多仅在主菜单中使用的图像（例如），请将它们放在单独的{}纹理页面{}上。 如果您有特定于关卡的图像，或者玩家和敌人等，情况也是如此。基本上，您希望按用途对它们进行分组，以便尽可能减少交换。 此外，为了帮助保持 {}VRAM{} 优化，您可以使用不同的{}预取和刷新{}函数根据需要从内存中加载和删除纹理。","{}NOTE{}&nbsp;As mentioned at the start of this page, if your game runs fine with a decent FPS then don't worry too much about texture swaps... especially when creating projects on the desktop targets. These optimisations are best when used with large games or on low-end mobile devices, and when used incorrectly can they actually negatively impact performance.":"{}注意{}如本页开头所述，如果您的游戏在FPS良好的情况下运行良好，则无需过多担心纹理交换.特别是在桌面目标上创建项目时。这些优化最适合用于大型游戏或低端移动的设备，如果使用不当，它们实际上会对性能产生负面影响。","{}NOTE{}&nbsp;If you don't require the instance to draw itself when using a controller in this way then you can simply add a comment into the Draw Event to suppress the default drawing, or make the instance invisible (although this will prevent all code running for the instance in all draw events).":"{}注意{}如果你不要求实例在使用控制器时以这种方式绘制自己，那么你可以简单地在绘制事件中添加一个注释来抑制默认的绘制，或者使实例不可见(尽管这将阻止所有绘制事件中为实例运行的所有代码)。","{}NOTE{}&nbsp;On the HTML5 target assigning arrays like this does not apply and your arrays should be initialised from 0 for this target! You can easily handle this by checking the os_browser variable, for example:":"{}注意{}在HTML5目标上，这样的数组赋值不适用，你的数组应该从0开始初始化！你可以通过检查os_browser变量来轻松处理这个问题，例如：","{}NOTE{}&nbsp;This doesn't just apply to using {}bm_add{} - any blending change will break the batch and will give a performance hit.":"{}注意{}这不仅仅适用于使用 {}bm_add{} - 任何混合更改都会破坏批次并影响性能。","{}Particles{} offer a very quick and efficient way to create dynamic effects in your game, and in general they give good performance. However, it's worth noting that using additive blending, alpha blending and colour blending on the particles may lower that performance, especially on mobile targets, so if you don't need it don't use it! Additive blending, in particular, can greatly increase the vertex batches and should be used with care.":"{}粒子{}提供了一种非常快速有效的方法来在游戏中创建动态效果，通常它们可以提供给予良好的性能。但是，值得注意的是，在粒子上使用加法混合，alpha混合和颜色混合可能会降低性能，特别是在移动的目标上，所以如果您不需要它，请不要使用它！特别是加法混合，可以大大增加顶点批次，应谨慎使用。","{}Particles{}{}Particles{}":"{}粒子{}{}粒子{}","{}Programming Style{}{}Programming Style{}":"{}编程风格{}{}编程风格{}","{}Surfaces{}{}Surfaces{}":"{}表面{}{}表面{}","{}Texture Swaps And Vertex Batches{}{}Texture Swaps And Vertex Batches{}":"{}纹理交换和顶点批{}{}纹理交换和顶点批{}","{}The above image is an example of a function declaration in a script to illustrate the above points. You can see that it uses the JSDoc style comments to clearly explain what it all does, and the coding style is consistent, with 4 space indents, underscores used for local vars, logged output, etc...":"{}上图是一个脚本中函数声明的例子，用来说明以上几点。你可以看到它使用了JSDoc风格的注释来清楚地解释它的全部功能，并且编码风格是一致的，有4个空格缩进，下划线用于本地变量，日志输出等...","{}Use Local Variables{}{}Use Local Variables{}":"{}使用局部变量{}{}使用局部变量{}","{}When writing code, you should be aware that when compiling your final game, {}GameMaker{} strips out comments, removes unnecessary line breaks and whitespace, substitutes in constant/macro/enum values, and generally compresses your code down as part of the process. This means that you can add as much whitespace around your code as required and you don't need to worry about keeping your comments short or only using them sparingly.":"{}在编写代码时，您应该注意，在编译最终游戏时，{}GameMaker{}会删除注释，删除不必要的换行符和空格，替换常量/宏/枚举值，这意味着你可以根据需要在代码周围添加尽可能多的空格，而不必担心保持注释简短或只使用它们有节制地"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="..",gTopicId="7.0_1"</script><script type="text/javascript" src="../template/scripts/rh.min.js"></script><script type="text/javascript" src="../template/scripts/common.min.js"></script><script type="text/javascript" src="../template/scripts/topic.min.js"></script><script type="text/javascript" src="../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Best Practices When Programming</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../assets/css/default.css" type="text/css"><script src="../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page that explains some best practices when programming using GameMaker"><meta name="rh-index-keywords" content="Best Practices When Programming"><meta name="search-keywords" content="best practices"><meta name="brsnext" value="Additional_Information/Bitwise_Operators.htm"><meta name="brsprev" value="Additional_Information/Additional_Information.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Best Practices When Programming"><span>Best Practices When Programming</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>Best Practices When Programming</h1><p>On this page we are going to cover some "best practices" when programming your game, and at the same time explain a little bit about the inner workings of <span data-keyref="GameMaker Name">GameMaker</span>. Before continuing, however, it is worth noting two very important points:</p><ul class="colour"><li>This is a <em>guide</em>, and not the be-all-and-end-all-definitive-100%-perfect method to write your game! The things mentioned here are generally more on the organisational and micro-optimisation scale and should be incorporated into your programming habits when you feel comfortable with GML and think that they are appropriate.</li><li>If your game runs fine and you are happy with things as they are, then <em>don't rush to change everything just to squeeze a few extra FPS out</em>. You have to strike a balance between readable, flexible and modular code with the time and energy required to change things, as well as the overall gain at the end. Basically, if it isn't broken, don't fix it and keep what you learn here for your next project.</li></ul><p>With that said, lets move on and look at some general tips for writing good GML code that you can apply at any time...</p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"><span data-open-text="true" data-skip-index="true">Programming Style</span><span data-close-text="true">Programming Style</span></a></p><div class="droptext" data-targetname="drop-down"><p class="dropspot">When it comes to writing code everyone has a <em>style</em>. The style you program in is the way you place your brackets, how you indent the lines, and how you declare and name variables, etc., and is essential to making your code clear and readable to other people (and to your future self, when you have to come back to this project after a time on something else).</p><p class="dropspot">There are many, many <a href="http://en.wikipedia.org/wiki/Programming_style">programming styles</a>, and some would argue that theirs is the best one to use, but the truth is that almost any style is fine as long as you are <strong>consistent</strong> when using it and it is <em>clear</em> and <em>obvious</em> what everything is and does.</p><p class="dropspot"><img alt="Code Style Example" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BestPractice_Style_Example.png">The above image is an example of a function declaration in a script to illustrate the above points. You can see that it uses the JSDoc style comments to clearly explain what it all does, and the coding style is consistent, with 4 space indents, underscores used for local vars, logged output, etc...</p><p class="dropspot">Also note that while the script editor permits you to fold code at each of the open/close brackets, you can use <span class="inline">#region</span> and <span class="inline">#endregion</span>&nbsp;tags to section off parts of your code and greatly enhance readability, especially when dealing with larger scripts which contain multiple functions. Regions can be commented, too - see the Editing section of this page in the manual):</p><p class="dropspot"><img alt="Example Of Using Regions" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BestPractice_Regions.png">When writing code, you should be aware that when compiling your final game, <span data-keyref="GameMaker Name">GameMaker</span> strips out comments, removes unnecessary line breaks and whitespace, substitutes in constant/macro/enum values, and generally compresses your code down as part of the process. This means that you can add as much whitespace around your code as required and you don't need to worry about keeping your comments short or only using them sparingly.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span data-open-text="true" data-skip-index="true">Use Local Variables</span><span data-close-text="true">Use Local Variables</span></a></p><div class="droptext" data-targetname="drop-down1"><p class="dropspot">Continuing on from the above point about programming style, one thing that a lot of beginners do is to cram as much into one line of code as possible. For example:</p><p class="code">draw_sprite(sprite_index, image_index, x + lengthdir_x(100, point_direction(x, y, mouse_x, mouse_y)), y + lengthdir_y(100, point_direction(x, y, mouse_x, mouse_y)));</p><p class="dropspot">While not completely unreadable, it is inefficient (the <span class="inline">point_direction()</span> function is called twice, for example) and it is messy and awkward to look at. It would be far better expressed as:</p><p class="code">var p_dir = point_direction(x, y, mouse_x, mouse_y);<br>var local_x = x + lengthdir_x(100, p_dir);<br>var local_y = y + lengthdir_y(100, p_dir);<br>draw_sprite(sprite_index, image_index, local_x, local_y);</p><p class="dropspot">The memory and resources required to create those local variables are negligible, and are far outweighed by the instant benefit you (or anyone else reading the code later) gets from its clarity. The same idea should be applied to functions too, where you should assign sensible names to the input variables, and use clear formatting and local variables where required to make it as readable as possible.</p><p class="dropspot">Local variables are fast to process in-game, so make the most of them, and if an expression appears in a code block or script two or more times, think about creating a local variable for it. When using the <a class="tooltip" title="This is a special compiler for creating executable packages that use native code instead of interepreted code and a runner (wich is what the GameMaker VM compile uses). Compiled code is faster to run, but takes more time to compile the executable.">YoYo Compiler (YYC)</a> targets, if you reference <span class="inline">global</span> or instance variables various times in a function or code block it is particularly beneficial to assign them to a local variable at the start of your code and then reference that local variable, as this will give much better performance.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span data-open-text="true" data-skip-index="true">Arrays</span><span data-close-text="true">Arrays</span></a></p><div class="droptext" data-targetname="drop-down2"><p class="dropspot"><a href="../GameMaker_Language/GML_Overview/Arrays.htm">Arrays</a> are fast to use and require less memory than data-structures, but they can be optimised further still. When you create an array, memory is allocated to it based on its size, so you should try to initialise an array to its maximum size first, even if you don't plan on filling it until later on. For example, if you know you need an array to hold a maximum of 100 values, you would initialise it to 100 slots straight away, using the <a href="../GameMaker_Language/GML_Reference/Variable_Functions/array_create.htm"><span class="inline">array_create()</span></a>&nbsp;function:</p><p class="code">array = array_create(100, 0);</p><p class="dropspot">This allocates the memory for it in one "chunk" with all array values being set to the default value of 0 and helps keep things fast, as otherwise every time you add a new value to the array the entire memory has to be re-allocated again.</p><p class="note"><span class="note">NOTE</span>&nbsp;On the HTML5 target assigning arrays like this does not apply and your arrays should be initialised from 0 for this target! You can easily handle this by checking the os_browser variable, for example:</p><p class="code"><span style="padding-left:1px">if (os_browser == browser_not_a_browser)<br>{<br>&nbsp; &nbsp; array_create(100, 0);<br>}<br>else<br>{<br>&nbsp; &nbsp; for (var i = 0; i &lt; 100; ++i;)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; array[i] = 0;<br>&nbsp; &nbsp; }<br>}</span></p><p class="dropspot">You can also free up the memory associated with an array by setting the variable used to equal 0. So, to clear the array from the code example above you would simply use:</p><p class="code">array = 0;</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#"><span data-open-text="true" data-skip-index="true">Data Structures</span><span data-close-text="true">Data Structures</span></a></p><div class="droptext" data-targetname="drop-down3"><p class="dropspot">In <span data-keyref="GameMaker Name">GameMaker</span> <a href="../GameMaker_Language/GML_Reference/Data_Structures/Data_Structures.htm">data structures</a> have been optimised to be a lot faster than previous GameMaker versions. They still need to be cleaned up (destroyed) when not used to free memory, and they can still be slower than, say, arrays, but the ease of use and the extra functions for dealing with the data they contain can often out-weigh the minimal speed difference, so don't be afraid to use them in your games.</p><p class="dropspot">It should be noted that of all the data structures, DS Maps in particular are lighting fast, both to read from and write to, making them an excellent option for all types of tasks.</p><p class="dropspot">Previously we mentioned <a href="../GameMaker_Language/GML_Overview/Accessors.htm">accessors</a>&nbsp;for arrays, but they are also available for data structures, which can help clean up your code and make it much easier to read.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#"><span data-open-text="true" data-skip-index="true">Collisions</span><span data-close-text="true">Collisions</span></a></p><div class="droptext" data-targetname="drop-down4"><p class="dropspot">There are <a href="../GameMaker_Language/GML_Reference/Movement_And_Collisions/Collisions/Collisions.htm">multiple ways to deal with collisions</a> in <span data-keyref="GameMaker Name">GameMaker</span>, and most of them come with a bit of extra CPU overhead attached. The <span class="inline">collision_</span> and <span class="inline">point_</span> functions, <span class="inline">place_</span> functions, and <span class="inline">instance_</span> functions all rely on <a class="tooltip" title="For sprites, the bounding-box is the name given to the edges of the area that collisions will initially be detected in, and it doesn't have to be the same size as the sprite it's being applied to. For sequences, the bounding box is the outer edge of the total space that one or more assets occupy in the canvas.">bounding box</a> checks with all instances of a given type within the room, and while there is some optimisation built in to the engine to limit these checks, collisions are never the most effecient thing to deal with. If you start to use precise collisions, performance will also get noticably worse, as not only will you be doing bounding box checks, but you will also be doing per-pixel checks, which is very slow indeed.</p><ul class="dropspotlist"></ul><p class="dropspot">That is not to say that you shouldn't use these functions, as they can be very handy. However, you should know which ones to use and when, as they all work slightly differently and will have different speeds. Rough rule of thumb is that the <span class="inline">place_</span> functions are faster than the <span class="inline">instance_</span> functions, which are faster than the <span class="inline">collision_</span> and <span class="inline">point_</span> functions, so read the pages in the manual for each of these types of functions and make sure to choose the most appropriate for every situation.</p><p class="dropspot">Alternatively, look into creating a <strong>tile-based collision system</strong>, which can be created using the <a href="../GameMaker_Language/GML_Reference/Asset_Management/Rooms/Tile_Map_Layers/Tile_Map_Layers.htm">tilemap functions</a>&nbsp;or even a custom 2D array or DS grid. These will be very fast and will help boost your game's speed. However, if you are using irregular terrain or walls and objects that don't align to a grid they may not be appropriate. You can find a very simple tutorial on tilemap collisions from the following video link</p><ul class="dropspotlist"><li class="dropspot"><a href="https://youtu.be/UyKdQQ3UR_0">Tile Collisions In <span data-keyref="GameMaker Name">GameMaker</span></a></li></ul><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down5" href="#"><span data-open-text="true" data-skip-index="true">Texture Swaps And Vertex Batches</span><span data-close-text="true">Texture Swaps And Vertex Batches</span></a></p><div class="droptext" data-targetname="drop-down5"><p class="dropspot">If you switch on the <a href="../GameMaker_Language/GML_Reference/Debugging/show_debug_overlay.htm"><strong>debug overlay</strong></a>,&nbsp;you will see that there are two figures in brackets at the top of your screen when testing. The first is the number of <strong>texture swaps</strong> being done and the second is the number of <strong>vertex batches</strong>. A number of factors will influence these figures and you will never get them down to (0) (0) as the engine requires one or two of each every step, but you should aim to get these values down as low as possible.</p><p class="dropspot"><img alt="The Debug Overlay Bar" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BestPractices_DebugOverlay.png">For texture swaps, the best and most efficient way to do this is to optimise how your sprites and backgrounds are stored on the texture page. This is done from the <a href="../The_Asset_Editors/Sprites.htm">sprite properties</a>, and you can create texture pages in the <a href="../Settings/Texture_Groups.htm">Texture Group Editor</a>. If you have a number of images that are only used in the main menu (for example), then put them together on a separate <a href="../Settings/Texture_Information/Texture_Pages.htm">texture page</a>. The same if you have level-specific images, or the player and the enemies, etc. Basically, you want to group them by use so that the swaps are reduced as much as possible. Additionally, to help keep <a class="tooltip" title="VRAM is the amount of memory available for video, ie: the memory space that can store textures and images.">VRAM</a> optimised you can then use the different <a href="../GameMaker_Language/GML_Reference/Drawing/Textures/Textures.htm">prefetch and flush</a> functions&nbsp;to load and remove textures from memory as required.</p><p class="note"><span class="note">NOTE</span>&nbsp;As mentioned at the start of this page, if your game runs fine with a decent FPS then don't worry too much about texture swaps... especially when creating projects on the desktop targets. These optimisations are best when used with large games or on low-end mobile devices, and when used incorrectly can they actually negatively impact performance.</p><p class="dropspot">Vertex information is sent in "batches" to the GPU for drawing, and in general the larger the batch the better. So "breaking" the batch should be avoided when drawing, as that will increase the number of vertex batches sent to the GPU. There are a number of things that will break the batch, with the main ones being <strong>blend modes</strong>, changing the&nbsp; <strong>shader</strong>, changing a uniform for a shader before drawing something, and drawing using&nbsp;the built-in shapes and primitives.</p><p class="dropspot">So, if you have a number of bullet instances that draw using the <span class="inline">bm_add</span> blend mode - for example - you will be creating a new vertex batch for each one, which is definitely a bad thing! Instead, have a controller object in your game that draws all the bullets instead, like this:</p><p class="code">gpu_set_blendmode(bm_add);<br><br>with (obj_BULLET)<br>{<br>&nbsp; &nbsp; draw_self();<br>}<br><br>gpu_set_blendmode(bm_normal);</p><p class="note"><span class="note">NOTE</span>&nbsp;This doesn't just apply to using <span class="inline" style="font-size:14px">bm_add</span> - any blending change will break the batch and will give a performance hit.</p><p class="dropspot">In this way, all the bullets will be drawn in the same batch. Judicious use of the functions <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendenable.htm"><span class="inline">gpu_set_blendenable()</span></a>, <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestref.htm"><span class="inline">gpu_set_alphatestref()</span></a>, and <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_alphatestenable.htm"><span class="inline">gpu_set_alphatestenable()</span></a>&nbsp;can greatly improve performance and can be enabled/disabled as required throughout your project code, although they may not be appropriate for all types of graphics or projects.</p><p class="note"><span class="note">NOTE</span>&nbsp;If you don't require the instance to draw itself when using a controller in this way then you can simply add a comment into the Draw Event to suppress the default drawing, or make the instance invisible (although this will prevent all code running for the instance in all draw events).</p><p class="dropspot">Another way to reduce these numbers is to disable the <strong>Separate Texture Page</strong> option for sprites unless absolutely necessary. Each image stored in this way is sent to its own texture page and batched differently, so having these images on a regular texture page is better. You can then get the UVS coordinates using the <a href="../GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm"><span class="inline">sprite_get_uvs()</span></a>&nbsp;function and store them in variables for use later. It may be a small amount of extra code, but the boost you will get is worth it. Note that this method will not permit texture repeats!</p><p class="dropspot">As with all these tips, if it makes your life more difficult to change it and your game runs fine, don't worry about it too much...</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down6" href="#"><span data-open-text="true" data-skip-index="true">Particles</span><span data-close-text="true">Particles</span></a></p><div class="droptext" data-targetname="drop-down6"><p class="dropspot"><a href="../GameMaker_Language/GML_Reference/Drawing/Particles/Particles.htm">Particles</a> offer a very quick and efficient way to create dynamic effects in your game, and in general they give good performance. However, it's worth noting that using additive blending, alpha blending and colour blending on the particles may lower that performance, especially on mobile targets, so if you don't need it don't use it! Additive blending, in particular, can greatly increase the vertex batches and should be used with care.</p><p class="dropspot">Note that on the non-WebGL HTML5 target, having multi-coloured, fading particles will require a lot of image caching and will be very slow. However, since particle sprites can be animated, you can create an animated sprite that has sub-images which change colour and then use that for the particle instead. It will still look like a gradual colour change, but not require the constant creation of cache images.</p><p class="dropspot">You can find out more about particles from the page&nbsp;<a href="Guide_To_Using_Particles.htm">Guide To Using Particles</a>.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down7" href="#"><span data-open-text="true" data-skip-index="true">Surfaces</span><span data-close-text="true">Surfaces</span></a></p><div class="droptext" data-targetname="drop-down7"><p class="dropspot">Finally, we're going to touch briefly on using <a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/Surfaces.htm">surfaces</a>, as <span data-keyref="GameMaker Name">GameMaker</span> has a fairly significant optimisation when using them in your games: the ability to switch on and off the <strong>depth buffer</strong>.</p><p class="dropspot">When you just use surfaces as normal, <span data-keyref="GameMaker Name">GameMaker</span> will actually create a surface and an accompanying depth buffer to ensure proper depth sorting when drawing anything in 3D. However, for most 2D games, this extra depth buffer is just not required and so is taking up extra memory space and processing time that could be used for other things. This is where the function <a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/surface_depth_disable.htm"><span class="inline">surface_depth_disable()</span></a>&nbsp;comes into play...</p><p class="dropspot">This function can be called before you create a surface to disable the depth buffer generation, and all surfaces created afterwards will not have a depth buffer created for them. You can enable/disable this function as required, and can even call it once at the start of the game to disable depth buffers for all subsequent surface calls (and in most 2D games this is fine). It won't give a major performance boost, but it's certainly something to keep in mind if your game relies heavily on surfaces and might stop your game running out of memory on lower-specced devices.</p></div><p>&nbsp;</p><p>Apart from the main things mentioned above, there are other more general things that can help with performance and that are considered "good practices" too:</p><ul class="colour"><li>don't be afraid to use the trigonometric functions as (contrary to popular belief) they are pretty fast, especially when compared to particles, collisions, strings, etc...</li><li>don't put code that is not for drawing things in the Draw events</li><li>use an alarm to call any code that doesn't have to be called every step (rather than just adding this into the Step event anyway)</li></ul><p>But, as we mentioned at the start of the page, all these optimisations are optional and if your game runs fine with 60 vertex batches, 80 texture swaps, additive blending, etc., then don't worry about it too much! Just keep these things in mind when programming your next game...</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Additional_Information.htm">Additional Information</a></div><div style="float:right">Next:&nbsp;<a href="Bitwise_Operators.htm">Bitwise Operators</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>