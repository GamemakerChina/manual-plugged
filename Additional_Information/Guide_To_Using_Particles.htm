<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../assets/import/layer/layer.js"></script><script type="text/javascript" src="../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let o;o=a?e.attr(a):e.html();let s=t[removeHtml(o)];if(null!=s&&s.length){t=retHtml(o);let i=0;t&&t.forEach(function(e,t){var a=s.replace("{"+i+"}",e);s=a===s?s.replace("{}",e):a,i++}),a?e.attr(a,s):e.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"And for those of you that use {}GML Visual{}:":"对于那些使用{}GML Visual{}的用户：","And using {}GML Visual{}:":"使用{}GML Visual{}：",'As mentioned at the start, once created, a particle system (and its particles, emitters, etc.) are stored in memory for instant use. Great, but what happens when you restart the game? Or if your player dies and starts the room again? Well, if you don\'t manage the game right you get a {}memory leak{}. This is when something has been created and uses up memory, but has been "de-referenced" meaning that&nbsp;{}GameMaker{} no longer has access to it. This kind of thing will slowly eat up memory and cause lag in your game or even block the computer causing your game to crash, and it is a pretty common problem with first time users of particle systems.':'正如开始时提到的，一旦创建，粒子系统(以及它的粒子，发射器等)都存储在内存中供即时使用。太好了，但是当你重新启动游戏时会发生什么呢？或者如果你的玩家死了，重新启动房间呢？好吧，如果你没有正确地管理游戏，你会得到一个{}内存泄漏{}。这是当一些东西被创建并耗尽内存时，但是已经被"de-referenced"了，这意味着{}GameMaker{}不再可以访问它。这种事情会慢慢消耗内存，导致游戏延迟，甚至阻塞计算机，导致游戏崩溃，这是第一次使用粒子系统的用户经常遇到的问题。',"Before going any further, we should probably explain what a particle actually is... Basically, a {}{}particle is a graphic resource that has certain properties which are defined by a {}particle system{}. These properties cannot be manipulated directly for {}individual {}particles, but are changed collectively through the code or actions that are used to define the system that it belongs to. They are very useful for creating beautiful and flashy effects - or subtle and discreet ones -&nbsp;in a game without the CPU overhead that using instances has.":"在进一步讨论之前，我们或许应该解释一下粒子实际上是什么...基本上，{}{}粒子是一种图形资源，具有由{}粒子系统{}定义的某些属性。 这些属性无法直接针对{}单个{}粒子进行操作，但可以通过用于定义其所属系统的代码或操作来集体更改。 它们对于在游戏中创建美丽而华丽的效果（或微妙而谨慎的效果）非常有用，而无需像使用实例那样产生 CPU 开销。","Before setting up a system and creating particles, it's important to know a few things... First is that most of a particle systems code is {}only ever called once in the game{}, usually in some type of controller object in the first room or level - this is not always the case, but for the sake of simplicity, we'll be using this scenario for the following brief guide as it's the most common way to use particles. You do this because a particle system, once created, stays in memory and is ready to be used at any time, so if you create it more than once it can quickly increase the memory usage and cause serious lag, and even has the potential of crashing the game. For the sake of simplicity in this guide, you&nbsp;will make a {}global{}{}&nbsp;{}particle system that can be used by any instance in the game at any time.":"在设置系统和创建粒子之前，了解一些事情很重要...首先，大多数粒子系统代码{}仅在游戏中调用一次{}，通常在游戏中的某种类型的控制器对象中 第一个房间或关卡 - 情况并非总是如此，但为了简单起见，我们将在以下简要指南中使用此场景，因为这是使用粒子的最常见方法。 这样做是因为粒子系统一旦创建，就会保留在内存中并随时可以使用，因此如果多次创建它，它会迅速增加内存使用量并导致严重的滞后，甚至有可能 使游戏崩溃。 为了在本指南中简单起见，您将创建一个可供游戏中任何实例随时使用的{}全局{}{} {}粒子系统。","Below is an example of the code/actions required to define two emitters, which would normally go in the {}Create Event{} of a controller object, just after defining the particle system. One will be static and stream particles over the area of the whole room, while the other will be dynamic and follow the mouse and burst every 30 steps from a small ellipse:":"下面是定义两个发射器所需的代码/动作的示例，它们通常会在定义粒子系统之后进入控制器对象的{}创建事件{}。一个是静态的，并在整个房间的区域上流动粒子，而另一个是动态的，并跟随鼠标从一个小椭圆每30步爆发一次：",'But what if you want several objects to emit particles? A global emitter can only be in one place at a time, so you would need to create {}local {}emitters in each object. These emitters will still use the global particle system and any particles that are within it, but they can be different shapes and sizes and move with the object, making them ideal for rockets or bullets or things. The code you would use is exactly the same as above, but without the "global" prefix before the emitter names.':'但是如果你想让几个物体发射粒子呢？全局发射器一次只能在一个地方，所以你需要在每个对象中创建{}局部{}发射器。这些发射器仍然使用全局粒子系统和其中的任何粒子，但它们可以是不同的形状和大小，并随对象移动，使它们成为火箭或子弹或其他东西的理想选择。您将使用的代码与上面完全相同，但在发射器名称之前没有"global"前缀。',"How do you avoid this? Well, {}GameMaker{} has&nbsp;{}GML Code{} functions and&nbsp;{}GML Visual{} actions to delete particle systems and their emitters and particles from memory when not in use, and with a little bit of planning when using the following code/actions, you can easily prevent this potential problem.":"如何避免这种情况？好吧，{}GameMaker{}有{}GML Code{}函数和{}GML Visual{}操作，可以在不使用时从内存中删除粒子系统及其发射器和粒子，并且在使用以下代码/操作时进行一点规划，您可以轻松防止此潜在问题。",'If you already have a&nbsp;{}{}Particle System Asset{}{}, you can create it using the above function/action by passing the asset into the {}partsys{}/"System" argument.':'如果已经有{}{}粒子系统资源{}{}，则可以使用上述函数/操作通过将资源传递到{}partsys{}/"System"参数中来创建它。',"Let's look at some code that defines a particle now:":"现在让我们看一些定义粒子的代码：","Now we have code/{}GML Visual{} to stream particles (these particles will be emitted every game step without us having to anything else), but we also want to add an {}A{}{}larm[0]{}&nbsp;{}Event{} to burst particles at specific intervals:":"现在我们有代码/{}GML Visual{}来流式传输粒子(这些粒子将在每个游戏步骤中发射，而无需我们做任何其他事情)，但我们还想添加{}A{}{}larm[0]{}{}Event{}来以特定的时间间隔爆发粒子：",'Now you know the basics about particles, particle systems and emitters, so you can now add them into your game! But before rushing off and adding particle effects to everything, please note that while particles are less CPU hungry than instances, they are not the solution to everything as they will cause lag if you have thousands of them at a time. The best thing to do is experiment and use them carefully to "flesh out" visually a game and give it a bit more eye-candy without over doing it.':'现在你已经了解了粒子、粒子系统和发射器的基础知识，所以你现在可以将它们添加到你的游戏中了！但在匆忙离开并将粒子效果添加到所有内容之前，请注意，虽然粒子比实例占用的CPU少，它们并不是解决一切问题的方法，因为如果你一次有数千个它们，它们会导致滞后。最好的办法是仔细试验和使用它们来"充实"视觉上的游戏和给予它多一点眼睛糖果没有做过。','Now, before we present you the code for defining the particle, let\'s just talk about "{}wiggle{}" for a moment... Believe it or not, "wiggle" is a particle property and can be set for many of the above settings individually. When you see "wiggle" as an argument for a particle function or action, it means that if you place a number between 1 and 20 the particle will "wiggle" or fluctuate between the min and max values for the property, with 1 being a slow wiggle and 20 being very fast. So a particle speed minimum of 2 and maximum of 5 with a wiggle of 20 will oscillate very quickly between the min/max speeds for the lifetime of each particle created.':'现在，在我们向你展示定义粒子的代码之前，让我们先讨论一下"{}wiggle{}".这意味着如果你在1和20之间放置一个数字，粒子将在属性的最小值和最大值之间"摆动"或波动，其中1表示缓慢摆动，20表示非常快。因此，粒子速度最小值为2，最大值为5，摆动为20，将在所创建的每个粒子的寿命内在最小/最大速度之间非常快地振荡。',"Since we've explained the easy way to create particles, let's now go the slightly more complex way, which is to use {}emitters{}. Emitters are another part of the particle system that has to be defined before being used, so we'll make a global emitter the same as we did for the system and the particles. We also have to decide whether to have a static (non-moving) emitter or not and whether we are going to {}burst {}or {}stream {}the particles, as well as decide over what area and what kind of distribution we are going to have the emitter use.":"既然我们已经解释了创建粒子的简单方法，现在让我们来看看稍微复杂一点的方法，即使用{}发射器{}。发射器是粒子系统的另一部分，必须在使用之前定义，所以我们要做一个全局发射器，就像我们为系统和粒子做的一样。我们还必须决定是否要有一个静态的(非移动)发射器与否，以及我们是否要{}爆裂{}或{}流{}粒子，以及决定在什么区域和什么样的分布，我们要有发射器使用。","So that's the system created, but what about the particles? We have to define them too or the system is useless and does nothing.":"这就是我们创造的系统，但是粒子呢？我们也必须定义它们，否则这个系统是无用的，什么也不做。","That's the creation of particles dealt with but there is one more thing that's very important... Cleaning up when you are finished with them.":"这就是粒子的创建，但还有一件事非常重要......当你完成它们时，清理它们。","The first thing you have to do is decide where you are going to create the system and how you will use it. You could create a global system in the {}Game Start Event{} of an object that is in your first room (like a menu or title screen), but this means that if you restart the game using the&nbsp;{}{}game_restart{}{} function, it will be recreated and cause a memory leak. Or you could create a local system in an instance in any room, but again, if you leave the room then the system will be inaccessible and cause a memory leak. To avoid this you would need to have something like this in the {}{}Game End Event{}{} or the {}{}Clean Up Event{}{} of your object:":"您要做的第一件事是决定在哪里创建系统以及如何使用它。 您可以在第一个房间中某个对象（如菜单或标题屏幕）的{}游戏开始事件{}中创建一个全局系统，但这意味着如果您使用 {}{}game_restart{}{} 函数，它将被重新创建并导致内存泄漏。 或者，您可以在任何房间的实例中创建本地系统，但同样，如果您离开房间，则系统将无法访问并导致内存泄漏。 为了避免这种情况，您需要在对象的{}{}游戏结束事件{}{}或{}{}清理事件{}{}中添加类似的内容：","The following images illustrate the different types of area shape available for emitters:":"下图说明了发射器可用的不同类型的区域形状：","There are a couple of ways to create particles, and each has its pros and cons. You can use {}emitters{} to {}burst {}or {}stream {}particles, or you can create particles {}directly {}at a point. Which one you use really depends on what you are trying to achieve and the effect you are wanting to create, but we'll start with the easiest of the two, which is creating particles directly. In GML we'd use the following function:":"有几种方法可以创建粒子，每种方法都有其优点和缺点。你可以使用{}发射器{}来{}爆裂{}或{}流{}粒子，或者你可以在一个点{}直接{}创建粒子。你使用哪一种实际上取决于你想要实现的目标和你想要创建的效果，但我们将从两种方法中最简单的开始，也就是直接创建粒子。在GML中，我们使用以下函数：","This guide is for those of you who want to understand how to use and create {}particles{}&nbsp;in GML. This page will cover both the {}{}GML Code{}&nbsp;functions{}&nbsp;and {}{}GML Visual{}&nbsp;actions{}&nbsp;for particles, so if you've never used particles before, we hope that this guide can get you started as they are very useful and quite fun to make.":"本指南适合那些想要了解如何在 GML 中使用和创建{}粒子{}的人。 本页将介绍粒子的 {}{}GML 代码{}函数{}和 {}{}GML 视觉{}操作{}，因此，如果您以前从未使用过粒子，我们希望本指南能够帮助您 开始是因为它们非常有用并且制作起来很有趣。","To create this same particle definition in&nbsp;{}GML Visual{} we'd need these actions:":"要在{}GML Visual{}中创建相同的粒子定义，我们需要执行以下操作：","To start with you need to define the particle system and give it a name so that you can use it. As this is going to be a global system that any object can use you would do this&nbsp;in a controller object or an initialisation function run at the start of the game. The&nbsp;{}GML Code{} would look like this:":"首先，你需要定义粒子系统，并给它给予一个名字，这样你就可以使用它。因为这将是一个任何对象都可以使用的全局系统，所以你可以在游戏开始时运行的控制器对象或初始化函数中完成这一点。{}GML代码{}看起来像这样：","To use a particle in a system you have to first define its general properties. These are like object properties, but they only apply in a {}general {}way to individual particles. What this means is that if you give the particles a minimum movement speed of 1 and a maximum movement speed of 2, any particle created by the system will have a random speed between 1 and 2 pixels per step, and that overall they will have an average speed of 1.5. You should name and add your first particle to the system using the following GML in the same object that you used to create the system:":"要在系统中使用粒子，您必须首先定义其一般属性。这些属性类似于对象属性，但它们仅以{}一般{}方式应用于单个粒子。这意味着，如果您给予粒子最小移动速度1和最大移动速度2，则系统创建的任何粒子将具有每步1到2像素的随机速度，它们的平均速度为1.5。您应该在创建系统时使用的同一对象中使用以下GML命名第一个粒子并将其添加到系统中：",'We have mentioned particle systems, so let\'s explain what that is before continuing. Think of a {}{}particle system like a container that you will use to hold your particles ready for use. You can use code or actions to define the visual aspect of the particles, and then they are placed in the "container" (the particle system) so that you can take it out and use it whenever and wherever you need it later.':"我们已经提到了粒子系统，所以在继续之前让我们解释一下它是什么。 将{}{}粒子系统想象成一个容器，您将用它来保存可供使用的粒子。 您可以使用代码或动作来定义粒子的视觉方面，然后将它们放置在“容器”（粒子系统）中，以便您以后可以随时随地将其取出并使用。","What does all that mean? Well, a {}static {}emitter is one that you can define once and forget about as it will not be moving anywhere for the duration of the game, ie: think of a log fire - it doesn't move, it just emits flames and so is static, but a fireball would require a {}dynamic{} emitter and will move across the screen. As for bursting or streaming, a burst is a one off explosion of particles, whereas a stream is just that - a constant stream of particles every step. For area and distribution, with emitters you can define an area for emitting particles (which can be a rectangle, ellipse, diamond or line) as well as the distribution curve (gaussian, inverse gaussian, or linear).":"这是什么意思好吧，一个{}静态{}发射器是一个你可以定义一次，忘记，因为它不会移动任何地方的游戏期间，即：想想一个木头火-它不移动，它只是发出火焰，所以是静态的，但火球需要一个{}动态{}发射器，并会在屏幕上移动。至于爆裂或流，爆裂是粒子的一次性爆炸，对于面积和分布，您可以使用发射器定义发射粒子的面积(可以是矩形，椭圆，菱形或直线)以及分布曲线(高斯，逆高斯或线性)。","You&nbsp;now have a system and a particle to put in it, but you're not ready yet to create your outstanding effects! You&nbsp;still have to define the properties of the particle, ie: how it looks - its speed, its rotation, its alpha, etc. There are a lot of details that can be used to define a particle effect, so below is an overview of the most important settings and then a snippet of code and&nbsp;{}GML Visual{} that uses all of them:":"你现在有一个系统和一个粒子，但你还没有准备好创造你的杰出效果！你仍然需要定义粒子的属性，即：它的外观-它的速度，它的旋转，它的阿尔法，等等。有很多细节可以用来定义粒子效果，因此，下面是最重要的设置的概述，然后是使用所有这些设置的代码片段和{}GML Visual{}：","and in&nbsp;{}GML Visual{} it'd be:":"在{}GML Visual{}中，它将是：","{} And the distribution curves (linear, gaussian, and inverse gaussian) are illustrated here:":"{}分布曲线(线性、高斯和逆高斯)如下所示：","{}A particle burst is simply a one-off explosion of particles from the emitter, rather than a constant stream of them every game step.":"{}粒子爆发只是发射器中粒子的一次性爆炸，而不是每个游戏步骤中粒子的恒定流。","{}Cleaning Up{}{}Cleaning Up{}":"{}清理{}{}清理{}","{}Creating A Particle System{}{}Creating A Particle System{}":"{}创建粒子系统{}{}创建粒子系统{}","{}Creating Particles Directly In-Game{}{}Creating Particles Directly In-Game{}":"{}直接在游戏中创建粒子{}{}直接在游戏中创建粒子{}","{}Creating Particles With Emitters{}{}Creating Particles With Emitters{}":"{}使用发射器创建粒子{}{}使用发射器创建粒子{}","{}Defining A Particle Type{}{}Defining A Particle Type{}":"{}定义粒子类型{}{}定义粒子类型{}","{}Guide To Using Particles{}":"{}粒子使用指南{}","{}So that's it! We have now defined our particles and they are ready to be used.":"{}所以就是这样！我们现在已经定义了我们的粒子，它们可以使用了。","{}So, here we are creating two particle emitters that are assigned to the particle system we created at the start. The functions/actions to create these emitters permit us to define an area in the room over which they will emit particles, as well as give the particle type to emit, and the shape and distribution to use within the defined area. The functions/actions will return a numeric value, which is the emitter ID value, and we store this in a variable so that we can use further emitter functions to target those emitters.":"{}这里我们创建两个粒子发射器，它们被分配给我们在开始时创建的粒子系统。创建这些发射器的函数/动作允许我们在房间中定义一个区域，它们将在该区域上发射粒子，以及给予要发射的粒子类型，以及在定义的区域内使用的形状和分布。函数/动作将返回一个数值，即发射器ID值，我们将其存储在一个变量中，这样我们就可以使用更多的发射器函数来定位这些发射器。",'{}That single code/action above will create 10 particles at the given x/y coordinates of type "Particle1" from our global system. Simple! The great thing about that line of code/action is that it can be used anywhere without any fuss. For example if you place it in the {}Global Left Pressed{} event for the mouse in an object and change x/y values for the mouse_x/y position, it will create particles at the mouse position every time you press the button. Or if you have a rocket, then you could place this in the step event and have smoke particles coming every step (although 1 or 2 would probably be better than 10!). You can even have it create particles over an area by changing the x/y coordinates randomly, for example:':'{}上面的代码/动作将在全局系统中的给定x/y坐标处创建10个粒子，类型为"Particle 1"。简单！这行代码/动作的伟大之处在于，它可以在任何地方使用，没有任何大惊小怪。例如，如果你把它放在对象中鼠标的{}全局左按{}事件中，并改变mouse_x/y位置的x/y值，它会在你每次按下按钮时在鼠标位置创建粒子。或者如果你有一个火箭，那么你可以把它放在step事件中，每一步都有烟雾粒子(尽管1或2可能比10更好！)。你甚至可以让它通过随机改变x/y坐标在一个区域上创建粒子，例如：',"{}The above code will create 50 particles at a random position within a 40px square area.":"{}上面的代码将在一个40px的正方形区域内的随机位置创建50个粒子。","{}This will remove the defined particles, emitters, and then the system from memory ready for you to restart the game or change room. Just remember that after thinking about where would be the most suitable place to create the system, think about where would be the most suitable place to destroy the system too!":"{}这将删除定义的粒子，发射器，然后系统从内存中准备重新启动游戏或改变房间。只要记住，在思考哪里是最合适的地方创建系统后，想想哪里是最合适的地方摧毁系统太！","{}alpha{}:&nbsp;Sets the alpha value for the particle between a value of 0 and 1. If a single value is passed in this will be the alpha of the particle, if two or three values are passed in then the alpha will blend between these over the lifetime of the particle.":"{}alpha{}：设置粒子的alpha值介于0和1之间。如果传入单个值，则该值将成为粒子的alpha，如果传入两个或三个值，则alpha将在粒子的生命周期内在这些值之间混合。",'{}blending{}:&nbsp;Sets whether to use {}additive {}blending or {}normal {}blending for the particle type. This is set in a function when using&nbsp;{}GML Code{} and as part of the particle initialisation when using {}GML Visual{}. Additive blending means that the particles will use the {}bm_add{} blend mode, giving them a "glowing" look where they overlap, and also blending them with anything drawn underneath (sprites, backgrounds, tiles, etc.) - very useful for fire and magic effects (for example), but best left off for something like smoke. Experiment to see the differences! Note that enabling this will break the texture batching when particles are created, and so more batches will be required per step to draw them - something to consider as it may affect performance, especially on mobile.':"{}blending{}：设置是否对粒子类型使用{}加法{}混合或{}正常{}混合。 当使用 {}GML Code{} 时，这是在函数中设置的；当使用 {}GML Visual{} 时，这是粒子初始化的一部分。 加法混合意味着粒子将使用 {}bm_add{} 混合模式，在重叠处赋予它们“发光”的外观，并将它们与在下面绘制的任何内容（精灵、背景、图块等）混合 - 对于以下情况非常有用 火焰和魔法效果（例如），但最好不要使用烟雾之类的效果。 实验看看差异！ 请注意，启用此功能会在创建粒子时破坏纹理批处理，因此每个步骤都需要更多批次来绘制它们 - 需要考虑这一点，因为它可能会影响性能，尤其是在移动设备上。","{}colour{}:&nbsp;Sets the colour for the particle if a single colour is used. If two or three colours are supplied this will be the colour blend, blending from one to the other over its lifetime.":"{}colour{}：如果使用单一颜色，则设置粒子的颜色。如果提供两种或三种颜色，则这将是颜色混合，在其生命周期内从一种颜色混合到另一种颜色。","{}direction{}:&nbsp;Sets the direction properties for the particle type. Again you specify a range of directions (in counterclockwise degrees - 0 indicates a motion to the right, 90 indicates a motion upwards, etc...). For example, to let the particle move in a random direction you'd choose a minimum of 0 and a maximum of 360 as values. You can specify an increase in direction for each step too (can also be negative).":"{}direction{}：设置粒子类型的方向属性。同样你指定一个方向范围(以逆时针角度计，0表示向右运动，90表示向上运动，等等)。例如，为了让粒子在一个随机的方向上移动，你可以选择最小值0和最大值360作为值。你也可以为每一步指定一个方向的增加(也可以是负数)。","{}life{}:&nbsp;Sets the lifetime bounds, in steps (game frames) for the particle type. Like previous settings, this has a minimum and maximum value and particles will last a random number of steps within these values. So, a lifetime of 30 min and 30 max will have the particle existing for exactly 30 steps, but a lifetime of 20 min and 60 max will have each particle exists for a random number of steps between 20 and 60.":"{}life{}：以步长设置生存期界限(游戏帧)的粒子类型。像以前的设置，这有一个最小值和最大值，粒子将持续在这些值内的随机步数。所以，30分钟和30最大的生命周期将有粒子存在正好30步，但是20分钟和60最大的寿命将使每个粒子存在20和60之间的随机步数。","{}orientation{}:&nbsp;Sets the orientation angle properties for the particle type. You specify the minimum angle, the maximum angle, and the increase in each step. You can also indicate whether the given angle should be relative to the current direction of motion or absolute, e.g: by setting all values to 0 but relative to true, the particle orientation will precisely follow the path of the particle.":"{}orientation{}：设置粒子类型的方向角属性。您可以指定最小角度、最大角度和每一步的增量。您还可以指定给定的角度是相对于当前运动方向还是绝对角度，例如：通过将所有值设置为0但相对于true，粒子方向将精确地跟随粒子的路径。","{}shape{}:&nbsp;The shape of the particle is the built in sprite that it will use, with the default being the constant {}pt_shape_pixel{}. There is also a function to add a custom particle if required -&nbsp;{}{}part_type_sprite{}{}&nbsp;- or the action {}Set Particle Sprite{}.":"{}shape{}：粒子的形状是它将使用的内置精灵，默认值为常量 {}pt_shape_pixel{}。 如果需要，还有一个用于添加自定义粒子的函数 - {}{}part_type_sprite{}{} - 或操作{}设置粒子精灵{}。","{}size{}:&nbsp;Sets the size parameters for the particle type. You specify the minimum starting size, the maximum starting size, and the size increase in each step (use a negative number for a decrease in size). This is a scalar value that will modify the base image x/y scale equally.":"{}size{}：设置粒子类型的尺寸参数。 您指定最小起始大小、最大起始大小以及每个步骤中的大小增加（使用负数表示大小减少）。 这是一个标量值，它将同等地修改基本图像的 x/y 比例。","{}speed{}:&nbsp;Sets the speed properties for the particle type. You specify a minimum and maximum speed and a random value between the given bounds is chosen when the particle is created. You can indicate a speed increase in each step, and even use a negative number to slow the particle down (the speed will never become smaller than 0).":"{}speed{}：设置粒子类型的速度属性。您可以指定最小和最大速度，并在创建粒子时选择给定边界之间的随机值。您可以在每一步中指示速度增加，甚至可以使用负数来减慢粒子(速度永远不会小于0)。",'{}{}NOTE{}{}&nbsp;The layer name supplied must be a valid layer in the room where the system will be used, otherwise no particles will be visible.&nbsp;Also note that we set the&nbsp;{}{}persistent{}{} flag (both in code and in {}GML Visual{}) to {}false{}. A persistent particle system is one that will "persist" across rooms without the need to destroy and re-create it for each room. However, to keep things simple for this guide, we\'ll not be using persistence.':"{}{}注意{}{} 提供的图层名称必须是使用系统的房间中的有效图层，否则将看不到任何粒子。 另请注意，我们将 {}{}persistent{}{} 标志（在代码和 {}GML Visual{} 中）设置为 {}false{}。 持久性粒子系统是一种可以在各个房间“持久”的粒子系统，无需为每个房间销毁并重新创建它。 然而，为了使本指南简单起见，我们不会使用持久性。","{}{}NOTE{}{}&nbsp;There are other minor particle properties too which we don't cover here, just to keep things as simple as possible to start with. See the appropriate pages for full details of particle properties.":"{}{}注意{}{}还有其他一些次要的粒子性质，我们在这里不涉及，只是为了让事情尽可能简单地开始。请参阅相应的页面了解粒子性质的完整细节。","{}{}NOTE{}{}&nbsp;Using&nbsp;{}GML Visual{} we also tick the {}blend {}option. This enables {}additive blending{} for the particle, which we'll discuss a bit further down.":"{}{}注意{}{}使用{}GML Visual{}，我们还勾选{}混合{}选项。这将为粒子启用{}加法混合{}，我们将在下面进一步讨论。","{}{}TIP{}{}&nbsp;If you prefer a more visual approach to creating particles and don't need the extensive functionality that&nbsp;{}GML Code{}&nbsp;offers,&nbsp;you can also create a&nbsp;{}{}Particle System Asset{}{}&nbsp;using&nbsp;{}The Particle System Editor{}. Additionally, you can generate the&nbsp;{}GML Code{}&nbsp;for it using the editor's {}Copy GML to Clipboard{} {}.":"{}{}提示{}{}如果您更喜欢采用更直观的方法来创建粒子，并且不需要 {}GML 代码{}提供的广泛功能，您还可以创建{}{}粒子系统资源{} {} 使用{}粒子系统编辑器{}。 此外，您还可以使用编辑器的{14}将 GML 复制到剪贴板{15}{16}为其生成 {}GML 代码{}。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="..",gTopicId="7.0_7"</script><script type="text/javascript" src="../template/scripts/rh.min.js"></script><script type="text/javascript" src="../template/scripts/common.min.js"></script><script type="text/javascript" src="../template/scripts/topic.min.js"></script><script type="text/javascript" src="../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Guide To Using Particles</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../assets/css/default.css" type="text/css"><script src="../assets/scripts/main_script.js" type="module">//<![CDATA[
    <
    meta name = "rh-authors"
    content = "Mark Alexander" / >
      <
      meta name = "topic-comment"
    content = "Page that explains how to set up and use particles" / >
      <
      meta name = "rh-index-keywords"
    content = "Guide To Using Particles" / >
      <
      meta name = "search-keywords"
    content = "particles,particle guide,particle setup" / >
    //]]></script><meta name="brsnext" value="Additional_Information/Guide_To_Using_Shaders.htm"><meta name="brsprev" value="Additional_Information/Guide_To_Using_Buffers.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Guide To Using Particles"><span>Guide To Using Particles</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Guide To Using Particles</span></h1><p>This guide is for those of you who want to understand how to use and create <strong>particles</strong>&nbsp;in GML. This page will cover both the <a href="../GameMaker_Language/GML_Reference/Drawing/Particles/Particles.htm"><span data-keyref="GML_Code">GML Code</span>&nbsp;functions</a>&nbsp;and <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Particles/Particle_Actions.htm"><span data-keyref="GML_Visual">GML Visual</span>&nbsp;actions</a>&nbsp;for particles, so if you've never used particles before, we hope that this guide can get you started as they are very useful and quite fun to make.</p><div data-conref="../assets/snippets/Note_tip_use_particle_system_editor.hts"><p class="note"><span data-conref="../assets/snippets/Tag_tip.hts"><span class="tip">TIP</span></span>&nbsp;If you prefer a more visual approach to creating particles and don't need the extensive functionality that&nbsp;<span data-keyref="GML_Code">GML Code</span>&nbsp;offers,&nbsp;you can also create a&nbsp;<span data-keyref="Type_Asset_ParticleSystem"><a target="_blank" href="../The_Asset_Editors/Particle_Systems.htm">Particle System Asset</a></span>&nbsp;using&nbsp;<a href="../The_Asset_Editors/Particle_Systems.htm">The Particle System Editor</a>. Additionally, you can generate the&nbsp;<span data-keyref="GML_Code">GML Code</span>&nbsp;for it using the editor's <strong>Copy GML to Clipboard</strong> <img class="icon" src="../assets/Images/Icons/Icon_GML_To_Clipboard.png" title="">.</p></div><p>Before going any further, we should probably explain what a particle actually is... Basically, a<a id="particle"></a> particle is a graphic resource that has certain properties which are defined by a <strong>particle system</strong>. These properties cannot be manipulated directly for <em>individual</em> particles, but are changed collectively through the code or actions that are used to define the system that it belongs to. They are very useful for creating beautiful and flashy effects - or subtle and discreet ones -&nbsp;in a game without the CPU overhead that using instances has.</p><p>We have mentioned particle systems, so let's explain what that is before continuing. Think of a<a id="particle_system"></a> particle system like a container that you will use to hold your particles ready for use. You can use code or actions to define the visual aspect of the particles, and then they are placed in the "container" (the particle system) so that you can take it out and use it whenever and wherever you need it later.</p><p>Before setting up a system and creating particles, it's important to know a few things... First is that most of a particle systems code is <strong>only ever called once in the game</strong>, usually in some type of controller object in the first room or level - this is not always the case, but for the sake of simplicity, we'll be using this scenario for the following brief guide as it's the most common way to use particles. You do this because a particle system, once created, stays in memory and is ready to be used at any time, so if you create it more than once it can quickly increase the memory usage and cause serious lag, and even has the potential of crashing the game. For the sake of simplicity in this guide, you&nbsp;will make a <a href="../GameMaker_Language/GML_Overview/Variables/Global_Variables.htm">global</a><strong>&nbsp;</strong>particle system that can be used by any instance in the game at any time.</p><p>&nbsp;</p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"><span data-open-text="true" data-skip-index="true">Creating A Particle System</span><span data-close-text="true">Creating A Particle System</span></a></p><div class="droptext" data-targetname="drop-down"><p class="dropspot">To start with you need to define the particle system and give it a name so that you can use it. As this is going to be a global system that any object can use you would do this&nbsp;in a controller object or an initialisation function run at the start of the game. The&nbsp;<span data-keyref="GML_Code">GML Code</span> would look like this:</p><p class="code">global.P_System = part_system_create_layer("Instance_Layer", false);</p><p class="dropspot">And using <span data-keyref="GML_Visual">GML Visual</span>:</p><p class="dropspot"><img alt="Create Particle System" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_DnD_CreateSystem.png"></p><p class="note"><span data-conref="../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;The layer name supplied must be a valid layer in the room where the system will be used, otherwise no particles will be visible.&nbsp;Also note that we set the&nbsp;<span class="inline2"><a href="../GameMaker_Language/GML_Reference/Asset_Management/Instances/Instance_Variables/persistent.htm">persistent</a></span> flag (both in code and in <span data-keyref="GML_Visual">GML Visual</span>) to <span class="inline2">false</span>. A persistent particle system is one that will "persist" across rooms without the need to destroy and re-create it for each room. However, to keep things simple for this guide, we'll not be using persistence.</p><p class="dropspot">So that's the system created, but what about the particles? We have to define them too or the system is useless and does nothing.</p><p class="dropspot">If you already have a&nbsp;<span data-keyref="Type_Asset_ParticleSystem"><a target="_blank" href="../The_Asset_Editors/Particle_Systems.htm">Particle System Asset</a></span>, you can create it using the above function/action by passing the asset into the <span class="inline2">partsys</span>/"System" argument.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span data-open-text="true" data-skip-index="true">Defining A Particle Type</span><span data-close-text="true">Defining A Particle Type</span></a></p><div class="droptext" data-targetname="drop-down1"><p class="dropspot">To use a particle in a system you have to first define its general properties. These are like object properties, but they only apply in a <em>general</em> way to individual particles. What this means is that if you give the particles a minimum movement speed of 1 and a maximum movement speed of 2, any particle created by the system will have a random speed between 1 and 2 pixels per step, and that overall they will have an average speed of 1.5. You should name and add your first particle to the system using the following GML in the same object that you used to create the system:</p><p class="code">global.Particle1 = part_type_create();</p><p class="dropspot">And for those of you that use <span data-keyref="GML_Visual">GML Visual</span>:</p><p class="dropspot"><img alt="Create Particle Type" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_DnD_Create_Type.png"></p><p class="note"><span data-conref="../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;Using&nbsp;<span data-keyref="GML_Visual">GML Visual</span> we also tick the <strong>blend</strong> option. This enables <strong>additive blending</strong> for the particle, which we'll discuss a bit further down.</p><p class="dropspot">You&nbsp;now have a system and a particle to put in it, but you're not ready yet to create your outstanding effects! You&nbsp;still have to define the properties of the particle, ie: how it looks - its speed, its rotation, its alpha, etc. There are a lot of details that can be used to define a particle effect, so below is an overview of the most important settings and then a snippet of code and&nbsp;<span data-keyref="GML_Visual">GML Visual</span> that uses all of them:</p><ul class="dropspotlist"><li class="dropspot"><strong>shape</strong>:&nbsp;The shape of the particle is the built in sprite that it will use, with the default being the constant <span class="inline">pt_shape_pixel</span>. There is also a function to add a custom particle if required -&nbsp;<span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/Particles/Particle_Types/part_type_sprite.htm">part_type_sprite</a></span>&nbsp;- or the action <a href="../Drag_And_Drop/Drag_And_Drop_Reference/Particles/Set_Particle_Sprite.htm">Set Particle Sprite</a>.</li><li class="dropspot"><strong>size</strong>:&nbsp;Sets the size parameters for the particle type. You specify the minimum starting size, the maximum starting size, and the size increase in each step (use a negative number for a decrease in size). This is a scalar value that will modify the base image x/y scale equally.</li><li class="dropspot"><strong>colour</strong>:&nbsp;Sets the colour for the particle if a single colour is used. If two or three colours are supplied this will be the colour blend, blending from one to the other over its lifetime.</li><li class="dropspot"><strong>alpha</strong>:&nbsp;Sets the alpha value for the particle between a value of 0 and 1. If a single value is passed in this will be the alpha of the particle, if two or three values are passed in then the alpha will blend between these over the lifetime of the particle.</li><li class="dropspot"><strong>speed</strong>:&nbsp;Sets the speed properties for the particle type. You specify a minimum and maximum speed and a random value between the given bounds is chosen when the particle is created. You can indicate a speed increase in each step, and even use a negative number to slow the particle down (the speed will never become smaller than 0).</li><li class="dropspot"><strong>direction</strong>:&nbsp;Sets the direction properties for the particle type. Again you specify a range of directions (in counterclockwise degrees - 0 indicates a motion to the right, 90 indicates a motion upwards, etc...). For example, to let the particle move in a random direction you'd choose a minimum of 0 and a maximum of 360 as values. You can specify an increase in direction for each step too (can also be negative).</li><li class="dropspot"><strong>orientation</strong>:&nbsp;Sets the orientation angle properties for the particle type. You specify the minimum angle, the maximum angle, and the increase in each step. You can also indicate whether the given angle should be relative to the current direction of motion or absolute, e.g: by setting all values to 0 but relative to true, the particle orientation will precisely follow the path of the particle.</li><li class="dropspot"><strong>blending</strong>:&nbsp;Sets whether to use <strong>additive</strong> blending or <strong>normal</strong> blending for the particle type. This is set in a function when using&nbsp;<span data-keyref="GML_Code">GML Code</span> and as part of the particle initialisation when using <span data-keyref="GML_Visual">GML Visual</span>. Additive blending means that the particles will use the <span class="inline2">bm_add</span> blend mode, giving them a "glowing" look where they overlap, and also blending them with anything drawn underneath (sprites, backgrounds, tiles, etc.) - very useful for fire and magic effects (for example), but best left off for something like smoke. Experiment to see the differences! Note that enabling this will break the texture batching when particles are created, and so more batches will be required per step to draw them - something to consider as it may affect performance, especially on mobile.</li><li class="dropspot"><strong>life</strong>:&nbsp;Sets the lifetime bounds, in steps (game frames) for the particle type. Like previous settings, this has a minimum and maximum value and particles will last a random number of steps within these values. So, a lifetime of 30 min and 30 max will have the particle existing for exactly 30 steps, but a lifetime of 20 min and 60 max will have each particle exists for a random number of steps between 20 and 60.</li></ul><p class="dropspot">Now, before we present you the code for defining the particle, let's just talk about "<strong>wiggle</strong>" for a moment... Believe it or not, "wiggle" is a particle property and can be set for many of the above settings individually. When you see "wiggle" as an argument for a particle function or action, it means that if you place a number between 1 and 20 the particle will "wiggle" or fluctuate between the min and max values for the property, with 1 being a slow wiggle and 20 being very fast. So a particle speed minimum of 2 and maximum of 5 with a wiggle of 20 will oscillate very quickly between the min/max speeds for the lifetime of each particle created.</p><p class="note"><span data-conref="../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;There are other minor particle properties too which we don't cover here, just to keep things as simple as possible to start with. See the appropriate pages for full details of particle properties.</p><p class="dropspot">Let's look at some code that defines a particle now:</p><p class="code">// This defines the particle's shape<br>part_type_shape(global.Particle1,pt_shape_pixel);<br><br>// This is for the size<br>part_type_size(global.Particle1,1,1,0,2);<br><br>// This sets its colour. There are three different codes for this<br>part_type_color1(global.Particle1,c_white);<br><br>// This is its alpha. There are three different codes for this<br>part_type_alpha1(global.Particle1,1);<br><br>// The particles speed<br>part_type_speed(global.Particle1,0.50,2,-0.10,0);<br><br>// The direction<br>part_type_direction(global.Particle1,0,359,0,20);<br><br>// This changes the rotation of the particle<br>part_type_orientation(global.Particle1,0,0,0,0,true);<br><br>// This is the blend mode, either additive or normal<br>part_type_blend(global.Particle1,1);<br><br>// This is its lifespan in steps<br>part_type_life(global.Particle1,5,30);</p><p class="dropspot">To create this same particle definition in&nbsp;<span data-keyref="GML_Visual">GML Visual</span> we'd need these actions:</p><p class="dropspot"><img alt="Define Particle Type" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_DnD_Define_Particle.png">So that's it! We have now defined our particles and they are ready to be used.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span data-open-text="true" data-skip-index="true">Creating Particles Directly In-Game</span><span data-close-text="true">Creating Particles Directly In-Game</span></a></p><div class="droptext" data-targetname="drop-down2"><p class="dropspot">There are a couple of ways to create particles, and each has its pros and cons. You can use <strong>emitters</strong> to <strong>burst</strong> or <strong>stream</strong> particles, or you can create particles <strong>directly</strong> at a point. Which one you use really depends on what you are trying to achieve and the effect you are wanting to create, but we'll start with the easiest of the two, which is creating particles directly. In GML we'd use the following function:</p><p class="code">part_particles_create(global.P_System, x, y, global.Particle1, 10);</p><p class="dropspot">and in&nbsp;<span data-keyref="GML_Visual">GML Visual</span> it'd be:</p><p class="dropspot"><img alt="Create Particles At A Position" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_DnD_Burst.png">That single code/action above will create 10 particles at the given x/y coordinates of type "Particle1" from our global system. Simple! The great thing about that line of code/action is that it can be used anywhere without any fuss. For example if you place it in the <strong>Global Left Pressed</strong> event for the mouse in an object and change x/y values for the mouse_x/y position, it will create particles at the mouse position every time you press the button. Or if you have a rocket, then you could place this in the step event and have smoke particles coming every step (although 1 or 2 would probably be better than 10!). You can even have it create particles over an area by changing the x/y coordinates randomly, for example:</p><p class="code">repeat(50)<br>{<br>var xx = x + 20 - random(40);<br>var yy = y + 20 - random(40);<br>part_particles_create(global.P_System, xx, yy, global.Particle1, 1);<br>}</p><p class="dropspot"><img alt="Create Particles Over A Random Area" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_DnD_Create_Particles.png">The above code will create 50 particles at a random position within a 40px square area.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#"><span data-open-text="true" data-skip-index="true">Creating Particles With Emitters</span><span data-close-text="true">Creating Particles With Emitters</span></a></p><div class="droptext" data-targetname="drop-down3"><p class="dropspot">Since we've explained the easy way to create particles, let's now go the slightly more complex way, which is to use <strong>emitters</strong>. Emitters are another part of the particle system that has to be defined before being used, so we'll make a global emitter the same as we did for the system and the particles. We also have to decide whether to have a static (non-moving) emitter or not and whether we are going to <strong>burst</strong> or <strong>stream</strong> the particles, as well as decide over what area and what kind of distribution we are going to have the emitter use.</p><p class="dropspot">What does all that mean? Well, a <strong>static</strong> emitter is one that you can define once and forget about as it will not be moving anywhere for the duration of the game, ie: think of a log fire - it doesn't move, it just emits flames and so is static, but a fireball would require a <strong>dynamic</strong> emitter and will move across the screen. As for bursting or streaming, a burst is a one off explosion of particles, whereas a stream is just that - a constant stream of particles every step. For area and distribution, with emitters you can define an area for emitting particles (which can be a rectangle, ellipse, diamond or line) as well as the distribution curve (gaussian, inverse gaussian, or linear).</p><p class="dropspot">The following images illustrate the different types of area shape available for emitters:</p><p class="dropspot">&nbsp;</p><center><img alt="Rectangle Emitter" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_Rectangular.gif"> <img alt="Line Emitter" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_Line.gif"></center><center><img alt="Ellipse Emitter" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_Ellipse.gif">&nbsp;<img alt="Diamond Emitter" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_Diamond.gif"></center><p class="dropspot"><br>And the distribution curves (linear, gaussian, and inverse gaussian) are illustrated here:</p><p><img alt="Particle distribution" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_Distribution.png"></p><p class="dropspot">Below is an example of the code/actions required to define two emitters, which would normally go in the <strong>Create Event</strong> of a controller object, just after defining the particle system. One will be static and stream particles over the area of the whole room, while the other will be dynamic and follow the mouse and burst every 30 steps from a small ellipse:</p><p>&nbsp;</p><p class="code">global.Particle1_Emitter1 = part_emitter_create(global.P_System);<br>global.Particle1_Emitter2 = part_emitter_create(global.P_System);<br><br>// Set up the area that will emit particles<br>part_emitter_region(global.P_System, global.Particle1_Emitter1, 0, room_width, 0, room_height, ps_shape_rectangle, ps_distr_linear);<br>part_emitter_region(global.P_System, global.Particle1_Emitter2, mouse_x-10, mouse_x+10, mouse_y-10, mouse_y+10, ps_shape_ellipse, ps_distr_gaussian);<br><br>// Set the first to stream 10 particles every step<br>part_emitter_stream(global.P_System, global.Particle1_Emitter1, global.Particle1, 10);<br><br>// This can now be forgotten as it will function until told to stop...<br>// Set the alarm[0] event to burst the emitter2 particles...<br>alarm[0] = 30;</p><p class="dropspot"><img alt="Define Particle Emitters" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_DnD_Create_Emitter.png">So, here we are creating two particle emitters that are assigned to the particle system we created at the start. The functions/actions to create these emitters permit us to define an area in the room over which they will emit particles, as well as give the particle type to emit, and the shape and distribution to use within the defined area. The functions/actions will return a numeric value, which is the emitter ID value, and we store this in a variable so that we can use further emitter functions to target those emitters.</p><p class="dropspot">Now we have code/<span data-keyref="GML_Visual">GML Visual</span> to stream particles (these particles will be emitted every game step without us having to anything else), but we also want to add an <strong>A</strong><strong>larm[0]</strong>&nbsp;<strong>Event</strong> to burst particles at specific intervals:</p><p class="code">part_emitter_region(global.P_System, global.Particle1_Emitter2, mouse_x - 10, mouse_x + 10, mouse_y - 10, mouse_y + 10, ps_shape_ellipse, ps_distr_gaussian);<br>part_emitter_burst(global.P_System, global.Particle1_Emitter2, global.Particle1, 30);<br>alarm[0] = 30;</p><p class="dropspot"><img alt="Burst Particles From Emitter" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_DnD_Set_Emitter.png">A particle burst is simply a one-off explosion of particles from the emitter, rather than a constant stream of them every game step.</p><p class="dropspot">But what if you want several objects to emit particles? A global emitter can only be in one place at a time, so you would need to create <em>local</em> emitters in each object. These emitters will still use the global particle system and any particles that are within it, but they can be different shapes and sizes and move with the object, making them ideal for rockets or bullets or things. The code you would use is exactly the same as above, but without the "global" prefix before the emitter names.</p><p class="dropspot">That's the creation of particles dealt with but there is one more thing that's very important... Cleaning up when you are finished with them.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#"><span data-open-text="true" data-skip-index="true">Cleaning Up</span><span data-close-text="true">Cleaning Up</span></a></p><div class="droptext" data-targetname="drop-down4"><p class="dropspot">As mentioned at the start, once created, a particle system (and its particles, emitters, etc.) are stored in memory for instant use. Great, but what happens when you restart the game? Or if your player dies and starts the room again? Well, if you don't manage the game right you get a <strong>memory leak</strong>. This is when something has been created and uses up memory, but has been "de-referenced" meaning that&nbsp;<span data-keyref="GameMaker Name">GameMaker</span> no longer has access to it. This kind of thing will slowly eat up memory and cause lag in your game or even block the computer causing your game to crash, and it is a pretty common problem with first time users of particle systems.</p><p class="dropspot">How do you avoid this? Well, <span data-keyref="GameMaker Name">GameMaker</span> has&nbsp;<span data-keyref="GML_Code">GML Code</span> functions and&nbsp;<span data-keyref="GML_Visual">GML Visual</span> actions to delete particle systems and their emitters and particles from memory when not in use, and with a little bit of planning when using the following code/actions, you can easily prevent this potential problem.</p><p class="dropspot">The first thing you have to do is decide where you are going to create the system and how you will use it. You could create a global system in the <strong>Game Start Event</strong> of an object that is in your first room (like a menu or title screen), but this means that if you restart the game using the&nbsp;<span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/General_Game_Control/game_restart.htm">game_restart</a></span> function, it will be recreated and cause a memory leak. Or you could create a local system in an instance in any room, but again, if you leave the room then the system will be inaccessible and cause a memory leak. To avoid this you would need to have something like this in the <a href="../The_Asset_Editors/Object_Properties/Other_Events.htm"><strong>Game End Event</strong></a> or the <a href="../The_Asset_Editors/Object_Properties/Object_Events.htm"><strong>Clean Up Event</strong></a> of your object:</p><p class="code">part_type_destroy(global.Particle1);<br>part_emitter_destroy(global.P_System, global.Particle1_Emitter);<br>part_emitter_destroy(global.P_System, global.Particle2_Emitter);<br>part_system_destroy(global.P_System);</p><p class="dropspot"><img alt="Clean Up Particle System" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/Particles_DnD_CleanUp.png">This will remove the defined particles, emitters, and then the system from memory ready for you to restart the game or change room. Just remember that after thinking about where would be the most suitable place to create the system, think about where would be the most suitable place to destroy the system too!</p><p class="dropspot">&nbsp;</p></div><p>&nbsp;</p><p>Now you know the basics about particles, particle systems and emitters, so you can now add them into your game! But before rushing off and adding particle effects to everything, please note that while particles are less CPU hungry than instances, they are not the solution to everything as they will cause lag if you have thousands of them at a time. The best thing to do is experiment and use them carefully to "flesh out" visually a game and give it a bit more eye-candy without over doing it.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="Additional_Information.htm">Additional Information</a></div><div style="float:right">Next:&nbsp;<a href="Guide_To_Using_Shaders.htm">Guide To Using Shaders</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>