<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../assets/import/layer/layer.js"></script><script type="text/javascript" src="../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let n;n=a?e.attr(a):e.html();let l=t[removeHtml(n)];if(null!=l&&l.length){t=retHtml(n);let o=0;t&&t.forEach(function(e,t){var a=l.replace("{"+o+"}",e);l=a===l?l.replace("{}",e):a,o++}),a?e.attr(a,l):e.html(l)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Above&nbsp;we have talked about the function {}{}gpu_set_blendmode(){}{}, but now we are going to look at {}{}gpu_set_blendmode_ext(){}{}. This is (as the name implies) an extended function to set {}custom {}blend modes, but how does this work? Let's just have a look at the dry technical answer first before we go any further:":"上面我们已经讨论了函数 {}{}gpu_set_blendmode（）{}{}，但现在我们将看看 {}{}gpu_set_blendmode_ext（）{}{}。顾名思义，这是一个用于设置 {}custom {}blend 模式的扩展函数，但这是如何工作的呢？在我们进一步讨论之前，让我们先看一下枯燥的技术答案：","And the destination would be like this:":"目的地应该是这样的：","As you can see, we multiply the destination values by 0, which gives them a value of 0 too, meaning that the source colours are unchanged, so our final colour value is&nbsp;{}(128, 255, 64, 255){}. You can see how the inclusion of alpha affects this value too:":"如您所见，我们将目标值乘以 0，这也使它们的值也为 0，这意味着源颜色保持不变，因此我们的最终颜色值为 {}(128, 255, 64, 255){}。 您还可以看到 alpha 的包含如何影响该值：","BASIC BLEND MODES":"基本混合模式","Before we actually draw something using this blend mode, let's have a look at how it should look in Photoshop:":"在我们实际使用这种混合模式绘制东西之前，让我们看看它在Photoshop中应该是什么样子：","Blend modes basically tell your game to draw certain things blended with whatever else is already drawn beforehand. Everything you draw to the screen is made up of four component parts - red, green, blue and alpha - and by default they are drawn to the screen using the blend mode {}bm_normal{}. This blend mode draws all pixels with their colour and alpha values essentially unchanged (although, later in this section you'll see that this isn't {}quite{} true...), but {}GameMaker{} has a number of built in blend modes that can be set to change this behaviour.":"混合模式基本上告诉你的游戏绘制某些东西与任何其他已经事先绘制的东西混合。你绘制到屏幕上的所有东西都由四个组成部分组成-红色，绿色，蓝色和alpha -默认情况下，它们是使用混合模式{}bm_normal{}绘制到屏幕上的。这种混合模式绘制的所有像素的颜色和alpha值基本不变(虽然，稍后在本节中你会看到，这不是{}完全{}正确.)，但{}GameMaker{}有许多内置的混合模式，可以设置来改变这种行为。","CREATING YOUR OWN BLEND MODES":"创建您自己的混合模式","Even if the alpha of the surface is 0, {}{}the colour components are still there and exist and will influence in all blending operations{}{}. So drawing to a zero alpha cleared surface that has been cleared using the colour red (for example) will blend the source colours with the destination colours and give different effects to that which you may think. The above image was created on a surface cleared to black over a black background, but if we clear the surface to red, we get this instead:":"即使表面的 Alpha 为 0，{}{}颜色分量仍然存在并且会影响所有混合操作{}{}。 因此，绘制到已使用红色（例如）清除的零 alpha 清除表面会将源颜色与目标颜色混合，并给出您可能认为的不同效果。 上面的图像是在黑色背景上清除为黑色的表面上创建的，但是如果我们将表面清除为红色，我们会得到以下结果：","Extended Blend Modes":"扩展混合模式","Following the same rule, if you wanted to simply reduce the brightness of a background by 50% then you would have a colour that is 50% red, 50% green and 50% blue, ie: RGB (128, 128, 128). This blend mode is mainly used for drawing shadows, or creating interesting fade out effects.":"按照同样的规则，如果你想简单地将背景的亮度降低50%，那么你就会有一个50%红色，50%绿色和50%蓝色的颜色，即：RGB(128，128，128)。这种混合模式主要用于绘制阴影，或创建有趣的淡出效果。","Guide To Using Blendmodes":"Blendmodes使用指南","Hopefully you can see clearly now what the blend mode factors do, and how combining them can change what is drawn to create some interesting effects. We will now look at a practical example of how to combine these factors to create your own custom blend modes.":"希望您现在可以清楚地了解混合模式因素的作用，以及将它们组合起来如何改变绘制的内容以创建一些有趣的效果。 现在，我们将看一个实际示例，了解如何结合这些因素来创建您自己的自定义混合模式。","If you then proceed to draw another circle in the existing circle, also with an alpha of 0.5, then the alpha outside the circles would be 0, in between the circles 0.25, and in the smaller circle it would be 0.375:":"如果你在现有的圆上再画一个alpha值为0.5的圆，那么在圆外的alpha值为0，在圆间的alpha值为0.25，在较小的圆内的alpha值为0.375：","If you were to continue to draw a number of 0.5 alpha circles to a surface with 0 alpha, and then draw this surface to the room, you would be able to clearly see this:":"如果你继续在一个alpha值为0的曲面上画一些alpha值为0.5的圆，然后把这个曲面画到房间上，你可以清楚地看到：","If you've been using {}GameMaker{} for any length of time, you will almost certainly have come across {}blend modes{}, and probably even used them in your games. Blend modes are a great way to change how something is drawn to give interesting and specific graphical effects, but do you know how they work and how do you use them? This is a subject that can confuse people and so in this section we hope to dispel some of the mystery surrounding blend modes and enable you to use them to their fullest extent in your games.":"如果您已经使用{}GameMaker{}一段时间，您几乎肯定会遇到{}混合模式{}，甚至可能在游戏中使用它们。混合模式是更改绘制方式以提供给予有趣和特定图形效果的好方法，但您知道它们的工作原理以及如何使用它们吗？这是一个可能会让人们感到困惑的主题，因此在本节中，我们希望消除一些围绕混合模式的神秘感，并使您能够在游戏中最大限度地使用它们。","It's worth mentioning that with {}GameMaker{} you can take this one step further using the function {}{}gpu_set_blendmode_ext_sepalpha(){}{}. This permits you to separate out the alpha component of the different blend mode factors and use them individually to create even more possible combinations. We won't cover this function here as it's explained in depth already in the manual, but it's worth mentioning just so you know it's available for use.":"值得一提的是，通过 {}GameMaker{}，您可以使用函数 {}{}gpu_set_blendmode_ext_sepalpha(){}{} 更进一步。 这允许您分离出不同混合模式因子的 Alpha 分量，并单独使用它们来创建更多可能的组合。 我们不会在这里介绍这个功能，因为它已经在手册中进行了深入解释，但值得一提，以便您知道它可以使用。","Now you know how setting blend modes works and have seen an example of it being used for everyday drawing, let's look at something abit more complex...":"现在你知道了如何设置混合模式的工作原理，并看到了一个例子，它被用于日常绘图，让我们看看一些更复杂的东西。","Now you know the very basics behind using a blend mode in {}GameMaker{}. It takes the RGB and alpha values for the source image (what is being drawn) and it then blends these with the RGB and alpha values of the destination (what is being drawn too). This blending is done by multiplying the individual components for each pixel colour and alpha by different amounts, depending on the effects that we wish to achieve. With this knowledge, you can start to use blend modes in your games to get glowing lasers, realistic shadows, or saturated transition effects, but there is still more to be learned here! Below&nbsp;we look at the {}extended blend modes{}, as well as explore a bit of the maths behind them, so that you can create your own blending effects like multiply or overlay.":"现在你知道了在GameMaker中使用混合模式的基本原理，它为源图像获取RGB和alpha值(正在绘制的内容)，然后将其与目标的RGB和alpha值混合(也正在绘制)。这种混合是通过将每个像素颜色和alpha的各个分量乘以不同的量来完成的，这取决于我们希望实现的效果。有了这些知识，你可以开始在游戏中使用混合模式来获得发光的激光，逼真的阴影或饱和的过渡效果，但这里还有更多的东西要学！下面我们来看看{}扩展混合模式{}，以及探索它们背后的一些数学，以便您可以创建自己的混合效果，如相乘或叠加。","Now, while that text is correct and explains what blend modes do, it's not really intuitive... so let's go into a bit more detail and explain what this is all about.":"现在，虽然文本是正确的，并解释了混合模式的作用，但它并不直观......所以让我们更详细地解释一下这是怎么回事。",OVERVIEW:"概述","One final thing is worth noting about blend modes, and that is how they affect the {}alpha {}component of a colour. When simply drawing to the {}application surface{} or the {}display buffer{}, you don't really need to take into consideration the destination alpha value as it will {}always {}be one. However surfaces that you make yourself are different, since you can clear a surface to have any alpha value from zero to one that you wish. This leads to some interesting effects that are contrary to what most people would expect.":"关于混合模式，最后一件事值得注意，那就是它们如何影响颜色的 {}Alpha{} 分量。 当仅绘制到{}应用程序表面{}或{}显示缓冲区{}时，您实际上不需要考虑目标 Alpha 值，因为它{}始终{}为 1。 然而，您自己制作的表面是不同的，因为您可以清除表面以使其具有您希望的从零到一的任何 alpha 值。 这会导致一些有趣的效果，与大多数人的预期相反。","One of the problems people have with blend modes is visualising the results, so to show the maths behind them, we'll use this blend mode as our test subject since it's the blend mode that everyone uses the most and we know exactly what to expect from it. Imagine we are drawing a rectangle with the colour (128, 255, 64, 255) over a background with the colour (64, 128, 255, 255):":"人们使用混合模式的一个问题是可视化结果，所以为了展示它们背后的数学原理，我们将使用这种混合模式作为我们的测试主题，因为它是每个人使用最多的混合模式，我们确切地知道它会带来什么。(128，255，64，255)的颜色的背景上：","Q(+y?>^":"","SURFACES AND ALPHA":"曲面和阿尔法","Say you have surface with every pixel at alpha 0, then you draw a circle on it with alpha 0.5 using the {}bm_normal{} blend mode. The entire surface is still going to be alpha 0, but in the circle the alpha will actually be 0.25, since:":"假设你有一个表面，每个像素的alpha都是0，然后你用{}bm_normal{}混合模式在上面画一个alpha为0.5的圆。整个表面仍然是alpha 0，但是在圆中alpha实际上是0.25，因为：","So when we draw something on the screen, our graphics processor is actually doing the following for every single pixel:":"所以当我们在屏幕上画东西时，我们的图形处理器实际上对每个像素都做了以下操作：","That code draws the instance sprite using an {}additive {}blend mode. The additive blend mode is set using one of the available GML constants, of which there are four for basic modes:":"该代码使用{}添加{}混合模式绘制实例精灵。添加混合模式使用可用的GML常量之一设置，其中有四个用于基本模式：",'The blend factor {}bm_zero{} effectively removes the destination colour from the equation (as zero times anything is zero), so we are left with the source colour multiplied by the blend factor of the destination colour, hence the name "multiply" for the mode. To use this in {}GameMaker{}, you would simply have something like this in your {}Draw Event{}:':'混合因子{}bm_zero{}有效地将目标颜色从等式中移除(因为零乘以任何东西都是零)，所以我们剩下的是源颜色乘以目标颜色的混合因子，因此该模式的名称为"乘"。要在{}GameMaker{}中使用此模式，您只需在{}Draw Event{}中设置如下内容：','The four "basic" blend modes that {}GameMaker{} has are actually composites of two of these blend factors.':'{}GameMaker{}拥有的四种"基本"混合模式实际上是其中两种混合因子的组合。',"The function {}gpu_set_blendmode_ext{}{}(src, dest){} indicates what blend mode to use for both the source and destination colour. The new colour is some factor times the source and another factor times the destination. These factors are set with this function. To understand this, the source and destination both have a red, green, blue, and alpha component. So the {}source {}is ({}Rs, Gs, Bs, As{}) and the {}destination {}is ({}Rd, Gd, Bd, Ad{}). All values are considered to lie between 0 and 1.":"函数 {}gpu_set_blendmode_ext{}{}（src， dest）{} 指示用于源颜色和目标颜色的混合模式。新颜色是某个因素乘以来源，另一个因素乘以目的地。这些因素是用这个函数设置的。为了理解这一点，源和目标都具有红色、绿色、蓝色和 alpha 分量。所以 {}source {}is （{}Rs， Gs， Bs， As{}） 和 {}destination {}is （{}Rd， Gd， Bd， Ad{}）。所有值都被认为介于 0 和 1 之间。","The next image was taken from a test project in GameMaker using this exact code:":"下一张图片是使用以下代码从GameMaker的测试项目中拍摄的：","The {}blend factors{} mentioned above are defined in {}GameMaker{} by a number of GML constants, and each one represents a factor by which the source or destination R, G, B and A values should be multiplied by. The factors available are:":"上述{}混合因子{}在{}GameMaker{}中由多个GML常量定义，每个常量代表源或目标R、G、B和A值应乘以的因子。可用因子包括：","This blend mode adds the colours of the source and destination pixels together (but does not affect the alpha values). For example, if your background image is a solid colour with an RGB value of (100,15,70), and then you draw a rectangle with an RGB of (120,25,30), then (using bm_add) the fina RGB values for each pixel of the rectangle would be (220,40,100). Note that colour values can't go over 255 (or under 0), so anything that adds up to more than that will be clamped to 255.":"此混合模式将源像素和目标像素的颜色添加在一起(但不影响alpha值)。例如，如果背景图像是RGB值为(100，15，70)，然后绘制一个RGB为(120，25，30)，然后(使用bm_add)矩形的每个像素的最终RGB值将为(220，40，100).注意颜色值不能超过255(或小于0)，所以任何加起来超过255的值都将被箝位到255。","This blend mode is a bit different to the previous one, as it it works on a percentage basis rather than a direct value. This percentage is what will be subtracted from the destination colour (the colour of the pixel being drawn to). To explain this better, let's look at an example.":"这个混合模式与前一个有点不同，因为它是基于百分比而不是直接值。这个百分比是从目标颜色(正在绘制的像素的颜色)中减去的百分比。为了更好地解释这一点，让我们看一个例子。",'This blend mode is more complex to explain, but it basically multiplies the source colours by the source alpha, then adds them to the destination colour values multiplied by the inverse source colour values. The actual maths behind bm_max (and the other blend modes) we\'ll cover in part two of our article, but all you need to know is that the result will be a more "saturated" and brighter colour, without leading to the same pure white brilliance that using {}bm_add{} will cause.':'这种混合模式更难解释，但它基本上是将源颜色乘以源alpha，然后将它们添加到目标颜色值乘以逆源颜色值。bm_max背后的实际数学(以及其他混合模式)我们将在文章的第二部分介绍，但您需要知道的是，结果将是一个更"饱和"和更明亮的颜色，而不会导致使用{}BM_add{}将导致的相同的纯白色亮度。',"This gives a final pixel colour (96, 192, 159, 192), and will give an image like that shown below:":"这给出了最终的像素颜色（96、192、159、192），并将给出如下所示的图像：","Time to look at a practical example of how this comes together for drawing in {}GameMaker{}. For this, we are going to look at bm_normal, which is really:":"是时候看看一个实际的例子了，它是如何在{}GameMaker{}中进行绘图的。为此，我们将看看bm_normal，它实际上是：",'To illustrate this, we are going to look at drawing using the basic default {}bm_normal{}. Most people think that having a surface cleared to alpha 0, and then drawing something with an alpha of 0.5 will give a resulting alpha value 0.5 too... {}but this is not the case{} and is something that many people think is a "bug" in how {}GameMaker{} renders things. However, as you will see, it\'s not a bug at all!':'为了说明这一点，我们将使用基本的默认值{}bm_normal{}进行绘制。大多数人认为将表面清除为alpha 0，然后绘制alpha为0.5的东西将给予结果alpha值也为0.5.{}但事实并非如此{}，许多人认为这是{}GameMaker{}渲染事物的"错误"。然而，正如你所看到的，这根本不是一个bug！',"Using the different factors available, you can create your own blend modes to achieve blending options that are not available to you normally. In this example, we are going to create a {}multiply {}effect like that used in Photoshop. We can simulate this blend mode using two of our above mentioned blend mode factor constants like this:":"使用不同的可用因子，您可以创建自己的混合模式，以实现通常不可用的混合选项。在这个例子中，我们将创建一个类似于Photoshop中使用的{}乘{}效果。我们可以使用上面提到的两个混合模式因子常量来模拟这种混合模式，如下所示：","We have seen already how {}bm_normal{} looks - since that's what everything defaults to! - so let's continue on to look at the other three in a bit more detail...":"我们已经看到了{}bm_normal{}的外观-因为这是所有默认设置！-所以让我们继续更详细地查看其他三个.","When we talk about the {}source {}we are talking about the colour and alpha values of the pixel that is being drawn, and when we talk about the {}destination {}we are talking about the colour and alpha values of the pixel that it is being drawn over. To keep things easier we can write out the source colour as it's components, like this:":"当我们谈论{}source{}时，我们谈论的是正在绘制的像素的颜色和alpha值，而当我们谈论{}destination{}时，我们谈论的是正在绘制的像素的颜色和alpha值。为了使事情更容易，我们可以将源颜色写为它的组件，如下所示：","When {}GameMaker{} goes to draw a pixel there's a {}source colour{} (the colour of the pixel you are going to draw) and a {}destination colour{} (the colour that's already in the pixel we're drawing to). When determining the new colour of the pixel, GameMaker will combine the source and destination colours according to the {}blend mode{}, as mentioned above. Each component of the colours is stored as a floating point value between 0 and 1, and the new colour is calculated by multiply each component of the source colour by some factor and by multiplying each component of destination colour by some other factor and then adding the results together component by component.":"当{}GameMaker{}去绘制一个像素时，有一个{}源颜色{}(要绘制的像素的颜色)和{}目标颜色{}(我们要绘制的像素中已有的颜色)。当确定像素的新颜色时，GameMaker将根据{}混合模式{}将源颜色和目标颜色联合收割机组合，颜色的每个分量被存储为0和1之间的浮点值，并且通过将源颜色的每个分量乘以某个因子并且通过将目的地颜色的每个分量乘以某个其它因子并且然后将结果加在一起分量，成分","{}(Rd, Gd, Bd, Ad){} = the RGB and Alpha of the colour you are going to draw on.":"{}(Rd，Gd，Bd，Ad){}=您要绘制的颜色的RGB和Alpha。","{}(Rs, Gs, Bs, As){} = the RGB and Alpha of the colour you are going to draw.":"{}(Rs，Gs，Bs，As){}=您要绘制的颜色的RGB和Alpha。","{}Can you spot the difference? Probably not! There will, however, be some deviation between the two due to differences between the render tools used, but it's almost exactly as you would expect. Note though that not all the blend modes used by art programs are available to you within {}GameMaker{} due to the fact some of them can actually force the colour values to go over 255 and so create special effects, but that doesn't mean you can't create passable imitations of these effects, or even brand new effects, using them.":"{}您看得出来差别吗？ 可能不会！ 然而，由于使用的渲染工具之间的差异，两者之间会存在一些偏差，但它几乎与您所期望的完全一样。 请注意，尽管并非艺术程序使用的所有混合模式都可以在 {}GameMaker{} 中使用，因为其中一些混合模式实际上可以强制颜色值超过 255，从而创建特殊效果，但这并不意味着 这意味着您无法使用它们创建这些效果的合格模仿，甚至无法创建全新的效果。","{}Example of how bm_normal Works{}{}Example of how bm_normal Works{}":"{}bm_normal 工作原理示例 {}{}bm_normal 工作原理示例 {}","{}GameMaker{} uses the function {}gpu_set_blendmode(){} to change the blending that your game uses for drawing. You would call this before (for example) drawing a sprite, then set it back again afterwards, something like this:":"{}GameMaker{}使用函数{}gpu_set_blendmode(){}来更改游戏用于绘制的混合。您可以在绘制精灵之前(例如)调用此函数，然后在绘制精灵之后再次设置它，类似于以下内容：","{}Hopefully you can now work out why this happens for yourself using the formulas I've outlined above and applying the appropriate figures for {}bm_normal{}.":"{}希望您现在可以使用我上面概述的公式并应用 {}bm_normal{} 的适当数字来弄清楚为什么会发生这种情况。","{}If you are still a bit confused about the alpha, try to picture it as just another colour. It behaves like a colour and all calculations on it are done in a similar manner. It's just not really visible, although the effect it has on other colours is. Which brings us to the final thing to note when using surfaces and blend modes (even {}bm_normal{})...":"{}如果您对 Alpha 仍然有点困惑，请尝试将其想象为另一种颜色。 它的行为就像一种颜色，所有关于它的计算都以类似的方式完成。 它只是不太明显，尽管它对其他颜色的影响是可见的。 这就是我们在使用曲面和混合模式（甚至是 {}bm_normal{}）时需要注意的最后一点...","{}Imagine you want to reduce the red value of all pixels drawn in an area of the room by 25%. You would first need to get 25% of 255, then convert that into an RGB colour value, and then finally use that along with bm_subtract to draw over the area. Something like this:":"{}假设你想将房间某个区域中所有像素的红色值减少25%。你首先需要得到255的25%，然后将其转换为RGB颜色值，最后使用沿着bm_subtract在该区域上绘制。类似这样：","{}So, our blend mode looks like this:":"{}因此，我们的混合模式如下所示：","{}This blend mode can be useful when you need to draw overlapping images without them becoming so bright that they can't be seen. The bright parts will become brighter, but they should still maintain a level of colour and hue. Note though that the alpha value of the source image will also influence in the final effect when using this blend mode.":"{}当你需要绘制重叠的图像时，此混合模式非常有用，而不会让它们变得太亮而看不见。明亮的部分会变得更亮，但它们仍然应该保持一定的颜色和色调。请注意，使用此混合模式时，源图像的alpha值也会影响最终效果。","{}Using our extended blend mode we get the following:":"{}使用我们的扩展混合模式，我们得到以下结果：",'{}Using this blend mode is a great way to get that "neon glow" look, and is most often used for lighting effects, or lasers or just about anything that you want to appear to glow or have luminescence.':'{}使用此混合模式是获得"氖发光"外观的好方法，并且最常用于照明效果，或激光或任何您想要看起来发光或发光的东西。'},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="..",gTopicId="7.0_10"</script><script type="text/javascript" src="../template/scripts/rh.min.js"></script><script type="text/javascript" src="../template/scripts/common.min.js"></script><script type="text/javascript" src="../template/scripts/topic.min.js"></script><script type="text/javascript" src="../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Guide To Using Blendmodes</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../assets/css/default.css" type="text/css"><script src="../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page that explains how blendmodes work."><meta name="rh-index-keywords" content="blendmodes,Guide To Using Blendmodes"><meta name="search-keywords" content="blendmodes,blending,blend modes"><meta name="brsnext" value="Additional_Information/Project_Format.htm"><meta name="brsprev" value="Additional_Information/Guide_To_Primitives_And_Vertex_Building.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Guide To Using Blendmodes"><span>Guide To Using Blendmodes</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>Guide To Using Blend Modes</h1><p>If you've been using <span data-keyref="GameMaker Name">GameMaker</span> for any length of time, you will almost certainly have come across <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/GPU_Control.htm">blend modes</a>, and probably even used them in your games. Blend modes are a great way to change how something is drawn to give interesting and specific graphical effects, but do you know how they work and how to use them? This is a subject that can confuse people and so in this section we hope to dispel some of the mystery surrounding blend modes and enable you to use them to their fullest extent in your games.</p><h2>Overview</h2><p>Blend modes basically tell your game to draw certain things blended with whatever else is already drawn beforehand. Everything you draw to the screen is made up of four component parts - <strong>Red</strong>, <strong>Green</strong>, <strong>Blue</strong> and <strong>Alpha</strong> - and by default they are drawn to the screen using the blend mode <span class="inline">bm_normal</span>.</p><p>This blend mode draws all pixels with their colour and alpha values essentially unchanged (although, later in this section you'll see that this isn't <em>quite</em> true...), but <span data-keyref="GameMaker Name">GameMaker</span> has a number of <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode.htm">built-in blend modes</a> that can be set to change this behaviour.</p><h2>How Things Are Drawn</h2><p>When <span data-keyref="GameMaker Name">GameMaker</span> goes to draw a pixel, there's a <strong>source colour</strong> (the colour of the pixel you are going to draw) and a <strong>destination colour</strong> (the colour that's already in the pixel we're drawing to). For example, if you're drawing a pink colour after having drawn a yellow colour at the same pixel, pink is the <strong>source</strong>&nbsp;(what you're drawing), and yellow is the <strong>destination</strong> (as it's already there).</p><p>When determining the final colour of a pixel, GameMaker will combine the source and destination colours according to the <strong>blend mode</strong>&nbsp;-- basically asking, "how should I combine the pink and the yellow?".</p><h2>Calculating Final Colour</h2><p>Both the source colour and destination colour contain RGBA (<strong>Red</strong>, <strong>Green</strong>, <strong>Blue</strong> and <strong>Alpha</strong>) components, each of which are floating point values between 0 and 1.</p><p>The final colour of a pixel is calculated by multiplying each component of the source and destination by a <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">factor</a>, and then bringing them together according to the set <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">equation</a>.</p><p>This means that the way a final pixel colour is calculated is the following: <span class="inline2">(source * factor) + (destination * factor)</span>.</p><p>Here, both values are finally <strong>added together</strong>, as the default equation is <span class="inline2">bm_add</span>, however you can change that to subtract or to use some other equation (covered later on this page).</p><h2>Basic Blend Modes</h2><p>Use the function <span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode.htm">gpu_set_blendmode</a></span>&nbsp;to apply a set of blend factors and equation <strong>at the same time</strong>, as a "preset" blend mode.</p><p>You would call this before (for example) drawing a sprite, then reset it afterwards, something like this:</p><p class="code">gpu_set_blendmode(bm_add);<br>draw_self();<br>gpu_set_blendmode(bm_normal);</p><p>That code draws the instance sprite using an <strong>additive</strong> blend mode. The additive blend mode is set using one of the available GML constants, of which there are six for basic modes:</p><div data-conref="../assets/snippets/Table_Gpu_blend_modes.hts"><table><colgroup><col><col><col><col></colgroup><tbody><tr><th colspan="4"><span data-keyref="Type_Constant_Draw_Blend_Mode"><a target="_blank" href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_get_blendmode.htm">Blend Mode Constant</a></span></th></tr><tr><th>Constant</th><th>Description</th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">Extended Blend Mode</a></th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Equation</a></th></tr><tr><td><span class="inline">bm_normal</span></td><td>Normal blending (the default blend mode).</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_inv_src_alpha</span>)</td><td><span class="inline">bm_eq_add</span></td></tr><tr><td><span class="inline">bm_add</span></td><td>Additive blending. Luminosity values of light areas are added.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_eq_add</span></td></tr><tr><td><span class="inline">bm_subtract</span></td><td>Subtractive blending. Source is subtracted from the destination.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_eq_subtract</span></td></tr><tr><td><span class="inline">bm_reverse_subtract</span></td><td>Reverse subtractive blending. Destination is subtracted from the source.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_eq_reverse_subtract</span></td></tr><tr><td><span class="inline">bm_min</span></td><td>Smaller value from source and destination is selected.</td><td>(<span class="inline">bm_one</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_eq_min</span></td></tr><tr><td><span class="inline">bm_max</span></td><td>Max blending. Similar to additive blending.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_inv_src_colour</span>)</td><td><span class="inline">bm_eq_add</span></td></tr></tbody></table></div><p>The "Extended Blend Mode" column shows the factors that are applied to the source and the destination (respectively), and the "Blend Equation" column shows the equation used to bring those two values together.</p><p>Let's now look through how each basic blend mode works.</p><p class="note"><span data-conref="../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;These examples demonstrate blend modes using a green background, with a blue square drawn on it, both of which count as the destination. A grey square is drawn as the source, using each of the blend modes.</p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down9" href="#"><span data-open-text="true" data-skip-index="true">bm_normal</span><span data-close-text="true">bm_normal</span></a></p><div class="droptext" data-targetname="drop-down9"><table class="cke_show_border"><tbody><tr><th>Constant</th><th>Description</th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">Extended Blend Mode</a></th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Equation</a></th></tr><tr><td><span class="inline">bm_normal</span></td><td>Normal blending (the default blend mode).</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_inv_src_alpha</span>)</td><td><span class="inline">bm_add</span></td></tr></tbody></table><p class="dropspot"><span class="inline2">bm_normal</span> is the default blend mode, which multiplies the source colour with its alpha, and multiplies the destination colour with the&nbsp;<em>inverse</em>&nbsp;of the source alpha (to make space for the source colour to fit in). Finally it adds both together (as the equation is <span class="inline2">bm_add</span>):</p><p><img alt="bm_normal example" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/guide_blend_modes/bm_normal.png"></p><p class="dropspot">The background colour in this example is <span class="inline2">(50, 100, 0, 255)</span>.</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#"><span data-open-text="true" data-skip-index="true">bm_add</span><span data-close-text="true">bm_add</span></a></p><div class="droptext" data-targetname="drop-down"><table class="cke_show_border"><tbody><tr><th>Constant</th><th>Description</th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">Extended Blend Mode</a></th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Equation</a></th></tr><tr><td><span class="inline">bm_add</span></td><td>Additive blending. Luminosity values of light areas are added.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_add</span></td></tr></tbody></table><p class="dropspot">This blend mode multiplies the source colour with its alpha, just like <span class="inline2">bm_normal</span>, however it keeps the destination as-is (<span class="inline2">bm_one</span>). It then adds both together, resulting in a lighter colour. Note that colour values can't go over 255 (or under 0), so anything that adds up to more than that will be clamped to 255.</p><p class="dropspot"><img alt="bm_add example" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/guide_blend_modes/bm_add.png">The background colour in this example is <span class="inline2">(50, 100, 0, 255)</span>.</p><p class="dropspot">Using this blend mode is a great way to get that "neon glow" look, and is most often used for lighting effects, lasers or just about anything that you want to appear to glow or have luminescence.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span data-open-text="true" data-skip-index="true">bm_subtract</span><span data-close-text="true">bm_subtract</span></a></p><div class="droptext" data-targetname="drop-down1"><table class="cke_show_border"><tbody><tr><th>Constant</th><th>Description</th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">Extended Blend Mode</a></th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Equation</a></th></tr><tr><td><span class="inline">bm_subtract</span></td><td>Subtractive blending. Source is subtracted from the destination.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_subtract</span></td></tr></tbody></table><p class="dropspot">This mode uses the same factors as <span class="inline2">bm_add</span>, however it uses the subtract equation so the source colour is subtracted from the destination colour (i.e. foreground is removed from the background).</p><p class="dropspot"><img class="center" src="../assets/Images/Scripting_Reference/Additional_Information/guide_blend_modes/bm_subtract.png">The background colour in this example is <span class="inline2">(50, 100, 0, 255)</span>.</p><p class="dropspot">This is useful for removing parts of an image using a mask, as shown in an example later on this page under "<strong>Blend Equations</strong>".</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span data-open-text="true" data-skip-index="true">bm_reverse_subtract</span><span data-close-text="true">bm_reverse_subtract</span></a></p><div class="droptext" data-targetname="drop-down2"><table class="cke_show_border"><tbody><tr><th>Constant</th><th>Description</th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">Extended Blend Mode</a></th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Equation</a></th></tr><tr><td><span class="inline">bm_reverse_subtract</span></td><td>Reverse subtractive blending. Destination is subtracted from the source.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_reverse_subtract</span></td></tr></tbody></table><p class="dropspot">This again uses the same factors as both <span class="inline2">bm_add</span> and <span class="inline2">bm_subtract</span>, but uses the reverse-subtract equation, so the destination colour is subtracted from the source colour (i.e. background is removed from the foreground).</p><p class="dropspot"><img class="center" src="../assets/Images/Scripting_Reference/Additional_Information/guide_blend_modes/bm_reverse_subtract.png">The background colour in this example is <span class="inline2">(50, 100, 0, 255)</span>.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-open-text="" data-rhwidget="DropSpot" data-target="drop-down6" href="#"><span data-open-text="true" data-skip-index="true">bm_min</span><span data-close-text="true">bm_min</span></a></p><div class="droptext" data-targetname="drop-down6"><table class="cke_show_border"><tbody><tr><th>Constant</th><th>Description</th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">Extended Blend Mode</a></th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Equation</a></th></tr><tr><td><span class="inline">bm_min</span></td><td>Smaller value from source and destination is selected.</td><td>(<span class="inline">bm_one</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_min</span></td></tr></tbody></table><p class="dropspot">This uses the <span class="inline2">bm_one</span> factor for both source and destination colours, so they are not changed at all. Then it makes use of the minimum equation, so that whichever component value is smaller between the source and the destination (for each of R, G, B and A) is used for the final pixel.</p><p class="dropspot"><img class="center" src="../assets/Images/Scripting_Reference/Additional_Information/guide_blend_modes/bm_min.png">The background colour in this example is <span class="inline2">(50, 100, 0, 255)</span>.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down8" href="#"><span data-open-text="true" data-skip-index="true">bm_max</span><span data-close-text="true">bm_max</span></a></p><div class="droptext" data-targetname="drop-down8"><table><tbody><tr><th>Constant</th><th>Description</th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">Extended Blend Mode</a></th><th><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Equation</a></th></tr><tr><td><span class="inline">bm_max</span></td><td>Max blending. Similar to additive blending.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_inv_src_colour</span>)</td><td><span class="inline">bm_eq_add</span></td></tr></tbody></table><p class="dropspot"><span>This blend mode is more complex to explain, but it basically multiplies the source colours by the source alpha, then adds them to the destination colour values multiplied by the inverse source colour values. The actual maths behind <span class="inline2">bm_max</span> (and the other blend modes) we'll cover in part two of our article, but all you need to know is that the result will be a more "saturated" and brighter colour, without leading to the same pure white brilliance that using<span>&nbsp;</span></span><span class="inline2">bm_add</span><span><span>&nbsp;</span>will cause.</span></p><p class="dropspot"><img class="center" src="../assets/Images/Scripting_Reference/Additional_Information/guide_blend_modes/bm_max.png">The background colour in this example is <span class="inline2">(50, 100, 0, 255)</span>.</p><p class="dropspot">&nbsp;</p></div><p>&nbsp;</p><p>Now you know the very basics behind using a blend mode in <span data-keyref="GameMaker Name">GameMaker</span>. It takes the RGBA values for the source image (what is being drawn) and it then blends these with the RGBA values of the destination (what is being drawn to).</p><p>This blending is done by multiplying the individual components for each pixel colour and alpha by different amounts, depending on the effects that we wish to achieve, and then calculating the final pixel value from both using the set equation.</p><p>With this knowledge, you can start to use blend modes in your games to get glowing lasers, realistic shadows, or saturated transition effects, but there is still more to be learned here! Below&nbsp;we look at the <strong>extended blend modes</strong> (factors), as well as explore a bit of the maths behind them, so that you can create your own blending effects like multiply or overlay.</p><h2>Extended Blend Modes (Factors)</h2><p>Above&nbsp;we have talked about the function <span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode.htm">gpu_set_blendmode</a></span>, but now we are going to look at <span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">gpu_set_blendmode_ext</a></span>.</p><p>We saw that each of the built-in blend modes applies <strong>factors</strong> to the <strong>source</strong> and <strong>destination</strong> colours. For example, <span class="inline2">bm_add</span> multiplies the source with its alpha, and multiplies the destination with 1.</p><p>With <span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">gpu_set_blendmode_ext</a></span>, you can <strong>manually set the factors</strong> for the source and destination colours, separately. This gives you a ton more options to draw your pixels, as you can now manually choose what the source multiplies with, and then what the destination multiplies with.</p><h3>Denoting Components</h3><p>As you already know, both source and destination colours have RGBA components.&nbsp;Each of these components are values between 0 and 1.</p><p>We denote the source RGBA as <span class="inline2">(Rs, Gs, Bs, As)</span> and destination RGBA as <span class="inline2">(Rd, Gd, Bd, Ad)</span>.</p><p>Knowing these will help you understand how each factor works, as one factor may use e.g. the <span class="inline2">Rs</span> value (source red), but another may use&nbsp;<span class="inline2">Rd</span> (destination red), and so on.</p><h3>Calculating The Final Pixel</h3><p>When you go to draw something, the GPU gets this:</p><ul class="colour"><li><span class="inline2">(Rs, Gs, Bs, As)</span> = the RGB and Alpha of the colour you are going to draw.</li><li><span class="inline2">(Rd, Gd, Bd, Ad)</span> = the RGB and Alpha of the colour that is already there at the pixel position.</li></ul><p>Then it does the following for every single pixel:</p><p class="code">final_pixel_colour = &nbsp;(Rs,Gs,Bs,As) * source_blend_factor + (Rd,Gd,Bd,Ad) * destination_blend_factor</p><p>As you can see, it is multiplying the source and destination RGBAs with their set factors. It then adds them together as per the default <a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">equation</a>.</p><p>Blend factors are defined in <span data-keyref="GameMaker Name">GameMaker</span> by a number of GML constants. Each constant is a factor that you can use for the source or destination (or both). The following factors are available:</p><div data-conref="../assets/snippets/Table_Gpu_blend_modes_ext.hts"><table><colgroup><col><col></colgroup><tbody><tr><th colspan="2"><span data-keyref="Type_Constant_Draw_Blend_Mode_Factor"><a target="_blank" href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_get_blendmode_ext.htm">Blend Mode Factor Constant</a></span></th></tr><tr><th>Constant</th><th>Blend factor (Red, Green, Blue, Alpha)</th></tr><tr><td><span class="inline">bm_zero</span></td><td>(0, 0, 0, 0)</td></tr><tr><td><span class="inline">bm_one</span></td><td>(1, 1, 1, 1)</td></tr><tr><td><span class="inline">bm_src_colour</span></td><td>(Rs, Gs, Bs, As)</td></tr><tr><td><span class="inline">bm_inv_src_colour</span></td><td>(1-Rs, 1-Gs, 1-Bs, 1-As)</td></tr><tr><td><span class="inline">bm_src_alpha</span></td><td>(As, As, As, As)</td></tr><tr><td><span class="inline">bm_inv_src_alpha</span></td><td>(1-As, 1-As, 1-As, 1-As)</td></tr><tr><td><span class="inline">bm_dest_alpha</span></td><td>(Ad, Ad, Ad, Ad)</td></tr><tr><td><span class="inline">bm_inv_dest_alpha</span></td><td>(1-Ad, 1-Ad, 1-Ad, 1-Ad)</td></tr><tr><td><span class="inline">bm_dest_colour</span></td><td>(Rd, Gd, Bd, Ad)</td></tr><tr><td><span class="inline">bm_inv_dest_colour</span></td><td>(1-Rd, 1-Gd, 1-Bd, 1-Ad)</td></tr><tr><td><span class="inline">bm_src_alpha_sat</span></td><td>(f, f, f, 1) where f = min(As, 1-Ad)</td></tr></tbody></table></div><p>The second column shows you what values each of the R, G, B, A components are multiplied with, when that factor is being used.</p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down4" href="#"><span data-open-text="true" data-skip-index="true">Example of how bm_normal Works</span><span data-close-text="true">Example of how bm_normal Works</span></a></p><div class="droptext" data-targetname="drop-down4"><p class="dropspot">Time to look at a practical example of how this comes together for drawing in <span data-keyref="GameMaker Name">GameMaker</span>. For this, we are going to look at the&nbsp;<span class="inline2">bm_normal</span>&nbsp;blend mode, which is simply:</p><p class="code">gpu_set_blendmode_ext(bm_src_alpha, bm_inv_src_alpha);<br>gpu_set_blendequation(bm_add);</p><p class="dropspot">One of the problems people have with blend modes is visualising the results, so to show the maths behind them, we'll use this blend mode as our test subject since it's the blend mode that everyone uses the most and we know exactly what to expect from it. Imagine we are drawing a rectangle with the colour <span class="inline2">(128, 255, 64, 255)</span> over a background with the colour <span class="inline2">(64, 128, 255, 255)</span>:</p><p class="dropspot"><img alt="Example of bm_normal" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_Example1.png">So, our blending calculations look like this:</p><p class="code_plain"><strong>Colours:</strong><br>Source: (128, 255, 64, 255) = (0.5, 1, 0.25, 1)<br>Destination: (64, 128, 255, 255) = (0.25, 0.5, 1, 1)<br><br><strong>Factors:</strong><br>bm_src_alpha (As, As, As, As) = (255, 255, 255, 255) = (1, 1, 1, 1)<br>bm_inv_src_alpha (1-As, 1-As, 1-As, 1-As) = &nbsp;(0, 0, 0, 0)<br><br><strong>Formula:</strong><br>(Rs,Gs,Bs,As) * bm_src_alpha + (Rd,Gd,Bd,Ad) * bm_inv_src_alpha<br><br><strong>Apply factors</strong>:<br>(0.5, 1, 0.25, 1) * (1, 1, 1, 1) + (0.25, 0.5, 1, 1) * (0, 0, 0, 0)<br><br><strong>Apply equation</strong>:<br>(0.5, 1, 0.25, 1) + (0, 0, 0, 0)<br><br><strong>Final pixel</strong>:<br>(0.5, 1, 0.25, 1) = (128, 255, 64, 255)</p><p class="dropspot">As you can see, we multiply the destination values by 0, which gives them a value of 0 too, meaning that the source colours are unchanged, so our final colour value is&nbsp;<span class="inline2">(128, 255, 64, 255)</span>.</p><p class="dropspot">You can see how the inclusion of a lower alpha affects this calculation:</p><p class="code_plain"><strong>Colours:</strong><br>Source (128, 255, 64, 128) = (0.5, 1, 0.25, 0.5)<br>Destination: (64, 128, 255, 255) = (0.25, 0.5, 1, 1)<br><br><strong>Factors:</strong><br>bm_src_alpha (As, As, As, As) = (128, 128, 128, 128) = (0.5, 0.5, 0.5, 0.5)<br>bm_inv_src_alpha (1-As, 1-As, 1-As, 1-As) = (0.5, 0.5, 0.5, 0.5)<br><br><strong>Formula:</strong><br>(Rs,Gs,Bs,As) * bm_src_alpha + (Rd,Gd,Bd,Ad) * bm_inv_src_alpha<br><br><strong>Apply factors</strong>:<br>(0.5, 1, 0.25, 0.5) * (0.5, 0.5, 0.5, 0.5) + (0.25, 0.5, 1, 1) * (0.5, 0.5, 0.5, 0.5)<br><br><strong>Apply equation</strong>:<br>(0.25, 0.5, 0.125, 0.25) + (0.125, 0.25, 0.5, 0.5)<br><br><strong>Final pixel</strong>:<br>(0.375, 0.75, 0.625, 0.75) = (96, 192, 159, 192)</p><p class="dropspot">This gives a final pixel colour <span class="inline2">(96, 192, 159, 192)</span>, and will give an image like that shown below:</p><p class="dropspot"><img alt="Example Of bm_normal With Alpha" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_Example2.png"></p><p class="dropspot">Hopefully you can see clearly now what the blend mode factors do, and how combining them can change what is drawn to create some interesting effects.</p></div><p>We will now look at a practical example of how to combine these factors to create your own custom blend modes.</p><h2>Creating Your Own Blend Modes</h2><p>Using the different factors available, you can create your own blend modes to achieve blending options that are not available to you normally. In this example, we are going to create a <strong>multiply</strong> effect like that used in Photoshop. We can simulate this blend mode using two of our above mentioned blend mode factor constants like this:</p><p class="code">gpu_set_blendmode_ext(bm_dest_colour, bm_zero);</p><p>Before we actually draw something using this blend mode, let's have a look at how it should look in Photoshop:</p><p><img alt="The &quot;Multiply&quot; Blend Mode In Photoshop" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_Multiply.png">Using our extended blend mode we get the following:</p><p class="code">(Rs, Gs, Bs, As) * (Rd, Gd, Bd, Ad) + (Rd, Gd, Bd, Ad) * (0,0,0,0) = (Rs, Gs, Bs, As) * (Rd, Gd, Bd, Ad)<br>Source colour * dest colour + dest colour * zero = source colour * dest colour</p><p>The blend factor <span class="inline2">bm_zero</span> effectively removes the destination colour from the equation (as zero times anything is zero), so we are left with the source colour multiplied by the blend factor of the destination colour, hence the name "multiply" for the mode. To use this in <span data-keyref="GameMaker Name">GameMaker</span>, you would simply have something like this in your <strong>Draw Event</strong>:</p><p class="code">gpu_set_blendmode_ext(bm_dest_colour, bm_zero);<br>draw_self();<br>gpu_set_blendmode(bm_normal);</p><p>The next image was taken from a test project in GameMaker using this exact code:</p><p><img alt="The &quot;Multiply&quot; Blend Mode In GameMaker" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_MultiplyGMS.png">Can you spot the difference? Probably not! There will, however, be some deviation between the two due to differences between the render tools used, but it's almost exactly as you would expect.</p><p>Note though that not all the blend modes used by art programs are available to you within <span data-keyref="GameMaker Name">GameMaker</span> due to the fact some of them can actually force the colour values to go over 255 and so create special effects, but that doesn't mean you can't create passable imitations of these effects, or even brand new effects, using them.</p><p>It's worth mentioning that with <span data-keyref="GameMaker Name">GameMaker</span> you can take this one step further using the function <span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext_sepalpha.htm">gpu_set_blendmode_ext_sepalpha</a></span>. This permits you to separate out the alpha component of the different blend mode factors and use them individually to create even more possible combinations. We won't cover this function here as it's explained in depth already in the manual, but it's worth mentioning just so you know it's available for use.</p><h2>Blend Equations</h2><p>Through reading this guide, you should already have a basic understanding of what a blend equation is. It controls how the source and destination colours are mixed together, after the factors have been applied.</p><p>By default, both the source and destination values are <strong>added</strong> together, as the default equation is <span class="inline2">bm_eq_add</span>.</p><p>The following equations are available in&nbsp;<span data-keyref="GameMaker Name">GameMaker</span>, which can be set using&nbsp;<span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">gpu_set_blendequation</a></span>:</p><div data-conref="../assets/snippets/Table_Gpu_blend_equations.hts"><table><colgroup><col><col><col></colgroup><tbody><tr><th colspan="3"><span data-keyref="Type_Constant_Draw_Blend_Mode_Equation"><a target="_blank" href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation.htm">Blend Mode Equation Constant</a></span></th></tr><tr><th>Constant</th><th>Description</th><th>Equation</th></tr><tr><td><span class="inline">bm_eq_add</span></td><td>Add both together (the default equation).</td><td>source + destination</td></tr><tr><td><span class="inline">bm_eq_subtract</span></td><td>Subtract source from destination.</td><td>destination - source</td></tr><tr><td><span class="inline">bm_eq_reverse_subtract</span></td><td>Subtract destination from source.</td><td>source - destination</td></tr><tr><td><span class="inline">bm_eq_min</span></td><td>Use whichever value is smaller.</td><td>min(source, destination)</td></tr><tr><td><span class="inline">bm_eq_max</span></td><td>Use whichever value is larger.</td><td>max(source, destination)</td></tr></tbody></table><p class="note"><span data-conref="../assets/snippets/Tag_important.hts"><span class="important">IMPORTANT</span></span>&nbsp;<a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm">Blend factors</a> are not applied when <span class="inline2">bm_eq_min</span> or <span class="inline2">bm_eq_max</span> is used as the blend equation, which is effectively the same as using&nbsp;<span class="inline2">bm_one</span>&nbsp;as the factors.</p></div><p>You can also set the equation used for RGB and Alpha separately using&nbsp;<span class="inline3_func"><a href="../GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendequation_sepalpha.htm">gpu_set_blendequation_sepalpha</a></span>.</p><h3>Using Equations</h3><p>You can use the <span class="inline2">bm_eq_subtract</span> equation to achieve the following effect:</p><p><video class="center" src="../assets/Images/Scripting_Reference/GML/Reference/Drawing/bm_eq_subtract.mp4" width="480" height="320" controls=""></video></p><p>Here, we're drawing a sprite to a <a href="../GameMaker_Language/GML_Reference/Drawing/Surfaces/Surfaces.htm">surface</a>, and then drawing a circle that subtracts whatever is in the surface. The surface is then drawn to the screen.</p><p>This can be achieved with the following <strong>Create</strong> and <strong>Draw</strong> event code:</p><p class="code_heading">Create Event</p><p class="code">surf = surface_create(128, 128);<br>surf_x = 175;<br>surf_y = 90;</p><p class="code_heading">Draw Event</p><p class="code">if (!surface_exists(surf))<br>{<br>&nbsp;&nbsp; &nbsp;surf = surface_create(128, 128);<br>}<br><br>// Draw to surface<br>surface_set_target(surf);<br>&nbsp;&nbsp; &nbsp;<br>draw_sprite(spr_box, 0, 0, 0);<br>&nbsp;&nbsp; &nbsp;<br>gpu_set_blendequation(bm_eq_subtract);<br>draw_circle(mouse_x - surf_x, mouse_y - surf_y, 32, 0);<br>gpu_set_blendequation(bm_add);<br>&nbsp;&nbsp; &nbsp;<br>surface_reset_target();<br>&nbsp;&nbsp; &nbsp;<br>// Draw surface to screen<br>draw_surface(surf, surf_x, surf_y);</p><p>First we create a surface and define its room position. Then in the Draw event, we check if the surface doesn't exist, and then recreate it.</p><p>Then we draw the following to that surface:</p><ul class="colour"><li>A sprite, drawn normally. Parts of this will be "removed" so we can see through it.</li><li>A <a href="../GameMaker_Language/GML_Reference/Drawing/Basic_Forms/draw_circle.htm">circle</a>, drawn at the mouse position, using the <span class="inline2">bm_eq_subtract</span> equation.</li></ul><p>The circle will subtract its alpha value from whatever is already in the surface, allowing us to see through it.</p><p>The surface is then drawn in the room at its defined position.</p><h2>Surfaces And Alpha</h2><p>One final thing is worth noting about blend modes, and that is how they affect the <strong>alpha</strong> component of a colour. When simply drawing to the <a class="tooltip" title="The application surface is a special built-in surface that GameMaker Studio 2 will draw everything to in the Draw Events of a game (a surface is essentially an area of memory reserved for graphics). This surface is then drawn to the display buffer at the end of each game frame, displaying its contents to the player.">application surface</a> or the <a class="tooltip" title="The display buffer is the 'canvas' where everything is finally drawn. Some events target this directly (like the Pre Draw event), while others will first draw to the application surface and then draw that to the display buffer.">display buffer</a>, you don't really need to take into consideration the destination alpha value as it will <em>always</em> be one. However surfaces that you make yourself are different, since you can clear a surface to have any alpha value from zero to one that you wish. This leads to some interesting effects that are contrary to what most people would expect.</p><p>To illustrate this, we are going to look at drawing using the basic default <span class="inline">bm_normal</span>. Most people think that having a surface cleared to alpha 0, and then drawing something with an alpha of 0.5 will give a resulting alpha value 0.5 too... <strong>but this is not the case</strong> and is something that many people think is a "bug" in how <span data-keyref="GameMaker Name">GameMaker</span> renders things. However, as you will see, it's not a bug at all!</p><p>Say you have surface with every pixel at alpha 0, then you draw a circle on it with alpha 0.5 using the <span class="inline">bm_normal</span> blend mode. The entire surface is still going to be alpha 0, but in the circle the alpha will actually be 0.25, since:</p><p class="code">0.5 * 0.5 + 0 * 0.5 = 0.5 * 0.5 = 0.25</p><p>If you then proceed to draw another circle in the existing circle, also with an alpha of 0.5, then the alpha outside the circles would be 0, in between the circles 0.25, and in the smaller circle it would be 0.375:</p><p class="code">0.5 * 0.5 + 0.25 * 0.5 = 0.25 + 0.125 = 0.375</p><p>If you were to continue to draw a number of 0.5 alpha circles to a surface with 0 alpha, and then draw this surface to the room, you would be able to clearly see this:</p><p><img alt="Surface Alpha Illustration" class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_Surface.png">If you are still a bit confused about the alpha, try to picture it as just another colour. It behaves like a colour and all calculations on it are done in a similar manner. It's just not really visible, although the effect it has on other colours is. Which brings us to the final thing to note when using surfaces and blend modes (even <span class="inline">bm_normal</span>)...</p><p>Even if the alpha of the surface is 0, <em><strong>the colour components are still there and exist and will influence in all blending operations</strong></em>. So drawing to a zero alpha cleared surface that has been cleared using the colour red (for example) will blend the source colours with the destination colours and give different effects to what you may think. The above image was created on a surface cleared to black, but if we clear the surface to red, we get this instead:</p><p><img class="center" src="../assets/Images/Scripting_Reference/Additional_Information/BlendModes2_SurfaceRed.png">Hopefully you can now work out why this happens for yourself using the formulas we've outlined above and applying the appropriate figures for <span class="inline">bm_normal</span>.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Additional_Information.htm">Additional Information</a></div><div style="float:right">Next:&nbsp;<a href="Guide_To_Using_JSON.htm">Guide To Using JSON</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>