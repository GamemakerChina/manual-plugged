<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,s){let o;o=s?e.attr(s):e.html();let a=t[removeHtml(o)];if(null!=a&&a.length){t=retHtml(o);let n=0;t&&t.forEach(function(e,t){var s=a.replace("{"+n+"}",e);a=s===a?a.replace("{}",e):s,n++}),s?e.attr(s,a):e.html(a)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"After that, another buffer {}buff_vertex_data{} is created to store the interleaved vertex data. Each of the three calls to&nbsp;{}{}buffer_copy_stride{}{}&nbsp;then reads the values of each attribute (position, colour and uv) and places them in the correct positions in the destination buffer, leaving room for the&nbsp;other attributes to be written by the next call to the function. Finally a vertex buffer is created from the data in the buffer.":"之后，创建另一个缓冲区 {}buff_vertex_data{} 来存储交错的顶点数据。然后，对 {}{}buffer_copy_stride{}{} 的三个调用中的每一个都会读取每个属性的值 (位置、颜色和 uv)，并将它们放置在目标缓冲区中的正确位置，为要写入的其他属性留出空间通过下一次调用该函数。最后根据缓冲区中的数据创建顶点缓冲区。",'By setting {}dest_stride{} to a value greater than {}src_size{}&nbsp;you can insert "gaps" between values written to the destination buffer.':'通过将 {}dest_stride{} 设置为大于 {}src_size{} 的值，您可以在写入目标缓冲区的值之间插入 " 间隙"。',"First, in the Create event, the default vertex format is created and assigned to an instance variable {}vertex_format{}. Then the three&nbsp;buffers containing the attribute data are created from base64-encoded data: {}buff_positions_xyz{} stores the (x, y, z) position data of 3 vertices, {}buff_colours_rgba{}&nbsp;stores&nbsp;their RGBA colour data and {}buff_uvs{}&nbsp;their UV data. The values of each attribute are stored one after the other, e.g. {}buff_positions_xyz{}&nbsp;stores the (x, y, z) position of the first vertex, followed by the (x, y, z) position of the second vertex, followed by that of the third vertex, etc.":"首先，在 Create 事件中，创建默认顶点格式并将其分配给实例变量 {}vertex_format{}。然后，根据 Base64 编码数据创建包含属性数据的三个缓冲区：{}buff_positions_xyz{} 存储 3 个顶点的 (x, y, z) 位置数据，{}buff_colours_rgba{} 存储其 RGBA 颜色数据，{}buff_uvs{} 他们的 UV 数据。每个属性的值依次存储，例如 {}buff_positions_xyz{} 存储第一个顶点的 (x, y, z) 位置，然后是第二个顶点的 (x, y, z) 位置，然后是第三个顶点的位置，依此类推。","First, the size&nbsp;of an item is set to the size&nbsp;of a float ({}buffer_f32{}) and stored in {}_item_size{}. Next, the source and destination buffer are created with a fixed size and an alignment of 4 (since floats always align to multiples of 4 bytes). The source buffer can&nbsp;only store a single float, the destination buffer can store 16 floats. Then, the value {}1{} is written to the source buffer. Finally, this value is copied a total&nbsp;of 4 times using&nbsp;{}{}buffer_copy_stride{}{}&nbsp;with a destination stride value&nbsp;of 5 times the item size. After the function has finished&nbsp;{}buff_destination{}&nbsp;will contain the values of an {}identity matrix{}.":"首先，项目的大小设置为浮点数 ({}buffer_f32{}) 的大小并存储在 {}_item_size{} 中。接下来，使用固定大小和 4 对齐方式创建源缓冲区和目标缓冲区 (因为浮点数始终与 4 字节的倍数对齐)。源缓冲区只能存储单个浮点数，目标缓冲区可以存储 16 个浮点数。然后，值 {}1{} 被写入源缓冲区。最后，使用 {}{}buffer_copy_stride{}{} 将该值总共复制 4 次，目标步幅值为项目大小的 5 倍。函数完成后，{}buff_destination{} 将包含 {} 单位矩阵 {} 的值。","For example, in case&nbsp;of&nbsp;{}GameMaker{}'s {}default vertex format{}&nbsp;the stride value is {}24{}&nbsp;(3*4+4*1+2*4). The number of bytes to move from&nbsp;one (x, y, z) position in the buffer to the next is {}24{}, the number of bytes to move from&nbsp;one colour value to the next is also&nbsp;{}24{}, as well as the number&nbsp;of bytes to move from&nbsp;one UV to the next.":"例如，对于 {}GameMaker{} 的 {} 默认顶点格式 {}，步幅值为 {}24{}(3*4+4*1+2*​​4)。从缓冲区中的一个 (x, y, z) 位置移动到下一个位置的字节数为 {}24{}，从一个颜色值移动到下一个颜色值的字节数也是 {}24{}，以及从一个 UV 移动到下一个 UV 的字节数。","How It Works":"怎么运行的","In case of a fixed-size buffer ({}buffer_fixed{})&nbsp;or&nbsp;of a non-wrapping buffer the copying stops when the end&nbsp;of the buffer is reached.&nbsp;For a buffer that's set to wrap ({}buffer_wrap{}) copying will continue from the start&nbsp;of the buffer.":"对于固定大小缓冲区 ({}buffer_fixed{}) 或非换行缓冲区，复制会在到达缓冲区末尾时停止。对于设置为换行 ({}buffer_wrap{}) 的缓冲区，复制将从缓冲区的开头继续。","In the Draw event, the vertex buffer is submitted.&nbsp;This will draw a triangle.":"在 Draw 事件中，顶点缓冲区被提交。这将绘制一个三角形。","It then repeats {}src_count{} times the following:&nbsp; {} {}Copy&nbsp;{}src_size{} bytes&nbsp;of data from the current offset in the source buffer to the current offset in the destination buffer.{} {}Move {}src_stride{} bytes to the right&nbsp;or to the left in the source buffer, depending&nbsp;on the sign&nbsp;of {}src_stride{}, and {}dest_stride{} bytes to the left&nbsp;or right in the destination buffer.{} {} ":"然后，它会重复 {}src_count{} 次以下操作：{}{} 将 {}src_size{} 字节数据从源缓冲区中的当前偏移量复制到目标缓冲区中的当前偏移量。{}{} 在源缓冲区中向左或向右移动 {}src_stride{}  个字节 (具体取决于 {}src_stride{} 的符号)，在目标缓冲区中向左或向右移动 {}dest_stride{} 个字节。{}{}","The above code first initialises two temporary variables that are used in the code that follows: the size of a single item {}_item_size{} and the number of items {}_num_items{}. It then creates a new buffer of a fixed size with room for this number&nbsp;of items. The byte alignment can be set to 4 since every item is stored at an integer multiple of 4 bytes. Next, a&nbsp;{}repeat{} loop writes the values 0 to 100 to the buffer, using&nbsp;{}{}buffer_write{}{}. After that, another fixed-size buffer of 2048 bytes is created and stored in the variable {}buff_data{}. Finally,&nbsp;{}{}buffer_copy_stride{}{}&nbsp;is called to write the numbers in the source buffer&nbsp;{}buff_numbers{} to the destination buffer {}buff_data{}. Because of the negative value of the source offset, the last number in the buffer is the first&nbsp;one&nbsp;to be written. Also, the numbers are traversed backwards because of the negative value&nbsp;of the source stride. The destination stride&nbsp;of 12 makes sure the numbers are spaced 12 bytes apart in {}buff_data{}. As a result&nbsp;{}buff_data{} contains the numbers in reverse&nbsp;order, with 12 bytes between each&nbsp;of them.":"上述代码首先初始化以下代码中使用的两个临时变量：单个项目的大小 {}_item_size{} 和项目数量 {}_num_items{}。然后，它创建一个固定大小的新缓冲区，为该数量的项目提供空间。字节对齐可以设置为 4，因为每个项目都以 4 字节的整数倍存储。接下来，{}repeat{} 循环使用 {}{}buffer_write{}{} 将 0 到 100 的值写入缓冲区。之后，创建另一个 2048 字节的固定大小缓冲区并将其存储在变量 {}buff_data{} 中。最后，调用 {}{}buffer_copy_stride{}{} 将源缓冲区 {}buff_numbers{} 中的数字写入目标缓冲区 {}buff_data{}。由于源偏移量为负值，缓冲区中的最后一个数字是第一个要写入的数字。此外，由于源步幅为负值，数字会向后遍历。目标步幅为 12 可确保 {}buff_data{} 中的数字间隔 12 个字节。因此，{}buff_data{} 包含相反顺序的数字，每个数字之间有 12 个字节。","The above code shows basic usage&nbsp;of the&nbsp;{}{}buffer_copy_stride{}{}&nbsp;function. First, a couple&nbsp;of temporary variables are defined that store the number&nbsp;of items in source and destination buffer, the stride&nbsp;of the source buffer and the size&nbsp;of an item. Two buffers&nbsp;of fixed size are then created,&nbsp;one to store the source data and&nbsp;one to store the destination data. The references to them are stored in the variables {}buff_source{} and {}buff_destination{} respectively. Next, the source buffer has 200 items written to it using {}{}buffer_write{}{}. Every item consists of one random {}buffer_f32{} value between -100 and 100 followed by a {}buffer_f16{} value that stores an index. Finally,&nbsp;the second {}buffer_f16{} element&nbsp;of each item is copied to the destination buffer using {}{}buffer_copy_stride{}{}. The first {}buffer_f16{} value is written to byte 0&nbsp;(as&nbsp;{}dest_offset{}&nbsp;is set to 0), the next&nbsp;one is written to byte 2 ({}dest_stride{} is set to {}_itemsize{} which is 2), the next one to byte 4, and so&nbsp;on. After the function call, {}buff_destination{} will contain the 200&nbsp;{}buffer_f16{} values in {}buff_source{} one right after the other, with no bytes in-between.":"上面的代码显示了 {}{}buffer_copy_stride{}{} 函数的基本用法。首先，定义几个临时变量，用于存储源缓冲区和目标缓冲区中的项目数、源缓冲区的步幅和项目的大小。然后创建两个固定大小的缓冲区，一个用于存储源数据，一个用于存储目标数据。对它们的引用分别存储在变量 {}buff_source{} 和 {}buff_destination{} 中。接下来，使用 {}{}buffer_write{}{} 将 200 个项目写入源缓冲区。每一项都包含一个介于 -100 到 100 之间的随机 {}buffer_f32{} 值，后跟一个存储索引的 {}buffer_f16{} 值。最后，使用 {}{}buffer_copy_stride{}{} 将每个项目的第二个 {16}buffer_f16{17} 元素复制到目标缓冲区。第一个 {}buffer_f16{} 值写入字节 0( 因为 {}dest_offset{} 设置为 0)，下一个值写入字节 2({}dest_stride{} 设置为 {}_itemsize{}，即 2)、下一个到字节 4，依此类推。函数调用后，{}buff_destination{} 将依次包含 {34}buff_source{35} 中的 200 个 {}buffer_f16{} 值，中间没有字节。","The above code shows how you can use a stride value of 0 to keep copying the same value multiple times to a destination buffer.":"上面的代码显示了如何使用步长值 0 来多次将相同的值复制到目标缓冲区。","The above example shows how to join together data that's stored as attributes in separate buffers. The data are combined into a single buffer, in which the data are {}interleaved{}.":"上面的示例展示了如何将作为属性存储在单独缓冲区中的数据连接在一起。数据被组合到单个缓冲区中，其中数据是 {} 交错 {} 的。","The buffer containing the source data":"包含源数据的缓冲区","The buffer to copy the data to":"将数据复制到的缓冲区","The function call belonging to the above diagram would look as follows:&nbsp;{}{}buffer_copy_stride{}(src_buffer, 6, 2, 6, 3, dest_buffer, 8, 2);{}":"属于上图的函数调用如下所示：{}{}buffer_copy_stride{}(src_buffer, 6, 2, 6, 3, dest_buffer, 8, 2);{}","The function starts by moving {}src_offset{} bytes from the start&nbsp;of the source buffer and {}dest_offset{} bytes from the start&nbsp;of the destination buffer.":"该函数首先从源缓冲区的开头移动 {}src_offset{} 字节，从目标缓冲区的开头移动 {}dest_offset{} 字节。","The number&nbsp;of bytes between two items in the destination buffer. This value can be negative.":"目标缓冲区中两个项目之间的字节数。该值可以为负值。","The number&nbsp;of bytes between two items. This value can be negative and be set to 0.":"两个项目之间的字节数。该值可以为负数并设置为 0。","The number&nbsp;of items to copy":"要复制的项目数","The size, in bytes,&nbsp;of a single item to copy":"要复制的单个项目的大小 (以字节为单位)","The stride is the number of bytes to go from one item to the next. A positive value&nbsp;moves forward, a negative value moves backward.":"步幅是从一个项目到下一个项目的字节数。正值向前移动，负值向后移动。","The stride value can be greater than the number&nbsp;of bytes that an item actually uses. These bytes in between may contain&nbsp;other data&nbsp;or no useful data at all.":"步幅值可以大于项目实际使用的字节数。中间的这些字节可能包含其他数据或根本不包含有用的数据。","The&nbsp;offset, in bytes, in the destination buffer to write the data.&nbsp;This&nbsp;offset can be negative.":"用于写入数据的目标缓冲区中的偏移量 (以字节为单位)。该偏移量可以是负值。","The&nbsp;offset, in bytes, in the source buffer to start copying bytes. When negative, it is subtracted from the buffer size.":"源缓冲区中开始复制字节的偏移量 (以字节为单位)。如果为负数，则从缓冲区大小中减去它。","This function copies the given number of&nbsp;items from&nbsp;a source&nbsp;buffer to a destination buffer, where all items have the same size in bytes and are spaced apart evenly by a different number&nbsp;of bytes in the source and destination buffer.":"此函数将给定数量的项目从源缓冲区复制到目标缓冲区，其中所有项目都具有相同的字节大小，并且在源缓冲区和目标缓冲区中均匀地间隔开不同数量的字节。","Usage Notes":"使用说明",'You "select" the attribute&nbsp;you want to copy by changing the offset, meanwhile the stride remains unchanged:&nbsp;':'您可以通过更改偏移量 " 选择 " 要复制的属性，同时步幅保持不变：',"You can interpret the source offset as the sum&nbsp;of two offsets: an offset to the start of the item data and an offset within the item (i.e. which attribute&nbsp;of the item to copy).":"您可以将源偏移量解释为两个偏移量的总和：项目数据开头的偏移量和项目内的偏移量 (即要复制项目的哪个属性)。","You can use this function with buffers that store items and their attributes in a structured way, e.g. game data, vertex data&nbsp;or any&nbsp;other data in a known format.":"您可以将此函数与以结构化方式存储项目及其属性的缓冲区一起使用，例如游戏数据、顶点数据或任何其他已知格式的数据。","{}{}NOTE{}{}&nbsp;You cannot copy to the same buffer.":"{}{} 注意{}{} 您不能复制到同一缓冲区。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.2.18.0_21"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>buffer_copy_stride</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" type="text/css" href="../../../assets/css/default.css"><script src="../../../assets/scripts/main_script.js"></script><meta name="rh-authors" content="Bart Teunis"><meta name="topic-comment" content=""><meta name="rh-index-keywords" content="buffer_copy_stride"><meta name="search-keywords" content="buffer_copy_stride"><meta name="template" content="assets/masterpages/Manual_Keyword_Page.htt"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Buffers/buffer_copy_from_vertex_buffer.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Buffers/buffer_copy.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="buffer_copy_stride"><span>buffer_copy_stride</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">buffer_copy_stride</span></h1><p>This function copies the given number of&nbsp;items from&nbsp;a source&nbsp;buffer to a destination buffer, where all items have the same size in bytes and are spaced apart evenly by a different number&nbsp;of bytes in the source and destination buffer.</p><p>You can use this function with buffers that store items and their attributes in a structured way, e.g. game data, vertex data&nbsp;or any&nbsp;other data in a known format.</p><div data-conref="../../../assets/snippets/Note_Buffer_Copy_NoSame.hts"><p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;You cannot copy to the same buffer.</p></div><p><img class="center" height="388" src="../../../assets/Images/Scripting_Reference/GML/Reference/Buffers/buffer_copy_stride_schematic.png" width="1231"></p><p>The function call belonging to the above diagram would look as follows:&nbsp;<span class="inline2"><span data-field="title" data-format="default">buffer_copy_stride</span>(src_buffer, 6, 2, 6, 3, dest_buffer, 8, 2);</span></p><p>You can interpret the source offset as the sum&nbsp;of two offsets: an offset to the start of the item data and an offset within the item (i.e. which attribute&nbsp;of the item to copy).</p><h3>Stride</h3><p>The stride is the number of bytes to go from one item to the next. A positive value&nbsp;moves forward, a negative value moves backward.</p><p>For example, in case&nbsp;of&nbsp;<span data-keyref="GameMaker Name">GameMaker</span>'s <a href="../../../Additional_Information/Guide_To_Primitives_And_Vertex_Building.htm#passthrough_vertex_format">default vertex format</a>&nbsp;the stride value is <span data-keyref="Const_DefaultVertexFormat_Bytesize">24</span>&nbsp;(3*4+4*1+2*4). The number of bytes to move from&nbsp;one (x, y, z) position in the buffer to the next is <span data-keyref="Const_DefaultVertexFormat_Bytesize">24</span>, the number of bytes to move from&nbsp;one colour value to the next is also&nbsp;<span data-keyref="Const_DefaultVertexFormat_Bytesize">24</span>, as well as the number&nbsp;of bytes to move from&nbsp;one UV to the next.</p><p>You "select" the attribute&nbsp;you want to copy by changing the offset, meanwhile the stride remains unchanged:&nbsp;</p><p><img class="center" height="260" src="../../../assets/Images/Scripting_Reference/GML/Reference/Buffers/buffer_copy_stride_stride.png" width="1280"></p><h3>How It Works</h3><ul class="Disc"><li>The function starts by moving <span class="inline2">src_offset</span> bytes from the start&nbsp;of the source buffer and <span class="inline2">dest_offset</span> bytes from the start&nbsp;of the destination buffer.</li><li>It then repeats <span class="inline2">src_count</span> times the following:&nbsp;<ul><li>Copy&nbsp;<span class="inline2">src_size</span> bytes&nbsp;of data from the current offset in the source buffer to the current offset in the destination buffer.</li><li>Move <span class="inline2">src_stride</span> bytes to the right&nbsp;or to the left in the source buffer, depending&nbsp;on the sign&nbsp;of <span class="inline2">src_stride</span>, and <span class="inline2">dest_stride</span> bytes to the left&nbsp;or right in the destination buffer.</li></ul></li></ul><h3>Usage Notes</h3><ul class="Disc"><li>The stride value can be greater than the number&nbsp;of bytes that an item actually uses. These bytes in between may contain&nbsp;other data&nbsp;or no useful data at all.</li><li>By setting <span class="inline2">dest_stride</span> to a value greater than <span class="inline2">src_size</span>&nbsp;you can insert "gaps" between values written to the destination buffer.</li><li>In case of a fixed-size buffer (<span class="inline2">buffer_fixed</span>)&nbsp;or&nbsp;of a non-wrapping buffer the copying stops when the end&nbsp;of the buffer is reached.&nbsp;For a buffer that's set to wrap (<span class="inline2">buffer_wrap</span>) copying will continue from the start&nbsp;of the buffer.</li></ul><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">buffer_copy_stride</span>(src_buffer, src_offset, src_size, src_stride, src_count, dest_buffer, dest_offset, dest_stride);</p><table><colgroup><col><col><col></colgroup><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>src_buffer</td><td><span data-keyref="Type_ID_Buffer"><a target="_blank" href="buffer_create.htm">Buffer</a></span></td><td>The buffer containing the source data</td></tr><tr><td>src_offset</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The&nbsp;offset, in bytes, in the source buffer to start copying bytes. When negative, it is subtracted from the buffer size.</td></tr><tr><td>src_size</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The size, in bytes,&nbsp;of a single item to copy</td></tr><tr><td>src_stride</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The number&nbsp;of bytes between two items. This value can be negative and be set to 0.</td></tr><tr><td>src_count</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The number&nbsp;of items to copy</td></tr><tr><td>dest_buffer</td><td><span data-keyref="Type_ID_Buffer"><a target="_blank" href="buffer_create.htm">Buffer</a></span></td><td>The buffer to copy the data to</td></tr><tr><td>dest_offset</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The&nbsp;offset, in bytes, in the destination buffer to write the data.&nbsp;This&nbsp;offset can be negative.</td></tr><tr><td>dest_stride</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The number&nbsp;of bytes between two items in the destination buffer. This value can be negative.</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Void">N/A</span></p><p>&nbsp;</p><h4>Example 1: Basic Usage</h4><p class="code">var _num_items = 200;<br>var _attribute_size = buffer_sizeof(buffer_u16);<br>var _itemsize_source = buffer_sizeof(buffer_f32) + _attribute_size;<br>buff_source = buffer_create(_num_items * _itemsize_source, buffer_fixed, 1);<br>buff_destination = buffer_create(_num_items * _attribute_size, buffer_fixed, 1);<br><br>var _i = 0;<br>repeat(_num_items)<br>{<br>&nbsp;&nbsp; &nbsp;buffer_write(buff_source, buffer_f32, random_range(-100, 100));<br>&nbsp;&nbsp; &nbsp;buffer_write(buff_source, buffer_u16, _i++);<br>}<br><br><span data-field="title" data-format="default">buffer_copy_stride</span>(buff_source, 4, _attribute_size, _itemsize_source, _num_items, buff_destination, 0, _attribute_size);</p><p>The above code shows basic usage&nbsp;of the&nbsp;<span class="inline3_func"><span data-field="title" data-format="default">buffer_copy_stride</span></span>&nbsp;function. First, a couple&nbsp;of temporary variables are defined that store the number&nbsp;of items in source and destination buffer, the stride&nbsp;of the source buffer and the size&nbsp;of an item. Two buffers&nbsp;of fixed size are then created,&nbsp;one to store the source data and&nbsp;one to store the destination data. The references to them are stored in the variables <span class="inline2">buff_source</span> and <span class="inline2">buff_destination</span> respectively. Next, the source buffer has 200 items written to it using <span class="inline3_func"><a href="buffer_write.htm">buffer_write</a></span>. Every item consists of one random <span class="inline2">buffer_f32</span> value between -100 and 100 followed by a <span class="inline2">buffer_f16</span> value that stores an index. Finally,&nbsp;the second <span class="inline2">buffer_f16</span> element&nbsp;of each item is copied to the destination buffer using <span class="inline3_func"><span data-field="title" data-format="default">buffer_copy_stride</span></span>. The first <span class="inline2">buffer_f16</span> value is written to byte 0&nbsp;(as&nbsp;<span class="inline2">dest_offset</span>&nbsp;is set to 0), the next&nbsp;one is written to byte 2 (<span class="inline2">dest_stride</span> is set to <span class="inline2">_itemsize</span> which is 2), the next one to byte 4, and so&nbsp;on. After the function call, <span class="inline2">buff_destination</span> will contain the 200&nbsp;<span class="inline2">buffer_f16</span> values in <span class="inline2">buff_source</span> one right after the other, with no bytes in-between.</p><p>&nbsp;</p><h4>Example 2: Negative Offset &amp; Stride</h4><p class="code">var _item_size = buffer_sizeof(buffer_f32);<br>var _num_items = 100;<br><br>var _i = 0;<br>buff_numbers = buffer_create(_num_items * _item_size, buffer_fixed, 4);<br>repeat(_num_items) buffer_write(buff_numbers, buffer_f32, _i++);<br><br>buff_data = buffer_create(2048, buffer_fixed, 4);<br><span data-field="title" data-format="default">buffer_copy_stride</span>(buff_numbers, -_item_size, _item_size, -_item_size, _num_items, buff_data, 0, 12);</p><p>The above code first initialises two temporary variables that are used in the code that follows: the size of a single item <span class="inline2">_item_size</span> and the number of items <span class="inline2">_num_items</span>. It then creates a new buffer of a fixed size with room for this number&nbsp;of items. The byte alignment can be set to 4 since every item is stored at an integer multiple of 4 bytes. Next, a&nbsp;<a href="../../GML_Overview/Language_Features/repeat.htm">repeat</a> loop writes the values 0 to 100 to the buffer, using&nbsp;<span class="inline3_func"><a href="buffer_write.htm">buffer_write</a></span>. After that, another fixed-size buffer of 2048 bytes is created and stored in the variable <span class="inline2">buff_data</span>. Finally,&nbsp;<span class="inline3_func"><span data-field="title" data-format="default">buffer_copy_stride</span></span>&nbsp;is called to write the numbers in the source buffer&nbsp;<span class="inline2">buff_numbers</span> to the destination buffer <span class="inline2">buff_data</span>. Because of the negative value of the source offset, the last number in the buffer is the first&nbsp;one&nbsp;to be written. Also, the numbers are traversed backwards because of the negative value&nbsp;of the source stride. The destination stride&nbsp;of 12 makes sure the numbers are spaced 12 bytes apart in <span class="inline2">buff_data</span>. As a result&nbsp;<span class="inline2">buff_data</span> contains the numbers in reverse&nbsp;order, with 12 bytes between each&nbsp;of them.</p><p>&nbsp;</p><h4>Example 3: Stride set to 0</h4><p class="code">var _item_size = buffer_sizeof(buffer_f32);<br>buff_source = buffer_create(_item_size, buffer_fixed, 4);<br>buff_destination = buffer_create(16 * _item_size, buffer_fixed, 4);<br><br>buffer_write(buff_source, buffer_f32, 1);<br><br><span data-field="title" data-format="default">buffer_copy_stride</span>(buff_source, 0, _item_size, 0, 4, buff_destination, 0, 5 * _item_size);</p><p>The above code shows how you can use a stride value of 0 to keep copying the same value multiple times to a destination buffer.</p><p>First, the size&nbsp;of an item is set to the size&nbsp;of a float (<span class="inline2">buffer_f32</span>) and stored in <span class="inline2">_item_size</span>. Next, the source and destination buffer are created with a fixed size and an alignment of 4 (since floats always align to multiples of 4 bytes). The source buffer can&nbsp;only store a single float, the destination buffer can store 16 floats. Then, the value <span class="inline2">1</span> is written to the source buffer. Finally, this value is copied a total&nbsp;of 4 times using&nbsp;<span class="inline3_func"><span data-field="title" data-format="default">buffer_copy_stride</span></span>&nbsp;with a destination stride value&nbsp;of 5 times the item size. After the function has finished&nbsp;<span class="inline2">buff_destination</span>&nbsp;will contain the values of an <a href="../Maths_And_Numbers/Matrix_Functions/matrix_build_identity.htm">identity matrix</a>.</p><p>&nbsp;</p><h4>Example 4: Interleaving Data from Multiple Buffers</h4><p class="code_heading">Create Event</p><p class="code">vertex_format_begin();<br>array_foreach([vertex_format_add_position_3d, vertex_format_add_colour, vertex_format_add_texcoord], script_execute);<br>vertex_format = vertex_format_end();<br><br>buff_positions_xyz = buffer_base64_decode("JqwCQwuLi0J5DIBBcQc3Q27Ar0NNpBZD+WSqQ8B9OEPB0YtD");<br>buff_colours_rgba = buffer_base64_decode("Ud93/wghI//D2cr/");<br>buff_uvs = buffer_base64_decode("9KQyP69/UT9Uxak+ybENPzKNZzwxS1A9");<br><br>buff_vertex_data = buffer_create(3 * 24, buffer_fixed, 1);<br>buffer_copy_stride(buff_positions_xyz, 0, 3 * 4, 3 * 4, 3, buff_vertex_data, 0, 24);<br>buffer_copy_stride(buff_colours_rgba, 0, 4 * 1, 4 * 1, 3, buff_vertex_data, 12, 24);<br>buffer_copy_stride(buff_uvs, 0, 2 * 4, 2 * 4, 3, buff_vertex_data, 16, 24);<br>vb = vertex_create_buffer_from_buffer(buff_vertex_data, vertex_format);</p><p class="code_heading">Draw Event</p><p class="code">vertex_submit(vb, pr_trianglelist, -1);</p><p>The above example shows how to join together data that's stored as attributes in separate buffers. The data are combined into a single buffer, in which the data are <a href="https://en.wikipedia.org/wiki/Interleaving_(data)">interleaved</a>.</p><p>First, in the Create event, the default vertex format is created and assigned to an instance variable <span class="inline2">vertex_format</span>. Then the three&nbsp;buffers containing the attribute data are created from base64-encoded data: <span class="inline2">buff_positions_xyz</span> stores the (x, y, z) position data of 3 vertices, <span class="inline2">buff_colours_rgba</span>&nbsp;stores&nbsp;their RGBA colour data and <span class="inline2">buff_uvs</span>&nbsp;their UV data. The values of each attribute are stored one after the other, e.g. <span class="inline2">buff_positions_xyz</span>&nbsp;stores the (x, y, z) position of the first vertex, followed by the (x, y, z) position of the second vertex, followed by that of the third vertex, etc.</p><p>After that, another buffer <span class="inline2">buff_vertex_data</span> is created to store the interleaved vertex data. Each of the three calls to&nbsp;<span class="inline3_func"><span data-field="title" data-format="default">buffer_copy_stride</span></span>&nbsp;then reads the values of each attribute (position, colour and uv) and places them in the correct positions in the destination buffer, leaving room for the&nbsp;other attributes to be written by the next call to the function. Finally a vertex buffer is created from the data in the buffer.</p><p>In the Draw event, the vertex buffer is submitted.&nbsp;This will draw a triangle.</p><p><br></p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div>Back:&nbsp;<a href="Buffers.htm">Buffers</a></div><div>Next:&nbsp;<a href="buffer_copy_from_vertex_buffer.htm">buffer_copy_from_vertex_buffer</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>