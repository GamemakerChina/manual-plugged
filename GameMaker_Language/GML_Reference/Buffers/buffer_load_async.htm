<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let n;n=a?e.attr(a):e.html();let s=t[removeHtml(n)];if(null!=s&&s.length){t=retHtml(n);let o=0;t&&t.forEach(function(e,t){var a=s.replace("{"+o+"}",e);s=a===s?s.replace("{}",e):a,o++}),a?e.attr(a,s):e.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Please read the {}{}buffer_load(){}{} page for platform-specific notes.":"请阅读{}{}buffer_load(){}{}页面了解平台特定注释。","Please read the&nbsp;{}{}buffer_load{}{} page for platform-specific notes.":"请阅读 {}{}buffer_load{}{} 页面，了解特定于平台的说明。",'The "offset" defines the start position within the buffer for loading (in bytes), and the "size" is the size of the buffer area to be loaded from that offset onwards (also in bytes). You can supply a value of -1 for the size argument to load the entire buffer. Note that the function will load from a "default" folder, which does {}not{} need to be included as part of the file path you provide. This folder will be created if it doesn\'t exist or when you save a file using {}{}buffer_save_async{}{}.':'"偏移量 " 定义了缓冲区内加载的起始位置 (以字节为单位)，"大小 " 是从该偏移量开始加载的缓冲区的大小 (也以字节为单位)。您可以为大小参数提供值 -1 以加载整个缓冲区。请注意，该函数将从 " 默认 " 文件夹加载，该文件夹 {} 不需要 {} 作为您提供的文件路径的一部分包含在内。如果该文件夹不存在或者当您使用 {}{}buffer_save_async{}{} 保存文件时，将会创建该文件夹。','The above code loads the contents of the file "{}Player_Save.sav{}" to the given buffer, storing the ID of the function call in the variable "{}loadid{}". When the load is complete, the asynchronous Save/Load event will be triggered and you can parse the {}async_load{} map for the correct ID of the function, like this:':'上述代码将文件"{}Player_Save.sav{}"的内容加载到给定缓冲区，将函数调用的ID存储在变量"{}loadid{}"中。 加载完成后，异步保存/加载事件将被触发，您可以解析{}async_load{}映射以获取函数的正确ID，如下所示：','The above code loads the contents of the file "{}Player_Save.sav{}" to the given buffer, storing the ID of the function call in the variable {}loadid{}. When the load is complete, the asynchronous&nbsp;{}Save / Load{} event will be triggered and you can parse the&nbsp;{}{}async_load{}{} map for the correct ID of the function, like this:':'上述代码将文件 "{}Player_Save.sav{}" 的内容加载到给定缓冲区，并将函数调用的 ID 存储在变量 {}loadid{} 中。加载完成后，将触发异步 {}Save / Load{} 事件，您可以解析 {}{}async_load{}{} 映射以获取函数的正确 ID，如下所示：',"The above code will first check the ID of the DS map that has been created, then check the status of the callback, posting a debug message if there has been any issues.":"上述代码将首先检查已创建的DS映射的ID，然后检查回调的状态，如果出现任何问题，则发布调试消息。","The above code will first check the ID of the DS map that has been created, then check the status of the callback, posting a debug message if there have been any issues.":"上面的代码将首先检查已创建的 DS 地图的 ID，然后检查回调的状态，如果有任何问题，则发布调试消息。","The buffer to load.":"要加载的缓冲区。","The function returns a unique ID value which can then be used in the {}Save / Load Asynchronous event{}&nbsp;to check the&nbsp;{}{}async_load{}{} ID value, as shown in the extended example below. The {}async_load{} map in the event will have the following two key/value pairs:":"函数返回唯一ID值，然后可以在{}保存/加载异步事件{}中使用该值来检查{}{}async_load{}{}ID值，如下扩展示例所示。事件中的{}async_load{}映射将具有以下两个键/值对：","The function returns a unique ID value which can then be used in the {}Save / Load Asynchronous event{}&nbsp;to check the&nbsp;{}{}async_load{}{}'s ID value, as shown in the extended example below. The&nbsp;{}{}async_load{}{} map in the event will have the following two key/value pairs:":"该函数返回一个唯一的 ID 值，然后可以在 {} 保存 / 加载异步事件 {} 中使用该值来检查 {}{}async_load{}{} 的 ID 值，如下面的扩展示例所示。事件中的 {}{}async_load{}{} 映射将具有以下两个键 / 值对：","The index of the buffer to load.":"要加载的缓冲区索引。","The name of the file to load.":"要加载的文件名。","The offset within the buffer to load to (in bytes).":"缓冲区内要加载到的偏移(以字节为单位)。","The size of the buffer area to load (in bytes).":"要加载的缓冲区的大小(以字节为单位)。","The {}buffer_load_async(){} function can be called from any event, and since it is asynchronous the callback can be almost instantaneous or could take several seconds. Calling the function is simple and would look something like this:":"{}buffer_load_async(){}函数可以从任何事件中调用，由于它是异步的，所以回调可以几乎是瞬时的，或者可能需要几秒钟的时间。调用函数很简单，看起来如下：","The&nbsp;{}{}buffer_load_async{}{} function can be called from any event, and since it's asynchronous the callback can be almost instantaneous or could take several seconds. Calling the function is simple and would look something like this:":"{}{}buffer_load_async{}{} 函数可以从任何事件调用，并且由于它是异步的，因此回调几乎是瞬时的，也可能需要几秒钟的时间。调用该函数很简单，如下所示：","This function loads a file that you have created previously using the&nbsp;{}{}buffer_save{}{} function (or any of the other functions for saving buffers) into a buffer.":"此函数将您之前使用 {}{}buffer_save{}{} 函数 (或任何其他用于保存缓冲区的函数) 创建的文件加载到缓冲区中。",'With this function you can load a file that you have created previously using the {}{}buffer_save(){}{} function (or any of the other functions for saving buffers) into a buffer. The "offset" defines the start position within the buffer for loading (in bytes), and the "size" is the size of the buffer area to be loaded from that offset onwards (also in bytes). You can supply a value of -1 for the size argument and the entire buffer will be loaded. Note that the function will load from a "default" folder, which does {}not{} need to be included as part of the file path you provide. This folder will be created if it doesn\'t exist or when you save a file using {}{}buffer_save_async(){}{}.':'使用此函数，可以将以前使用{}{}buffer_save(){}{}函数(或任何其他用于保存缓冲区的函数)创建的文件加载到缓冲区中。"偏移"定义缓冲区内加载的起始位置(以字节为单位)，"大小"是从该偏移量开始加载的缓冲区的大小(也以字节为单位)。您可以为 size 参数提供值 -1，然后将加载整个缓冲区。请注意，该函数将从"default"文件夹加载，而{}不需要{}作为您提供的文件路径的一部分。如果此文件夹不存在，或使用{}{}buffer_save_async(){}{}保存文件时，将创建此文件夹。','{}"id": {}the ID of the async function as returned by the save function.':'{}"id"：{}save 函数返回的 async 函数的 ID。','{}"status": {}will return {}true{} if the data was saved/loaded correctly, and {}false{} otherwise.':'{}"status"：{}如果数据保存/加载正确，将返回{}true{}，否则返回{}false{}。','{}"status": {}will return {}true{} if the data was saved/loaded correctly, {}false{} otherwise.':'{}"status"：{} 如果数据保存 / 加载正确，将返回 {}true{}，否则返回 {}false{}。',"{}NOTE{}&nbsp;On {}HTML5{}, this is the preferred method for loading a file if you are loading from a server and not local storage, as loading synchronously has been deprecated on most browsers and will eventually be obsoleted.":"{}注意{}在{}HTML5{}上，如果您从服务器而非本地存储加载文件，这是首选的加载文件方法，因为同步加载在大多数浏览器上已经过时，最终将被淘汰。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.2.18.0_28"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>buffer_load_async</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference page for buffer_load_async"><meta name="rh-index-keywords" content="buffer_load_async"><meta name="search-keywords" content="buffer_load_async"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Buffers/buffer_load_partial.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Buffers/buffer_load_ext.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="buffer_load_async"><span>buffer_load_async</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">buffer_load_async</span></h1><p>This function loads a file that you have created previously using the&nbsp;<span class="inline3_func"><a href="buffer_save.htm">buffer_save</a></span> function (or any of the other functions for saving buffers) into a buffer.</p><p>The "offset" defines the start position within the buffer for loading (in bytes), and the "size" is the size of the buffer area to be loaded from that offset onwards (also in bytes). You can supply a value of -1 for the size argument to load the entire buffer. Note that the function will load from a "default" folder, which does <i>not</i> need to be included as part of the file path you provide. This folder will be created if it doesn't exist or when you save a file using <span class="inline3_func"><a href="buffer_save_async.htm">buffer_save_async</a></span>.</p><p>The function returns a unique ID value which can then be used in the <a href="../../../The_Asset_Editors/Object_Properties/Async_Events/Save_Load.htm">Save / Load Asynchronous event</a>&nbsp;to check the&nbsp;<span class="inline2"><a href="../../GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span>'s ID value, as shown in the extended example below. The&nbsp;<span class="inline2"><a href="../../GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span> map in the event will have the following two key/value pairs:</p><ul class="colour"><li><b>"id":</b> the ID of the async function as returned by the save function.</li><li><b>"status":</b> will return <span class="inline2">true</span> if the data was saved/loaded correctly, <span class="inline2">false</span> otherwise.</li></ul><p class="note"><span class="note">NOTE</span>&nbsp;On <b>HTML5</b>, this is the preferred method for loading a file if you are loading from a server and not local storage, as loading synchronously has been deprecated on most browsers and will eventually be obsoleted.</p><p>Please read the&nbsp;<span class="inline3_func"><a href="buffer_load.htm">buffer_load</a></span> page for platform-specific notes.</p><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">buffer_load_async</span>(buffer, filename, offset, size);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>buffer</td><td><span data-keyref="Type_ID_Buffer"><a target="_blank" href="buffer_create.htm">Buffer</a></span></td><td>The buffer to load.</td></tr><tr><td>filename</td><td><span data-keyref="Type_String"><a target="_blank" href="../../GML_Overview/Data_Types.htm">String</a></span></td><td>The name of the file to load.</td></tr><tr><td>offset</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The offset within the buffer to load to (in bytes).</td></tr><tr><td>size</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The size of the buffer area to load (in bytes).</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_ID_Async_Event"><a target="_blank" href="../Asynchronous_Functions/Asynchronous_Functions.htm">Async Request ID</a></span></p><p>&nbsp;</p><h4>Example:</h4><p>The&nbsp;<span class="inline3_func"><span data-field="title" data-format="default">buffer_load_async</span></span> function can be called from any event, and since it's asynchronous the callback can be almost instantaneous or could take several seconds. Calling the function is simple and would look something like this:</p><p class="code">loadid = <span data-field="title" data-format="default">buffer_load_async</span>(buff, "Player_Save.sav", 0, 16384);</p><p>The above code loads the contents of the file "<i>Player_Save.sav</i>" to the given buffer, storing the ID of the function call in the variable <span class="inline2">loadid</span>. When the load is complete, the asynchronous&nbsp;<a href="../../../The_Asset_Editors/Object_Properties/Async_Events/Save_Load.htm">Save / Load</a> event will be triggered and you can parse the&nbsp;<span class="inline2"><a href="../../GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span> map for the correct ID of the function, like this:</p><p class="code">if (ds_map_find_value(async_load, "id") == loadid)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;if (ds_map_find_value(async_load, "status") == false)<br>&nbsp; &nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_debug_message("Load failed!");<br>&nbsp; &nbsp;&nbsp;}<br>}</p><p>The above code will first check the ID of the DS map that has been created, then check the status of the callback, posting a debug message if there have been any issues.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Buffers.htm">Buffers</a></div><div style="float:right">Next:&nbsp;<a href="buffer_load_partial.htm">buffer_load_partial</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>