<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,o){let a;a=o?e.attr(o):e.html();let r=t[removeHtml(a)];if(null!=r&&r.length){t=retHtml(a);let n=0;t&&t.forEach(function(e,t){var o=r.replace("{"+n+"}",e);r=o===r?r.replace("{}",e):o,n++}),o?e.attr(o,r):e.html(r)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"A buffer of fixed size.":"固定大小的缓冲区。",'A buffer that will "grow" dynamically as data is added':'一个缓冲区，将在添加数据时动态 "增长"','A buffer where the data will "wrap". When the data being added reaches the limit of the buffer size, the overwrite will be placed back at the start of the buffer, and further writing will continue from that point.':'数据将在其中"包装"的缓冲区。当添加的数据达到缓冲区大小的限制时，覆盖将被放回缓冲区的开头，并从该点继续进一步写入。','A special "stripped" buffer that is extremely fast to read/write to. Can only be used with {}buffer_u8{} {}data types{}, and {}must{} be 1 byte aligned.':'一种特殊的 " 剥离 " 缓冲区，读 / 写速度极快。只能与 {}buffer_u8{}{} 数据类型 {} 一起使用，并且 {} 必须 {} 按 1 字节对齐。',"Apart from the buffer type, you will also have to set the {}byte alignment{} for the buffer. This value will vary depending on the data that you wish to store in the buffer, and in most cases a value of 1 is perfectly fine. However, be aware that for some operations a specific alignment is {}essential{}, and an incorrect alignment may cause errors (for further details on alignment see {}Buffers{}). The following is a general guide to show which values are most appropriate for each data type (when in doubt, use an alignment of 1):":"除了缓冲区类型之外，您还必须为缓冲区设置{}字节对齐{}。此值将根据您希望存储在缓冲区中的数据而变化，并且在大多数情况下，值为1是完全可以的。但是，请注意，对于某些操作，特定的对齐是{}必不可少的{}，并且不正确的对齐可能会导致错误 (有关对齐的更多详细信息，请参见{}缓冲区{})。以下是显示哪些值最适合每种数据类型的通用指南 (如有疑问，请使用1的对齐方式):","Buffer Type Constant":"缓冲区类型常量","Floats of up to 16bits should be aligned to 2 bytes.":"最多 16 位的浮点数应对齐 2 个字节。","Floats of up to 16bits should be aligned to 2 bytes. {}(Not currently supported!){}":"最多16位的浮点数应与2个字节对齐。{}(当前不支持!){}","Floats of up to 32bits should be aligned to 4 bytes.":"最多 32 位的浮点数应与 4 字节对齐。","Floats of up to 64bits should be aligned to 8 bytes.":"最多 64 位的浮点数应与 8 个字节对齐。","Signed or unsigned 16bit integers should be aligned to 2 bytes.":"有符号或无符号的16位整数应对齐2字节。","Signed or unsigned 32bit integers should be aligned to 4 bytes":"有符号或无符号的32位整数应对齐为4字节","Signed or unsigned 32bit integers should be aligned to 4 bytes.":"有符号或无符号的 32 位整数应对齐 4 个字节。","Signed or unsigned 8bit integers can be aligned to any value, but note that for a fast buffer (see {}{}buffer_write(){}{}) it {}must{} be aligned to 1.":"有符号或无符号的8位整数可以与任何值对齐，但是请注意，对于快速缓冲区 (请参阅{}{}buffer_write(){}{})，它{}必须{}与1对齐。","Signed or unsigned 8bit integers can be aligned to any value, but note that for a fast buffer (see {}{}buffer_write{}{}) it {}must{} be aligned to 1.":"有符号或无符号的 8 位整数可以对齐到任何值，但请注意，对于快速缓冲区 (参见 {}{}buffer_write{}{})，它必须 {} 对齐到 1。",'Special "stripped" buffer that is extremely fast to read/write to. Can only be used with {}buffer_u8{} {}data types{}, and {}must{} be 1 byte aligned.':'读取/写入速度极快的特殊 "剥离" 缓冲区。只能与{}buffer_u8{}{}数据类型{}一起使用，而{}必须{}为1字节对齐。',"Strings should be aligned to 1 byte.":"字符串应对齐为1字节。","The above code allocates 16384 bytes of memory to a buffer and returns the buffer, storing the reference to it in the variable {}player_buffer{}&nbsp;for future use. The buffer is aligned to a two byte boundary.":"上述代码将 16384 字节内存分配给缓冲区并返回该缓冲区，并将对其的引用存储在变量 {}player_buffer{} 中以供将来使用。缓冲区与两字节边界对齐。",'The above code allocates 16384 bytes of memory to a buffer and returns the index of that buffer, which is stored in the variable "player_buffer", for future use. The buffer is aligned to a two byte boundary.':'上面的代码将16384字节的内存分配给缓冲区，并返回该缓冲区的索引，该索引存储在变量 "player_buffer" 中，以备将来使用。缓冲区对齐到两个字节的边界。',"The above code allocates 16384 bytes of memory to a buffer and returns the index of that buffer, which is stored in the variable {}player_buffer{}, for future use. The buffer is aligned to a two byte boundary.":"上面的代码为缓冲区分配了 16384 字节的内存，并返回该缓冲区的索引，该索引存储在变量 {}player_buffer{} 中，以供将来使用。缓冲区与两字节边界对齐。","The byte alignment for the buffer":"缓冲区的字节对齐","The following constants can be used to define the buffer type:":"以下常量可用于定义缓冲区类型：","The function allocates a portion of memory for the&nbsp;buffer, which&nbsp;can then be used to store different types of data (specified when you write to the buffer using the {}{}buffer_write{}{},&nbsp;{}{}buffer_poke{}{} or&nbsp;{}{}buffer_fill{}{}&nbsp;function).":"该函数为缓冲区分配一部分内存，然后可用于存储不同类型的数据 (在使用 {}{}buffer_write{}{}、{}{}buffer_poke{}{}{ 写入缓冲区时指定 )} 或 {}{}buffer_fill{}{} 函数)。","The size (in bytes) of the buffer.":"缓冲区的大小 (以字节为单位)。","The type of buffer to create (see the constants list above).":"要创建的缓冲区类型 (请参见上面的常量列表)。","This function creates a new buffer and returns it.":"该函数创建一个新的缓冲区并返回它。","This type of buffer is to be used as a vertex buffer only.":"这种类型的缓冲区仅用作顶点缓冲区。","You use this function to allocate a portion of memory as a buffer in your game, with the function returning the unique {}buffer id{} that should be stored in a variable and used for all further function calls to the buffer. The buffer can then be used to store different types of data (specified when you write to the buffer using the {}{}buffer_write(){}{} function, with the following constants being used to define the buffer type:":"您可以使用此函数将一部分内存分配为游戏中的缓冲区，该函数返回唯一的{}缓冲区 ID{}，该缓冲区应存储在变量中，用于对缓冲区的所有后续函数调用。然后，该缓冲区可用于存储不同类型的数据(使用{}{}buffer_write (){}{}函数写入缓冲区时指定，使用以下常量定义缓冲区类型：","You use this function to allocate a portion of memory as a buffer in your game, with the function returning the unique {}buffer id{} that should be stored in a variable and used for all further function calls to the buffer. The buffer can then be used to store different types of data (specified when you write to the buffer using the {}{}buffer_write{}{}&nbsp;function, with the following constants being used to define the buffer type:":"您可以使用此函数在游戏中分配一部分内存作为缓冲区，该函数返回唯一的 {}buffer id{}，该 id 应存储在变量中，并用于所有对缓冲区的进一步函数调用。然后，该缓冲区可用于存储不同类型的数据 (在使用 {}{}buffer_write{}{} 函数写入缓冲区时指定，以下常量用于定义缓冲区类型：","{}NOTE{}: Byte alignment can be very important as the wrong choice may adversely affect performance.":"{}注意{}: 字节对齐可能非常重要，因为错误的选择可能会对性能产生不利影响。","{}NOTE{}: It's important that you remove any dynamically created resources like this from memory when you no longer need them to prevent memory leaks, so when you are finished with the buffer that you have created you should free it up again using {}{}{}buffer_delete(){}{}{}.":"{}注意{}: 重要的是，当您不再需要它们以防止内存泄漏时，从内存中删除任何动态创建的资源，因此，当您用完创建的缓冲区时，您应该使用{}{}{}buffer_delete(){}{}{}{}再次释放它。","{}{}IMPORTANT{}{}&nbsp;You cannot create buffers that are 2 Gibibytes ({}2,147,483,648 bytes) or larger.{}":"{}{} 重要信息{}{} 您无法创建 2 GB({}2,147,483,648 字节) 或更大的缓冲区。{}","{}{}NOTE{}{}&nbsp;Byte alignment can be very important as the wrong choice may adversely affect performance.":"{}{} 注意{}{} 字节对齐非常重要，因为错误的选择可能会对性能产生不利影响。","{}{}NOTE{}{}&nbsp;It's important that you remove any dynamically created resources like this from memory when you no longer need them to prevent memory leaks, so when you are finished with the buffer that you have created you should free it up again using {}{}buffer_delete{}{}.":"{}{} 注意{}{} 当不再需要此类动态创建的资源时，请务必将其从内存中删除，以防止内存泄漏，因此，当您使用完已创建的缓冲区时，应使用 {}{}buffer_delete{}{} 再次释放它。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.2.18.0_2"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>buffer_create</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference page for buffer_create"><meta name="rh-index-keywords" content="buffer_create,buffer_fixed,buffer_grow,buffer_wrap,buffer_fast,buffer_vbuffer"><meta name="search-keywords" content="buffer_create,buffer_fixed,buffer_grow,buffer_wrap,buffer_fast,buffer_vbuffer"><meta name="is_pure" content="true"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Buffers/buffer_create_from_vertex_buffer.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Buffers/buffer_exists.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="buffer_create"><span>buffer_create</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">buffer_create</span></h1><p>This function creates a new buffer and returns it.</p><p>The function allocates a portion of memory for the&nbsp;buffer, which&nbsp;can then be used to store different types of data (specified when you write to the buffer using the <span class="inline3_func"><a href="buffer_write.htm">buffer_write</a></span>,&nbsp;<span class="inline3_func"><a href="buffer_poke.htm">buffer_poke</a></span> or&nbsp;<span class="inline3_func"><a href="buffer_fill.htm">buffer_fill</a></span>&nbsp;function).</p><p>The following constants can be used to define the buffer type:</p><div data-conref="../../../assets/snippets/Table_Buffer_Type_Constant.hts"><table><colgroup><col><col></colgroup><tbody><tr><th colspan="2"><span data-keyref="Type_Constant_Buffer_Type"><a target="_blank" href="buffer_create.htm">Buffer Type Constant</a></span></th></tr><tr><th>Constant</th><th>Description</th></tr><tr><td><span class="inline">buffer_fixed</span></td><td>A buffer of fixed size.</td></tr><tr><td><span class="inline">buffer_grow</span></td><td>A buffer that will "grow" dynamically as data is added</td></tr><tr><td><span class="inline">buffer_wrap</span></td><td>A buffer where the data will "wrap". When the data being added reaches the limit of the buffer size, the overwrite will be placed back at the start of the buffer, and further writing will continue from that point.</td></tr><tr><td><span class="inline">buffer_fast</span></td><td>A special "stripped" buffer that is extremely fast to read/write to. Can only be used with <span class="inline">buffer_u8</span> <a href="buffer_write.htm">data types</a>, and <i>must</i> be 1 byte aligned.</td></tr></tbody></table></div><p>Apart from the buffer type, you will also have to set the <i>byte alignment</i> for the buffer. This value will vary depending on the data that you wish to store in the buffer, and in most cases a value of 1 is perfectly fine. However, be aware that for some operations a specific alignment is <i>essential</i>, and an incorrect alignment may cause errors (for further details on alignment see <a href="../../../Additional_Information/Guide_To_Using_Buffers.htm">Buffers</a>). The following is a general guide to show which values are most appropriate for each data type (when in doubt, use an alignment of 1):</p><ul class="colour"><li>Strings should be aligned to 1 byte.</li><li>Signed or unsigned 8bit integers can be aligned to any value, but note that for a fast buffer (see <span class="inline3_func"><a href="buffer_write.htm">buffer_write</a></span>) it <i>must</i> be aligned to 1.</li><li>Signed or unsigned 16bit integers should be aligned to 2 bytes.</li><li>Signed or unsigned 32bit integers should be aligned to 4 bytes.</li><li>Floats of up to 16bits should be aligned to 2 bytes.</li><li>Floats of up to 32bits should be aligned to 4 bytes.</li><li>Floats of up to 64bits should be aligned to 8 bytes.</li></ul><p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;Byte alignment can be very important as the wrong choice may adversely affect performance.</p><p class="note"><span data-conref="../../../assets/snippets/Tag_important.hts"><span class="important">IMPORTANT</span></span>&nbsp;You cannot create buffers that are 2 Gibibytes (<span>2,147,483,648 bytes) or larger.</span></p><div data-conref="../../../assets/snippets/Note_Buffer_Delete_Dynamic.hts"><p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;It's important that you remove any dynamically created resources like this from memory when you no longer need them to prevent memory leaks, so when you are finished with the buffer that you have created you should free it up again using <span class="inline3_func"><a href="buffer_delete.htm">buffer_delete</a></span>.</p></div><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">buffer_create</span>(size, type, alignment)</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>size</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The size (in bytes) of the buffer.</td></tr><tr><td>type</td><td><span data-keyref="Type_Constant_Buffer_Type"><a target="_blank" href="buffer_create.htm">Buffer Type Constant</a></span></td><td>The type of buffer to create (see the constants list above).</td></tr><tr><td>alignment</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The byte alignment for the buffer</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_ID_Buffer"><a target="_blank" href="buffer_create.htm">Buffer</a></span></p><p>&nbsp;</p><h4>Example:</h4><p class="code">player_buffer = <span data-field="title" data-format="default">buffer_create</span>(16384, buffer_fixed, 2);</p><p>The above code allocates 16384 bytes of memory to a buffer and returns the buffer, storing the reference to it in the variable <span class="inline2">player_buffer</span>&nbsp;for future use. The buffer is aligned to a two byte boundary.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="Buffers.htm">Buffers</a></div><div style="float:right">Next:&nbsp;<a href="buffer_create_from_vertex_buffer.htm">buffer_create_from_vertex_buffer</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>