<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,o){let n;n=o?e.attr(o):e.html();let s=t[removeHtml(n)];if(null!=s&&s.length){t=retHtml(n);let a=0;t&&t.forEach(function(e,t){var o=s.replace("{"+a+"}",e);s=o===s?s.replace("{}",e):o,a++}),o?e.attr(o,s):e.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"A position relative to the current read/write position":"相对于当前读/写位置的位置。","Buffer Seek Constant":"缓冲区寻道常量",'If the buffer is not of the "wrap" type, the seek will clamp to the beginning or end of the buffer, even when the offset would take the seek outside of the buffer limits.':'如果缓冲器不是"包裹"类型，则寻道将钳制到缓冲器的开始或结束，即使偏移将使寻道超出缓冲器限制。','If the buffer is of the "wrap" type and you offset past the end of the buffer, the seek position will also wrap.':'如果缓冲区是"包裹"类型，并且您偏移超过缓冲区的末端，则查找位置也将包裹。','The "offset" value is the offset (in bytes) to add to the given seek position, for example, if the base is relative and the offset is 4, then the buffer position will move along 4 bytes from its current position. Please note the following:':'"offset" 值是要添加到给定查找位置的偏移量 (以字节为单位)，例如，如果基数是相对的，并且偏移量为 4，则缓冲区位置将从其当前位置沿 4 个字节移动。请注意以下事项：','The "offset" value is the offset (in bytes) to add to the given seek position, for example, if the base is relative and the offset is 4, then the buffer position will move along 4 bytes from its current position. Please note the following: {} {}You can use negative values for the offset to seek back through the buffer as well as positive values.{} {}If the buffer is of the "wrap" type and you offset past the end of the buffer, the seek position will also wrap.{} {}If the buffer is not of the "wrap" type, the seek will clamp to the beginning or end of the buffer, even when the offset would take the seek outside of the buffer limits.{} {} ':'"offset" 值是添加到给定查找位置的偏移量 (以字节为单位)，例如，如果基址是相对的且偏移量为 4，则缓冲区位置将从当前位置移动 4 个字节。请注意以下事项：{}{} 您可以使用负值作为偏移量来在缓冲区中回溯，也可以使用正值。{}{} 如果缓冲区是 " 换行 " 类型，并且您的偏移量超过了缓冲区的末尾缓冲区中，查找位置也会换行。{}{} 如果缓冲区不是 " 换行 " 类型，则查找将固定到缓冲区的开头或结尾，即使偏移量会使查找超出缓冲区的范围缓冲区限制。{}{}',"The above code finds the start of the buffer stored in the variable {}buff{} then writes a series of signed 16bit integer values to it.":"上面的代码找到存储在变量 {}buff{} 中的缓冲区的开头，然后向其中写入一系列带符号的 16 位整数值。",'The above code finds the start of the buffer with the id stored in the variable "buff" them writes a series of signed 16bit integer values to it.':'上面的代码找到缓冲区的开始，ID存储在变量"buffe"中，它们向其写入一系列有符号的16位整数值。',"The base position to seek.":"寻求的基础位置。","The data offset value.":"数据偏移值。","The end of the buffer":"缓冲区的末端",'The following constants are accepted as the "base" argument for seeking to:':'接受以下常量作为"base"参数来寻求：',"The index of the buffer to use.":"要使用的缓冲区的索引。","The seek position is the offset (in bytes) from the start of the buffer where new values are {}written{}, and from where values are {}read{}. It also moves automatically when you read from or write to a buffer.":"查找位置是距 {} 写入 {} 新值和 {} 读取 {} 值的缓冲区开头的偏移量 (以字节为单位)。当您读取或写入缓冲区时，它也会自动移动。","The start of the buffer":"缓冲区的开始",'This function can be used to move through a buffer, finding the start, the end, or a position relative to that which was last used when reading or writing data. The "offset" value is the offset (in bytes) to add to the given seek position, for example, if the base is relative and the offset is 4, then the buffer position will move along 4 bytes from its current position. Please note the following:':'此函数可用于在缓冲区中移动，查找开始、结束或相对于上次读取或写入数据时使用的位置。"偏移量"值是要添加到给定寻道位置的偏移量(以字节为单位)，例如，如果基数是相对的，偏移量是4，则缓冲区位置将从其当前位置沿4字节移动。请注意以下事项：',"This function can be used to move through a buffer, finding the start, the end, or a position relative to that which was last used when reading or writing data. This seek position is where new values are written, and from where values are read. It also moves automatically when you read from or write to a buffer.":"此函数可用于在缓冲区中移动，在读取或写入数据时查找开始、结束或相对于上次使用的位置。该寻道位置是写入新值以及从中读取值的位置。当您从缓冲区读取或写入缓冲区时，它也会自动移动。","This function moves the seek position&nbsp;of a buffer, setting it relative to the start, end or current seek position (that which was last used when reading or writing data).":"此函数移动缓冲区的查找位置，将其设置为相对于开始、结束或当前查找位置 (读取或写入数据时最后使用的位置)。","Usage Notes":"使用说明","You can use negative values for the offset to seek back through the buffer as well as positive values.":"您可以使用偏移的负值通过缓冲区以及正值进行查找。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.2.18.0_9"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>buffer_seek</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference page for buffer_seek"><meta name="rh-index-keywords" content="buffer_seek,buffer_seek_start,buffer_seek_relative,buffer_seek_end"><meta name="search-keywords" content="buffer_seek,buffer_seek_start,buffer_seek_relative,buffer_seek_end"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Buffers/buffer_tell.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Buffers/buffer_fill.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="buffer_seek"><span>buffer_seek</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">buffer_seek</span></h1><p>This function moves the seek position&nbsp;of a buffer, setting it relative to the start, end or current seek position (that which was last used when reading or writing data).</p><p>The seek position is the offset (in bytes) from the start of the buffer where new values are <a href="buffer_write.htm">written</a>, and from where values are <a href="buffer_read.htm">read</a>. It also moves automatically when you read from or write to a buffer.</p><h3>Usage Notes</h3><ul class="Disc"><li>The "offset" value is the offset (in bytes) to add to the given seek position, for example, if the base is relative and the offset is 4, then the buffer position will move along 4 bytes from its current position. Please note the following:<ul><li>You can use negative values for the offset to seek back through the buffer as well as positive values.</li><li>If the buffer is of the "wrap" type and you offset past the end of the buffer, the seek position will also wrap.</li><li>If the buffer is not of the "wrap" type, the seek will clamp to the beginning or end of the buffer, even when the offset would take the seek outside of the buffer limits.</li></ul></li></ul><p>The following constants are accepted as the "base" argument for seeking to:</p><table><colgroup><col><col></colgroup><tbody><tr><th colspan="2"><span data-keyref="Type_Constant_Buffer_Seek"><a target="_blank" href="buffer_seek.htm">Buffer Seek Constant</a></span></th></tr><tr><th>Constant</th><th>Description</th></tr><tr><td><span class="inline">buffer_seek_start</span></td><td>The start of the buffer</td></tr><tr><td><span class="inline">buffer_seek_relative</span></td><td>A position relative to the current read/write position</td></tr><tr><td><span class="inline">buffer_seek_end</span></td><td>The end of the buffer</td></tr></tbody></table><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">buffer_seek</span>(buffer, base, offset);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>buffer</td><td><span data-keyref="Type_ID_Buffer"><a target="_blank" href="buffer_create.htm">Buffer</a></span></td><td>The buffer to use.</td></tr><tr><td>base</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The base position to seek.</td></tr><tr><td>offset</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The data offset value.</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span>&nbsp;(the new seek position)</p><p>&nbsp;</p><h4>Example:</h4><p class="code"><span data-field="title" data-format="default">buffer_seek</span>(buff, buffer_seek_start, 0);<br>buffer_write(buff, buffer_s16, 0);<br>buffer_write(buff, buffer_s16, x);<br>buffer_write(buff, buffer_s16, y);</p><p>The above code finds the start of the buffer stored in the variable <span class="inline2">buff</span> then writes a series of signed 16bit integer values to it.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="Buffers.htm">Buffers</a></div><div style="float:right">Next:&nbsp;<a href="buffer_tell.htm">buffer_tell</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>