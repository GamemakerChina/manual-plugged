<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(t){return t=(t=(t=(t=t.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(t){return t.match(/(<([^>]+)>)/gi)},setTranslator=function(t,e,o){let f;f=o?t.attr(o):t.html();let a=e[removeHtml(f)];if(null!=a&&a.length){e=retHtml(f);let n=0;e&&e.forEach(function(t,e){var o=a.replace("{"+n+"}",t);a=o===a?a.replace("{}",t):o,n++}),o?t.attr(o,a):t.html(a)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var t=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(t):($(".topic-header").append(t),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(t){return t.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"The above code first creates two buffers,&nbsp;{}buff1{} and {}buff2{}, both with a size of 2048 bytes. {}buff1{}&nbsp;is then filled with&nbsp;random bytes (type {}buffer_u8{}) using&nbsp;{}{}buffer_write{}{}&nbsp;and a {}repeat{} loop. {}irandom(255){}&nbsp;returns random values from 0 to 255, both inclusive. Finally the entire&nbsp;{}buff1{} is copied to {}buff2{}. Copying of the data starts at the start of {}buff1{} (as the&nbsp;{}src_offset{}&nbsp;parameter is 0). 2048 bytes (i.e. {}all{} bytes) are copied to the destination buffer {}buff2{}. Writing starts at the start, indicated by the {}dest_offset{} set to 0. After copying, {}buff2{} contains the exact same bytes as {}buff1{}&nbsp;(and so is identical).":"上面的代码首先创建两个缓冲区，{}buff1{} 和 {}buff2{}，大小都是 2048 字节。然后使用 {8}{9}buffer_write{10}{11} 和 {12}repeat{13} 循环，用随机字节 (类型 {}buffer_u8{}) 填充 {4}buff1{5}。{}irandom(255){} 返回 0 到 255 之间的随机值，包括 0 和 255。最后，将整个 {}buff1{} 复制到 {}buff2{}。数据复制从 {}buff1{} 开始 (因为 {}src_offset{} 参数为 0)。2048 字节 (即 {} 所有 {} 字节) 复制到目标缓冲区 {}buff2{}。写入从开始处开始，由设置为 0 的 {}dest_offset{} 指示。复制后，{}buff2{} 包含与 {}buff1{} 完全相同的字节 (因此完全相同)。",'The above code will copy the data stored in the buffer indexed in the variable "buff1", and then paste it into the buffer indexed in the variable "buff2", but offset by 2048 bytes.':'上述代码将复制存储在变量 "buff1" 中索引的缓冲区中的数据，然后将其粘贴到变量 "buff2" 中索引的缓冲区中，但偏移量2048年字节。',"The buffer to copy {}from{}.":"{} 从中复制 {} 的缓冲区。","The buffer to copy {}to{}.":"要复制到 {} 的缓冲区。","The data offset to start copying from (in bytes).":"开始复制的数据偏移量(以字节为单位)。","The index of the buffer to copy {}from{}.":"要从{}复制{}的缓冲区的索引。","The index of the buffer to copy {}to{}.":"要复制{}到{}的缓冲区索引。","The offset position to copy the data to (in bytes).":"要将数据复制到的偏移位置(以字节为单位)。","The size of the data to copy (in bytes).":"要复制的数据的大小(以字节为单位)。","This example initialises the buffers in the same way as Example 1, i.e. it creates two buffers of size 2048 and fills the first&nbsp;one with random bytes. It then defines an&nbsp;offset from which to start copying bytes from the first buffer {}buff1{} to the second buffer {}buff2{}. The number&nbsp;of bytes to copy (i.e. the {}length{}&nbsp;or the {}size{})&nbsp;is then calculated by subtracting the&nbsp;offset {}_offset{} from the total size&nbsp;of the buffer, retrieved using&nbsp;{}{}buffer_get_size{}{}. Finally, the contiguous block&nbsp;of bytes in&nbsp;{}buff1{}, starting at {}_offset{}&nbsp;is copied to {}buff2{}. It is copied to {}buff2{} at an offset of 0, so the byte in {}buff1{} at index {}_offset{} is copied to index 0 in {}buff2{}, the byte in {}buff1{} at index {}_offset+1{} ends up at index 1 in {}buff2{}, etc. This happens for a total&nbsp;of&nbsp;{}_size{} bytes.":"该示例以与示例 1 相同的方式初始化缓冲器，即它创建大小为 2048 的两个缓冲器，并用随机字节填充第一个缓冲器。然后定义一个偏移量，从该偏移量开始将字节从第一个缓冲区 {}buff 1{} 复制到第二个缓冲区 {}buff 2{}。要复制的字节数 (即 {} 长度 {} 或 {} 大小 {}) 然后通过从缓冲区的总大小中减去偏移 {}_offset{} 来计算，该缓冲区的总大小是使用 {}{}buffer_get_size{}{} 检索的。最后，{}buff 1{} 中从 {}_offset{} 开始的连续字节块被复制到 {}buff 2{}。它被复制到偏移量为 0 的 {}buff 2{} 中，因此 {}buff 1{} 中索引 {}_offset{} 处的字节被复制到 {}buff 2{} 中的索引 0，{}buff 1{} 中索引 {}_offset+1{} 处的字节在 {}buff 2{} 中的索引 1 处结束，依此类推。总共 {}_size{} 字节发生此情况。","This function can be used to copy a segment (or all) of the data stored in one buffer to another. When using two buffers and copying from one to the other, both buffers must have previously been created using the {}{}buffer_create(){}{} function (for example), and you can specify a data offset (in bytes) for the start point of the data to be copied from the source buffer relative to the start of the buffer, as well as another data offset to define the position to copy the data to in the destination buffer.":"此函数可用于将存储在一个缓冲区中的一段(或全部)数据复制到另一个缓冲区。使用两个缓冲区并从一个缓冲区复制到另一个时，两个缓冲区必须事先使用{}{}buffer_create (){}{}函数(例如)创建，并且您可以为要从源缓冲区复制的数据起点指定相对于缓冲区起点的数据偏移量(以字节为单位)，以及另一个数据偏移量来定义要将数据复制到的位置在目标缓冲区中。","This function copies a segment (or all) of the data stored in one buffer to another.":"此函数将存储在一个缓冲区中的一段 (或全部) 数据复制到另一个缓冲区。","When using two buffers and copying from one to the other, both buffers must have previously been created using the&nbsp;{}{}buffer_create{}{} function (for example), and you can specify a data offset (in bytes) for the start point of the data to be copied from the source buffer relative to the start of the buffer, as well as another data offset to define the position to copy the data to in the destination buffer.":"当使用两个缓冲区并从一个复制到另一个时，这两个缓冲区必须先前已使用{}{}buffer_create{}{}函数创建(例如)，并且可以指定数据偏移量(以字节为单位)相对于缓冲器的开始，以及另一数据偏移量，以定义在目的地缓冲器中要将数据复制到的位置。","{}NOTE{}: You cannot copy to the same buffer.":"{}注意{}：您不能复制到同一个缓冲区。","{}{}NOTE{}{}&nbsp;You cannot copy to the same buffer.":"{}{}注意{}{} 不能复制到同一缓冲区。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(t){json_global=t}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.2.18.0_20"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>buffer_copy</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference page for buffer_copy"><meta name="rh-index-keywords" content="buffer_copy"><meta name="search-keywords" content="buffer_copy"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Buffers/buffer_copy_stride.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Buffers/buffer_set_used_size.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="buffer_copy"><span>buffer_copy</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">buffer_copy</span></h1><p>This function copies a segment (or all) of the data stored in one buffer to another.</p><p>When using two buffers and copying from one to the other, both buffers must have previously been created using the&nbsp;<span class="inline3_func"><a href="buffer_create.htm">buffer_create</a></span> function (for example), and you can specify a data offset (in bytes) for the start point of the data to be copied from the source buffer relative to the start of the buffer, as well as another data offset to define the position to copy the data to in the destination buffer.</p><div data-conref="../../../assets/snippets/Note_Buffer_Copy_NoSame.hts"><p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;You cannot copy to the same buffer.</p></div><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">buffer_copy</span>(src_buffer, src_offset, size, dest_buffer, dest_offset);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>src_buffer</td><td><span data-keyref="Type_ID_Buffer"><a target="_blank" href="buffer_create.htm">Buffer</a></span></td><td>The buffer to copy <i>from</i>.</td></tr><tr><td>src_offset</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The data offset to start copying from (in bytes).</td></tr><tr><td>size</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The size of the data to copy (in bytes).</td></tr><tr><td>dest_buffer</td><td><span data-keyref="Type_ID_Buffer"><a target="_blank" href="buffer_create.htm">Buffer</a></span></td><td>The buffer to copy <i>to</i>.</td></tr><tr><td>dest_offset</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The offset position to copy the data to (in bytes).</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Void">N/A</span></p><p>&nbsp;</p><h4>Example 1: Copying an entire buffer's contents</h4><p class="code">buff1 = buffer_create(2048, buffer_grow, 1);<br>buff2 = buffer_create(2048, buffer_grow, 1);<br>repeat(2048)<br>{<br>&nbsp; &nbsp; buffer_write(buff1, buffer_u8, irandom(255));<br>}<br><span data-field="title" data-format="default">buffer_copy</span>(buff1, 0, 2048, buff2, 0);</p><p>The above code first creates two buffers,&nbsp;<span class="inline2">buff1</span> and <span class="inline2">buff2</span>, both with a size of 2048 bytes. <span class="inline2">buff1</span>&nbsp;is then filled with&nbsp;random bytes (type <span class="inline2">buffer_u8</span>) using&nbsp;<span class="inline3_func"><a href="buffer_write.htm">buffer_write</a></span>&nbsp;and a <a href="../../GML_Overview/Language_Features/repeat.htm">repeat</a> loop. <span class="inline2">irandom(255)</span>&nbsp;returns random values from 0 to 255, both inclusive. Finally the entire&nbsp;<span class="inline2">buff1</span> is copied to <span class="inline2">buff2</span>. Copying of the data starts at the start of <span class="inline2">buff1</span> (as the&nbsp;<span class="inline2">src_offset</span>&nbsp;parameter is 0). 2048 bytes (i.e. <em>all</em> bytes) are copied to the destination buffer <span class="inline2">buff2</span>. Writing starts at the start, indicated by the <span class="inline2">dest_offset</span> set to 0. After copying, <span class="inline2">buff2</span> contains the exact same bytes as <span class="inline2">buff1</span>&nbsp;(and so is identical).</p><p>&nbsp;</p><h4>Example 2: Copying from a buffer, starting at an offset</h4><p class="code">buff1 = buffer_create(2048, buffer_fixed, 1);<br>buff2 = buffer_create(2048, buffer_fixed, 1);<br>repeat(2048)<br>{<br>&nbsp; &nbsp; buffer_write(buff1, buffer_u8, irandom(255));<br>}<br>var _offset = 273;<br>var _size = buffer_get_size(buff1) - _offset;<br><span data-field="title" data-format="default">buffer_copy</span>(buff1, _offset, _size, buff2, 0);</p><p>This example initialises the buffers in the same way as Example 1, i.e. it creates two buffers of size 2048 and fills the first&nbsp;one with random bytes. It then defines an&nbsp;offset from which to start copying bytes from the first buffer <span class="inline2">buff1</span> to the second buffer <span class="inline2">buff2</span>. The number&nbsp;of bytes to copy (i.e. the <em>length</em>&nbsp;or the <em>size</em>)&nbsp;is then calculated by subtracting the&nbsp;offset <span class="inline2">_offset</span> from the total size&nbsp;of the buffer, retrieved using&nbsp;<span class="inline3_func"><a href="buffer_get_size.htm">buffer_get_size</a></span>. Finally, the contiguous block&nbsp;of bytes in&nbsp;<span class="inline2">buff1</span>, starting at <span class="inline2">_offset</span>&nbsp;is copied to <span class="inline2">buff2</span>. It is copied to <span class="inline2">buff2</span> at an offset of 0, so the byte in <span class="inline2">buff1</span> at index <span class="inline2">_offset</span> is copied to index 0 in <span class="inline2">buff2</span>, the byte in <span class="inline2">buff1</span> at index <span class="inline2">_offset+1</span> ends up at index 1 in <span class="inline2">buff2</span>, etc. This happens for a total&nbsp;of&nbsp;<span class="inline2">_size</span> bytes.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="Buffers.htm">Buffers</a></div><div style="float:right">Next:&nbsp;<a href="buffer_copy_stride.htm">buffer_copy_stride</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>