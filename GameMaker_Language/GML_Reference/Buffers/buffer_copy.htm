<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(t){return t=(t=(t=(t=t.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(t){return t.match(/(<([^>]+)>)/gi)},setTranslator=function(t,n,a){let e;e=a?t.attr(a):t.html();let l=n[removeHtml(e)];if(null!=l&&l.length){n=retHtml(e);let o=0;n&&n.forEach(function(t,n){var a=l.replace("{"+o+"}",t);l=a===l?l.replace("{}",t):a,o++}),a?t.attr(a,l):t.html(l)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){$(".header").length&&$(".header").append(`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`)},removeExtensionFromHash=function(t){return t.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")},$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption,blockquote").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption,.expandtext").each(function(){setTranslator($(this),json)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.2.18.0_20"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>buffer_copy</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference page for buffer_copy"><meta name="rh-index-keywords" content="buffer_copy"><meta name="search-keywords" content="buffer_copy"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Buffers/buffer_copy_stride.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Buffers/buffer_set_used_size.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="buffer_copy"><span>buffer_copy</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">buffer_copy</span></h1><p>This function copies a segment (or all) of the data stored in one buffer to another.</p><p>When using two buffers and copying from one to the other, both buffers must have previously been created using the&nbsp;<span class="inline3_func"><a href="buffer_create.htm">buffer_create</a></span> function (for example), and you can specify a data offset (in bytes) for the start point of the data to be copied from the source buffer relative to the start of the buffer, as well as another data offset to define the position to copy the data to in the destination buffer.</p><div data-conref="../../../assets/snippets/Note_Buffer_Copy_NoSame.hts"><p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;You cannot copy to the same buffer.</p></div><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">buffer_copy</span>(src_buffer, src_offset, size, dest_buffer, dest_offset);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>src_buffer</td><td><span data-keyref="Type_ID_Buffer"><a target="_blank" href="buffer_create.htm">Buffer</a></span></td><td>The buffer to copy <i>from</i>.</td></tr><tr><td>src_offset</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The data offset to start copying from (in bytes).</td></tr><tr><td>size</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The size of the data to copy (in bytes).</td></tr><tr><td>dest_buffer</td><td><span data-keyref="Type_ID_Buffer"><a target="_blank" href="buffer_create.htm">Buffer</a></span></td><td>The buffer to copy <i>to</i>.</td></tr><tr><td>dest_offset</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The offset position to copy the data to (in bytes).</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Void">N/A</span></p><p>&nbsp;</p><h4>Example 1: Copying an entire buffer's contents</h4><p class="code">buff1 = buffer_create(2048, buffer_grow, 1);<br>buff2 = buffer_create(2048, buffer_grow, 1);<br>repeat(2048)<br>{<br>&nbsp; &nbsp; buffer_write(buff1, buffer_u8, irandom(255));<br>}<br><span data-field="title" data-format="default">buffer_copy</span>(buff1, 0, 2048, buff2, 0);</p><p>The above code first creates two buffers,&nbsp;<span class="inline2">buff1</span> and <span class="inline2">buff2</span>, both with a size of 2048 bytes. <span class="inline2">buff1</span>&nbsp;is then filled with&nbsp;random bytes (type <span class="inline2">buffer_u8</span>) using&nbsp;<span class="inline3_func"><a href="buffer_write.htm">buffer_write</a></span>&nbsp;and a <a href="../../GML_Overview/Language_Features/repeat.htm">repeat</a> loop. <span class="inline2">irandom(255)</span>&nbsp;returns random values from 0 to 255, both inclusive. Finally the entire&nbsp;<span class="inline2">buff1</span> is copied to <span class="inline2">buff2</span>. Copying of the data starts at the start of <span class="inline2">buff1</span> (as the&nbsp;<span class="inline2">src_offset</span>&nbsp;parameter is 0). 2048 bytes (i.e. <em>all</em> bytes) are copied to the destination buffer <span class="inline2">buff2</span>. Writing starts at the start, indicated by the <span class="inline2">dest_offset</span> set to 0. After copying, <span class="inline2">buff2</span> contains the exact same bytes as <span class="inline2">buff1</span>&nbsp;(and so is identical).</p><p>&nbsp;</p><h4>Example 2: Copying from a buffer, starting at an offset</h4><p class="code">buff1 = buffer_create(2048, buffer_fixed, 1);<br>buff2 = buffer_create(2048, buffer_fixed, 1);<br>repeat(2048)<br>{<br>&nbsp; &nbsp; buffer_write(buff1, buffer_u8, irandom(255));<br>}<br>var _offset = 273;<br>var _size = buffer_get_size(buff1) - _offset;<br><span data-field="title" data-format="default">buffer_copy</span>(buff1, _offset, _size, buff2, 0);</p><p>This example initialises the buffers in the same way as Example 1, i.e. it creates two buffers of size 2048 and fills the first&nbsp;one with random bytes. It then defines an&nbsp;offset from which to start copying bytes from the first buffer <span class="inline2">buff1</span> to the second buffer <span class="inline2">buff2</span>. The number&nbsp;of bytes to copy (i.e. the <em>length</em>&nbsp;or the <em>size</em>)&nbsp;is then calculated by subtracting the&nbsp;offset <span class="inline2">_offset</span> from the total size&nbsp;of the buffer, retrieved using&nbsp;<span class="inline3_func"><a href="buffer_get_size.htm">buffer_get_size</a></span>. Finally, the contiguous block&nbsp;of bytes in&nbsp;<span class="inline2">buff1</span>, starting at <span class="inline2">_offset</span>&nbsp;is copied to <span class="inline2">buff2</span>. It is copied to <span class="inline2">buff2</span> at an offset of 0, so the byte in <span class="inline2">buff1</span> at index <span class="inline2">_offset</span> is copied to index 0 in <span class="inline2">buff2</span>, the byte in <span class="inline2">buff1</span> at index <span class="inline2">_offset+1</span> ends up at index 1 in <span class="inline2">buff2</span>, etc. This happens for a total&nbsp;of&nbsp;<span class="inline2">_size</span> bytes.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="Buffers.htm">Buffers</a></div><div style="float:right">Next:&nbsp;<a href="buffer_copy_stride.htm">buffer_copy_stride</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>