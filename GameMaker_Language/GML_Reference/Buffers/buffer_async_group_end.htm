<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,n){let o;o=n?e.attr(n):e.html();let s=t[removeHtml(o)];if(null!=s&&s.length){t=retHtml(o);let a=0;t&&t.forEach(function(e,t){var n=s.replace("{"+a+"}",e);s=n===s?s.replace("{}",e):n,a++}),n?e.attr(n,s):e.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"The above code first checks if the ID in the&nbsp;{}{}async_load{}{}&nbsp;DS map is the same as the one returned by the call to {}{}buffer_async_group_end{}{}, then checks the status of the callback and posts a debug message if there have been any issues.":"上面的代码首先检查 {}{}async_load{}{}DS 映射中的 ID 是否与调用 {}{}buffer_async_group_end{}{} 返回的 ID 相同，然后检查回调的状态并如果出现任何问题，则发布调试消息。",'The above code starts a buffer group then sets it to save out 4 files asynchronously. The group definition is then ended (at which point saving will begin), storing the ID of the function call in the variable "{}save_id{}". When the save is complete, the asynchronous Save/Load event will be triggered and you can parse the {}async_load{} map for the correct ID of the function, like this:':'上面的代码启动一个缓冲区组，然后将其设置为异步保存4个文件。然后结束组定义 (此时将开始保存)，将函数调用的ID存储在变量 "{}save_id{}" 中。保存完成后，将触发异步保存/加载事件，您可以解析{}async_load{}映射以获取函数的正确ID，如下所示:',"The above code starts a buffer group then sets it to save out 4 files asynchronously. The group definition is then ended (at which point saving will begin), storing the ID of the function call in the variable {}save_id{}. When the save is complete, the asynchronous&nbsp;{}Save / Load{} event will be triggered and you can parse the&nbsp;{}{}async_load{}{} map for the correct ID of the function, like this:":"上面的代码启动一个缓冲区组，然后将其设置为异步保存 4 个文件。然后组定义结束 (此时开始保存)，将函数调用的 ID 存储在变量 {}save_id{} 中。保存完成后，将触发异步 {}Save / Load{} 事件，您可以解析 {}{}async_load{}{} 映射以获取函数的正确 ID，如下所示：","The above code will first check the id of the DS map that has been created, then check the status of the callback, posting a debug message if there has been any issues.":"上面的代码将首先检查已创建的DS映射的id，然后检查回调的状态，如果有任何问题，则发布调试消息。","The {}buffer_async_group_end(){} function can be called from any event, and since it is asynchronous the callback can be almost instantaneous or could take several seconds. Calling the function is simple and would look something like this:":"{}buffer_async_group_end(){}函数可以从任何事件调用，由于它是异步的，所以回调可以几乎是瞬时的，或者可能需要几秒钟的时间。调用函数很简单，看起来如下：","The&nbsp;{}{}buffer_async_group_end{}{} function can be called from any event, and since it is asynchronous the callback can be almost instantaneous or could take several seconds. Calling the function is simple and would look something like this:":"{}{}buffer_async_group_end{}{} 函数可以从任何事件调用，并且由于它是异步的，因此回调几乎是瞬时的，也可能需要几秒钟的时间。调用该函数很简单，如下所示：","This function finishes the definition of a buffer async group.":"该函数完成缓冲区异步组的定义。","This function finishes the definition of a buffer async group. You must have previously called the function {}{}buffer_async_group_begin(){}{} to initiate the group, then call the function {}{}buffer_save_async(){}{} for each file that you wish to save out (or {}{}buffer_load_async(){}{} to load buffers). Finally you call this function, which will start the saving of the files. The function will return a unique ID value for the save, which can then be used in the {}Asynchronous Save / Load event{} to parse the results from the {}async_load{} DS map.":"此函数完成缓冲区异步组的定义。您必须先调用函数{}{}buffer_async_group_begin(){}{}来启动组，然后为要保存的每个文件调用函数{}{}buffer_save_async(){}{}(或{}{}buffer_load_async(){}{}加载缓冲区)。最后你调用这个函数，它将开始保存文件。函数将为保存返回唯一的ID值，然后可以在{}异步保存/加载事件{}中使用该值来解析来自{}async_load{}DS映射的结果。","You must have previously called the function&nbsp;{}{}buffer_async_group_begin{}{} to initiate the group, then call the function&nbsp;{}{}buffer_save_async{}{} for each file that you wish to save out (or&nbsp;{}{}buffer_load_async{}{} to load buffers). Finally you call this function, which will start the saving of the files. The function will return a unique ID value for the save, which can then be used in the {}Asynchronous Save / Load event{} to parse the results from the&nbsp;{}{}async_load{}{}&nbsp;DS map.":"您之前必须调用函数 {}{}buffer_async_group_begin{}{} 来启动该组，然后为您要保存的每个文件调用函数 {}{}buffer_save_async{}{}( 或 {}{}buffer_load_async{}{} 加载缓冲区)。最后调用此函数，它将开始保存文件。该函数将为保存返回一个唯一的 ID 值，然后可以在 {} 异步保存 / 加载事件 {} 中使用该值来解析 {}{}async_load{}{}DS 映射的结果。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.2.18.0_34"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>buffer_async_group_end</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference page for buffer_async_group_end"><meta name="rh-index-keywords" content="buffer_async_group_end"><meta name="search-keywords" content="buffer_async_group_end"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Buffers/buffer_get_surface.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Buffers/buffer_async_group_option.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="buffer_async_group_end"><span>buffer_async_group_end</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">buffer_async_group_end</span></h1><p>This function finishes the definition of a buffer async group.</p><p>You must have previously called the function&nbsp;<span class="inline3_func"><a href="buffer_async_group_begin.htm">buffer_async_group_begin</a></span> to initiate the group, then call the function&nbsp;<span class="inline3_func"><a href="buffer_save_async.htm">buffer_save_async</a></span> for each file that you wish to save out (or&nbsp;<span class="inline3_func"><a href="buffer_load_async.htm">buffer_load_async</a></span> to load buffers). Finally you call this function, which will start the saving of the files. The function will return a unique ID value for the save, which can then be used in the <a href="../../../The_Asset_Editors/Object_Properties/Async_Events/Save_Load.htm">Asynchronous Save / Load event</a> to parse the results from the&nbsp;<span class="inline2"><a href="../../GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span>&nbsp;DS map.</p><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">buffer_async_group_end</span>();</p><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_ID_Async_Event"><a target="_blank" href="../Asynchronous_Functions/Asynchronous_Functions.htm">Async Request ID</a></span></p><p>&nbsp;</p><h4>Example:</h4><p>The&nbsp;<span class="inline3_func"><span data-field="title" data-format="default">buffer_async_group_end</span></span> function can be called from any event, and since it is asynchronous the callback can be almost instantaneous or could take several seconds. Calling the function is simple and would look something like this:</p><p class="code">buffer_async_group_begin("SaveGame");<br>save1 = buffer_save_async(buff1, "Player_Save1.sav", 0, 16384);<br>save2 = buffer_save_async(buff2, "Player_Save2.sav", 0, 16384);<br>save3 = buffer_save_async(buff3, "Player_Save3.sav", 0, 16384);<br>save4 = buffer_save_async(buff4, "Player_Save4.sav", 0, 16384);<br>save_id = <span data-field="title" data-format="default">buffer_async_group_end</span>();</p><p>The above code starts a buffer group then sets it to save out 4 files asynchronously. The group definition is then ended (at which point saving will begin), storing the ID of the function call in the variable <span class="inline2">save_id</span>. When the save is complete, the asynchronous&nbsp;<a href="../../../The_Asset_Editors/Object_Properties/Async_Events/Save_Load.htm">Save / Load</a> event will be triggered and you can parse the&nbsp;<span class="inline2"><a href="../../GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span> map for the correct ID of the function, like this:</p><p class="code">if (ds_map_find_value(async_load, "id") == saveid)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;if (ds_map_find_value(async_load, "status") == false)<br>&nbsp; &nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_debug_message("Save failed!");<br>&nbsp; &nbsp; }<br>}</p><p>The above code first checks if the ID in the&nbsp;<span class="inline2"><a href="../../GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span>&nbsp;DS map is the same as the one returned by the call to <span class="inline3_func"><span data-field="title" data-format="default">buffer_async_group_end</span></span>, then checks the status of the callback and posts a debug message if there have been any issues.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Buffers.htm">Buffers</a></div><div style="float:right">Next:&nbsp;<a href="buffer_get_surface.htm">buffer_get_surface</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>