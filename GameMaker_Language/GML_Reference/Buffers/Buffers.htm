<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let n;n=a?e.attr(a):e.html();let r=t[removeHtml(n)];if(null!=r&&r.length){t=retHtml(n);let o=0;t&&t.forEach(function(e,t){var a=r.replace("{"+o+"}",e);r=a===r?r.replace("{}",e):a,o++}),a?e.attr(a,r):e.html(r)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"A buffer is a region of physical memory used to temporarily hold data while it is being moved from one place to another or manipulated in some way, for example you can use a buffer to hold packet data awaiting transmission over a network or for storing a packet that has been received over a network. {}GameMaker{} has a number of specific functions related to creating, modifying and loading/saving buffers, but before using them please note the following points:":"缓冲区是物理内存的一个区域，用于在数据从一个地方移动到另一个地方或以某种方式进行操作时临时保存数据，例如，您可以使用缓冲区来保存等待通过网络传输的数据包数据，或者用于存储通过网络接收到的数据包。{}GameMaker{}有许多与创建、修改和加载/保存缓冲区相关的特定函数，但在使用它们之前，请注意以下几点：","Async Groups":"异步组","Before using&nbsp;{}buffers{} please note the following points:&nbsp;":"在使用 {} 缓冲区 {} 之前，请注意以下几点：",Buffers:"缓冲区",Compression:"压缩",Encoding:"编码","Finally, you can also use special {}Vertex Buffers{} to create your own custom primitives or models, etc... You can find out more about these from the following section of the manual:":"最后，您还可以使用特殊的{}顶点缓冲区{}来创建自己的自定义原语或模型等...您可以从手册的以下部分中找到有关这些内容的更多信息:","Function Reference":"功能参考",General:"常规","Hashes &amp; Checksums":"哈希值和校验和","Loading &amp; Saving":"装载 和 保存","Loading &amp; Saving Game States":"加载 和 保存游戏状态","Primitive Building":"基元创建","Some of the buffer functions also create a new buffer (like {}buffer_load{} for example). Remember that these buffers will also need to be removed from memory when not in use using the {}buffer_delete{} function.":"一些缓冲区函数还创建了一个新的缓冲区 (例如{}buffer_load{})。请记住，当不使用{}buffer_delete{}函数时，还需要从内存中删除这些缓冲区。","Some of the buffer functions also create a new buffer (like&nbsp;{}{}buffer_load{}{} for example). Remember that these buffers will also need to be removed from memory when not in use using the&nbsp;{}{}buffer_delete{}{} function.":"一些 buffer 函数也会创建一个新的 buffer(例如 {}{}buffer_load{}{})。请记住，这些缓冲区在不使用时也需要使用 {}{}buffer_delete{}{} 函数从内存中删除。",Surfaces:"表面","The \"Alignment\" argument refers to how data is stored within a buffer. If your alignment is set to say, 4, and you write a single piece of data which is 1 byte in size then do a {}buffer_tell{}, you'll get an offset of 1. However, if you write another piece of data, also 1 byte in size, then do a {}buffer_tell{}, you'll get an offset of 5 as the alignment has \"padded\" the data to that size. Alignment only affects {}where{} things are written to, so if you do a {}buffer_tell{} after you write something, it'll return the current write position which immediately follows the data you've written. Note, however, that if you then write another piece of data, internally the buffer will move the write position along to the next multiple of the alignment size before actually writing the piece of data.":'"Alignment" 参数是指数据在缓冲区中的存储方式。如果你的对齐设置为 4，并且你写了一段大小为 1 字节的数据，然后执行{}buffer_tell{}，你的偏移量将为 1。但是，如果您再写一段数据，大小也是 1 字节，然后执行{}buffer_tell{}，则偏移量为 5，因为对齐已将数据 "填充" 到该大小。对齐仅影响写入{}内容的{}处，因此，如果您在写入内容后执行{}buffer_tell{}，它将返回紧随您写入的数据的当前写入位置。但是请注意，如果您随后写入另一段数据，则在实际写入该数据之前，缓冲区内部会将写入位置移动到对齐大小的下一个倍数。',"The \"Alignment\" argument refers to how data is stored within a buffer. If your alignment is set to say, 4, and you write a single piece of data which is 1 byte in size then do a {}{}buffer_tell{}{}, you'll get an offset of 1. However, if you write another piece of data, also 1 byte in size, then do a {}{}buffer_tell{}{}, you'll get an offset of 5 as the alignment has \"padded\" the data to that size. Alignment only affects {}where{} things are written to, so if you do a&nbsp;{}{}buffer_tell{}{}&nbsp;after you write something, it'll return the current write position which immediately follows the data you've written. Note, however, that if you then write another piece of data, internally the buffer will move the write position along to the next multiple of the alignment size before actually writing the piece of data.":'"对齐"参数是指数据如何存储在缓冲区内。如果你的对齐设置为 4，你写了一个 1 字节大小的数据，然后执行 {}{}buffer_tell{}{}，你会得到一个偏移量 1。但是，如果您写入另一段数据，也是 1 字节大小，然后执行 {}{}buffer_tell{}{}，您将获得偏移量 5，因为对齐已将数据 " 填充 " 到该大小。对齐只影响 {} 写入 {} 的位置，所以如果你在写入内容后执行 {}{}buffer_tell{}{}，它将返回当前写入位置，紧跟在你写入的数据之后。但是，请注意，如果您随后写入另一段数据，则在实际写入该数据段之前，缓冲区将在内部将写入位置移动到对齐大小的下一个倍数。',"The \"alignment\" argument refers to how data is stored within a buffer. If your alignment is set to say, 4, and you write a single piece of data which is 1 byte in size then do a {}{}buffer_tell{}{}, you'll get an offset of 1. However, if you write another piece of data, also 1 byte in size, then do a {}{}buffer_tell{}{}, you'll get an offset of 5 as the alignment has \"padded\" the data to that size. Alignment only affects {}where{} things are written to, so if you do a&nbsp;{}{}buffer_tell{}{}&nbsp;after you write something, it'll return the current write position which immediately follows the data you've written. Note, however, that if you then write another piece of data, internally the buffer will move the write position along to the next multiple of the alignment size before actually writing the piece of data.":'"对齐 " 参数是指数据如何存储在缓冲区内。如果您的对齐方式设置为 4，并且您写入大小为 1 字节的单条数据，然后执行 {}{}buffer_tell{}{}，您将获得偏移量 1。但是，如果您写入另一条数据，大小也是 1 字节，然后执行 {}{}buffer_tell{}{}，您将获得偏移量 5，因为对齐已将数据 " 填充 " 到该大小。对齐仅影响写入内容的 {} 位置 {}，因此，如果您在写入内容后执行 {}{}buffer_tell{}{}，它将返回紧随您写入的数据之后的当前写入位置。但请注意，如果您随后写入另一条数据，则在实际写入该数据之前，缓冲区内部会将写入位置移动到对齐大小的下一个倍数。','The "size" argument of the buffer functions always refers to the size {}in bytes{} of the buffer.':'缓冲区函数的 "大小" 参数总是指缓冲区的大小{}(以字节为单位)。',"The following functions exist for you to use with binary buffers in your games:":"以下函数可供您在游戏中与二进制缓冲区一起使用:","The following pages explain how buffers work within the context of {}GameMaker{} and contain a couple of code examples for those users that are unsure of how to use them:":"以下页面解释了缓冲区如何在{}GameMaker{}的上下文中工作，并为那些不确定如何使用它们的用户提供了几个代码示例:","The memory used for creating buffers is {}system memory{} so even when the game doesn't have focus, any data stored in a buffer should be safe, however if the app is closed or re-started then it will be lost.":"用于创建缓冲区的内存是{}系统内存{}所以即使游戏没有焦点，存储在缓冲区中的任何数据都应该是安全的，但是如果应用程序关闭或重新启动，它将丢失。","The memory used for creating buffers is {}system memory{} so even when the game doesn't have focus, any data stored in a buffer should be safe, however if the app is closed or restarted then it will be lost.":"用于创建缓冲区的内存是 {} 系统内存 {}，因此即使游戏没有焦点，存储在缓冲区中的任何数据也应该是安全的，但如果应用关闭或重新启动，这些数据就会丢失。","There are also two extra functions related to buffers that can be used to save and load game states (note that they require a buffer to have been created previously):":"还有两个与缓冲区相关的额外函数，可用于保存和加载游戏状态 (请注意，它们需要以前创建的缓冲区):","Transferring Data Between Buffers":"在缓冲区之间传输数据","Usage Notes":"使用说明","Using Buffers":"使用缓冲区","When a buffer is created, it is automatically cleared and filled to 0.":"创建缓冲区时，它会自动清除并填充为0。",'When dealing with "offset", this is the value {}in bytes{} to offset the data by within the given buffer. So if your buffer is 2 byte aligned and you want to skip the first 4 aligned places, you would have an offset of {}2 * 4 bytes{}.':'当处理 "offset" 时，这是字节{}中的值{}，用于在给定缓冲区内偏移数据。因此，如果您的缓冲区是2字节对齐的，并且您想跳过前4个对齐位置，则您的偏移量为{}2*4字节{}。',"{}GameMaker{} has a number of specific functions related to creating, modifying and loading/saving buffers. A buffer is a region of physical memory used to temporarily hold data while it's being moved from one place to another or manipulated in some way. For example, you can use a buffer to hold packet data awaiting transmission over a network or for storing a packet that has been received over a network.":"{}GameMaker{} 具有许多与创建、修改和加载 / 保存缓冲区相关的特定函数。缓冲区是物理内存的一个区域，用于在数据从一个位置移动到另一个位置或以某种方式进行操作时临时保存数据。例如，您可以使用缓冲区来保存等待通过网络传输的数据包数据或存储已通过网络接收的数据包。","{}{}IMPORTANT!{}{} When you create a buffer, the index value used to identify it is an integer value starting at 0. These indices are re-used by GameMaker, so a destroyed buffer index value may be used by a newly created one afterwards, and we recommend that you set any variable that holds a buffer&nbsp;index to -1 after having destroyed the buffer.":"{}{}重要!{}{}创建缓冲区时，用于标识缓冲区的索引值是从0开始的整数值。这些索引由GameMaker重新使用，因此在之后新创建的缓冲区索引值可能会使用已销毁的缓冲区索引值，我们建议您在已销毁缓冲区后将任何保存缓冲区索引的变量设置为-1。","{}{}IMPORTANT{}{} When you create a buffer, a reference to&nbsp;the new buffer is returned. After the buffer is destroyed, we recommend that you set the variable that holds a buffer&nbsp;reference to {}-1{}.":"{}{} 重要信息{}{} 创建缓冲区时，会返回对新缓冲区的引用。缓冲区被销毁后，我们建议您将保存缓冲区引用的变量设置为 {}-1{}。","{}{}IMPORTANT{}{} When you create a buffer, the index value used to identify it is an integer value starting at 0. These indices are re-used by {}GameMaker{}, so a destroyed buffer index value may be used by a newly created one afterwards, and we recommend that you set any variable that holds a buffer&nbsp;index to -1 after having destroyed the buffer.":"{}{} 重要{}{} 创建缓冲区时，用于标识缓冲区的索引值是从 0 开始的整数值。这些索引由 {}GameMaker{} 重复使用，因此已销毁的缓冲区索引值可能会被新创建的缓冲区索引值使用，我们建议您在销毁缓冲区后将保存缓冲区索引的任何变量设置为 -1。","{}{}NOTE{}{}&nbsp;These functions require a buffer to have been created previously.":"{}{} 注意{}{} 这些函数需要之前创建一个缓冲区。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.2.18"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Buffers</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference section for the Buffer functions"><meta name="rh-index-keywords" content="Buffers"><meta name="search-keywords" content="Buffers"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Buffers/buffer_exists.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/File_Handling/Encoding_And_Hashing/zip_save.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Buffers"><span>Buffers</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Buffers</span></h1><p><span data-keyref="GameMaker Name">GameMaker</span> has a number of specific functions related to creating, modifying and loading/saving buffers. A buffer is a region of physical memory used to temporarily hold data while it's being moved from one place to another or manipulated in some way. For example, you can use a buffer to hold packet data awaiting transmission over a network or for storing a packet that has been received over a network.</p><h3>Usage Notes</h3><p>Before using&nbsp;<span data-field="title" data-format="lower-alpha">buffers</span> please note the following points:&nbsp;</p><ul class="colour"><li>When a buffer is created, it is automatically cleared and filled to 0.</li><li>The "size" argument of the buffer functions always refers to the size <i>in bytes</i> of the buffer.</li><li>The "alignment" argument refers to how data is stored within a buffer. If your alignment is set to say, 4, and you write a single piece of data which is 1 byte in size then do a <span class="inline3_func"><a href="buffer_tell.htm">buffer_tell</a></span>, you'll get an offset of 1. However, if you write another piece of data, also 1 byte in size, then do a <span class="inline3_func"><a href="buffer_tell.htm">buffer_tell</a></span>, you'll get an offset of 5 as the alignment has "padded" the data to that size. Alignment only affects <i>where</i> things are written to, so if you do a&nbsp;<span class="inline3_func"><a href="buffer_tell.htm">buffer_tell</a></span>&nbsp;after you write something, it'll return the current write position which immediately follows the data you've written. Note, however, that if you then write another piece of data, internally the buffer will move the write position along to the next multiple of the alignment size before actually writing the piece of data.</li><li>When dealing with "offset", this is the value <i>in bytes</i> to offset the data by within the given buffer. So if your buffer is 2 byte aligned and you want to skip the first 4 aligned places, you would have an offset of <span class="inline">2 * 4 bytes</span>.</li><li>Some of the buffer functions also create a new buffer (like&nbsp;<span class="inline3_func"><a href="buffer_load.htm">buffer_load</a></span> for example). Remember that these buffers will also need to be removed from memory when not in use using the&nbsp;<span class="inline3_func"><a href="buffer_delete.htm">buffer_delete</a></span> function.</li><li>The memory used for creating buffers is <i>system memory</i> so even when the game doesn't have focus, any data stored in a buffer should be safe, however if the app is closed or restarted then it will be lost.</li></ul><p>The following pages explain how buffers work within the context of <span data-keyref="GameMaker Name">GameMaker</span> and contain a couple of code examples for those users that are unsure of how to use them:</p><ul class="colour"><li><a href="../../../Additional_Information/Guide_To_Using_Buffers.htm">Using Buffers</a></li><li><a href="Transferring_Data_Between_Buffers.htm">Transferring Data Between Buffers</a></li></ul><p class="note"><span data-conref="../../../assets/snippets/Tag_important.hts"><span class="important">IMPORTANT</span></span> When you create a buffer, a reference to&nbsp;the new buffer is returned. After the buffer is destroyed, we recommend that you set the variable that holds a buffer&nbsp;reference to <span class="inline2">-1</span>.</p><h2 id="func_ref">Function Reference</h2><h3 id="func_ref_general">General</h3><ul class="colour"><li><a href="buffer_exists.htm">buffer_exists</a></li><li><a href="buffer_create.htm">buffer_create</a></li><li><a href="buffer_create_from_vertex_buffer.htm">buffer_create_from_vertex_buffer</a></li><li><a href="buffer_create_from_vertex_buffer_ext.htm">buffer_create_from_vertex_buffer_ext</a></li><li><a href="buffer_delete.htm">buffer_delete</a></li><li><a href="buffer_read.htm">buffer_read</a></li><li><a href="buffer_write.htm">buffer_write</a></li><li><a href="buffer_fill.htm">buffer_fill</a></li><li><a href="buffer_seek.htm">buffer_seek</a></li><li><a href="buffer_tell.htm">buffer_tell</a></li><li><a href="buffer_peek.htm">buffer_peek</a></li><li><a href="buffer_poke.htm">buffer_poke</a></li><li><a href="buffer_get_type.htm">buffer_get_type</a></li><li><a href="buffer_get_alignment.htm">buffer_get_alignment</a></li><li><a href="buffer_get_address.htm">buffer_get_address</a></li><li><a href="buffer_get_size.htm">buffer_get_size</a></li><li><a href="buffer_resize.htm">buffer_resize</a></li><li><a href="buffer_sizeof.htm">buffer_sizeof</a></li><li><a href="buffer_set_used_size.htm">buffer_set_used_size</a></li><li><a href="buffer_copy.htm">buffer_copy</a></li><li><a href="buffer_copy_stride.htm">buffer_copy_stride</a></li><li><a href="buffer_copy_from_vertex_buffer.htm">buffer_copy_from_vertex_buffer</a></li></ul><h3>Loading &amp; Saving</h3><ul class="colour"><li><a href="buffer_save.htm">buffer_save</a></li><li><a href="buffer_save_ext.htm">buffer_save_ext</a></li><li><a href="buffer_save_async.htm">buffer_save_async</a></li><li><a href="buffer_load.htm">buffer_load</a></li><li><a href="buffer_load_ext.htm">buffer_load_ext</a></li><li><a href="buffer_load_async.htm">buffer_load_async</a></li><li><a href="buffer_load_partial.htm">buffer_load_partial</a></li></ul><h3>Compression</h3><ul class="colour"><li><a href="buffer_compress.htm">buffer_compress</a></li><li><a href="buffer_decompress.htm">buffer_decompress</a></li></ul><h3>Async Groups</h3><ul class="colour"><li><a href="buffer_async_group_begin.htm">buffer_async_group_begin</a></li><li><a href="buffer_async_group_option.htm">buffer_async_group_option</a></li><li><a href="buffer_async_group_end.htm">buffer_async_group_end</a></li></ul><h3>Surfaces</h3><ul class="colour"><li><a href="buffer_get_surface.htm">buffer_get_surface</a></li><li><a href="buffer_set_surface.htm">buffer_set_surface</a></li></ul><h3>Hashes &amp; Checksums</h3><ul class="colour"><li><a href="buffer_md5.htm">buffer_md5</a></li><li><a href="buffer_sha1.htm">buffer_sha1</a></li><li><a href="buffer_crc32.htm">buffer_crc32</a></li></ul><h3>Encoding</h3><ul class="colour"><li><a href="buffer_base64_encode.htm">buffer_base64_encode</a></li><li><a href="buffer_base64_decode.htm">buffer_base64_decode</a></li><li><a href="buffer_base64_decode_ext.htm">buffer_base64_decode_ext</a></li></ul><h3 id="func_ref_loading_saving">Loading &amp; Saving Game States</h3><p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;These functions require a buffer to have been created previously.</p><ul class="colour"><li><a href="../General_Game_Control/game_load_buffer.htm">game_load_buffer</a></li><li><a href="../General_Game_Control/game_save_buffer.htm">game_save_buffer</a></li></ul><h3>Vertex Buffers</h3><ul class="colour"><li><a href="../Drawing/Primitives/Primitives_And_Vertex_Formats.htm">Primitive Building</a></li></ul><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../GML_Reference.htm">GML Reference</a></div><div style="float:right">Next:&nbsp;<a href="../OS_And_Compiler/OS_And_Compiler.htm">OS And Compiler</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>