<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let n;n=a?e.attr(a):e.html();let r=t[removeHtml(n)];if(null!=r&&r.length){t=retHtml(n);let o=0;t&&t.forEach(function(e,t){var a=r.replace("{"+o+"}",e);r=a===r?r.replace("{}",e):a,o++}),a?e.attr(a,r):e.html(r)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"A buffer of fixed size.":"固定大小的缓冲区。",'A buffer that will "grow" dynamically as data is added':'一个缓冲区，将在添加数据时动态 "增长"','A buffer where the data will "wrap". When the data being added reaches the limit of the buffer size, the overwrite will be placed back at the start of the buffer, and further writing will continue from that point.':'数据将 "换行" 的缓冲区。当正在添加的数据达到缓冲区大小的限制时，覆盖将被放回缓冲区的开始处，并且进一步的写入将从该点继续。',"A reference to the vertex buffer to use.":"对要使用的顶点缓冲区的引用。",'A special "stripped" buffer that is extremely fast to read/write to. Can only be used with {}buffer_u8{} {}data types{}, and {}must{} be 1 byte aligned.':'一种特殊的 " 剥离 " 缓冲区，读 / 写速度极快。只能与 {}buffer_u8{}{} 数据类型 {} 一起使用，并且 {} 必须 {} 按 1 字节对齐。',"Apart from the buffer type, you will also have to set the {}byte alignment{} for the buffer. This value will vary depending on the data that you wish to store in the buffer, and in most cases a value of 1 is perfectly fine. However, be aware that for some operations a specific alignment is {}essential{}, and an incorrect alignment may cause errors (for further details on alignment see {}Buffer Alignment{}). The following is a general guide to show which values are most appropriate for each data type (when in doubt, use an alignment of 1):":"除了缓冲区类型外，您还必须为缓冲区设置{}字节对齐{}。该值将根据您希望存储在缓冲区中的数据而有所不同，在大多数情况下，值为 1 是完全正确的。但是请注意，对于某些操作，特定的对齐是{}必不可少的{}，不正确的对齐可能会导致错误(有关对齐的更多详细信息，请参阅{}缓冲区对齐{})。以下是显示哪些值最适合每种数据类型的通用指南(如有疑问，请使用 1 的对齐方式)：","Buffer Type Constant":"缓冲区类型常数","Floats of up to 16bits should be aligned to 2 bytes. {}(Not currently supported!){}":"最多 16 位的浮点数应与 2 字节对齐。{}(目前不支持！){}","Floats of up to 32bits should be aligned to 4 bytes.":"最多 32 位的浮点数应与 4 字节对齐。","Floats of up to 64bits should be aligned to 8 bytes.":"最多 64 位的浮点数应与 8 字节对齐。","Signed or unsigned 16bit integers should be aligned to 2 bytes.":"有符号或无符号的 16 位整数应与 2 字节对齐。","Signed or unsigned 32bit integers should be aligned to 4 bytes":"有符号或无符号的 32 位整数应与 4 字节对齐","Signed or unsigned 8bit integers can be aligned to any value, but note that for a fast buffer (see {}{}buffer_write(){}{}) it {}must{} be aligned to 1.":"有符号或无符号的 8 位整数可以与任何值对齐，但请注意，对于快速缓冲区(参见{}{}buffer_write (){}{})，它{}必须{}与 1 对齐。","Signed or unsigned 8bit integers can be aligned to any value, but note that for a fast buffer (see {}{}buffer_write{}{}) it {}must{} be aligned to 1.":"有符号或无符号 8 位整数可以与任何值对齐，但请注意，对于快速缓冲区 (请参阅 {}{}buffer_write{}{})，它 {} 必须 {} 与 1 对齐。",'Special "stripped" buffer that is extremely fast to read/write to. Can only be used with {}buffer_u8{} {}data types{}, and {}must{} be 1 byte aligned.':'特殊的 "已剥离" 缓冲区，读取/写入速度极快。只能与{}buffer_u8{}{}数据类型{}一起使用，{}必须{}以 1 字节对齐。',"Strings should be aligned to 1 byte.":"字符串应与 1 字节对齐。",'The above code allocates memory to a buffer then copies the data of all vertices from the given vertex buffer into it, returning the index of the new buffer which is stored in the variable "player_buffer", for future use.':'上面的代码为缓冲区分配内存，然后将给定顶点缓冲区中所有顶点的数据复制到缓冲区中，返回存储在变量 "player_buffer" 中的新缓冲区的索引，以备将来使用。',"The above code allocates memory to a buffer then copies the data of all vertices from the given vertex buffer into it, returning the new buffer. It is stored in the variable {}player_buffer{}&nbsp;for future use.":"上面的代码将内存分配给缓冲区，然后将给定顶点缓冲区中所有顶点的数据复制到其中，返回新缓冲区。它存储在变量 {}player_buffer{} 中以供将来使用。","The byte alignment for the buffer":"缓冲区的字节对齐方式","The byte alignment for the buffer.":"缓冲区的字节对齐方式。","The final two arguments are used to specify the range of vertex data that you wish to copy into the newly created buffer. The start vertex can be anywhere between 0 and the number of vertices -1, and then you give the number of vertices from that point to copy. You can use the function {}{}vertex_get_number(){}{}&nbsp;on the vertex buffer to get the total number of vertices stored.":"最后两个参数用于指定要复制到新创建的缓冲区的顶点数据的范围。起始顶点可以介于 0 和顶点数 1 之间的任何位置，然后你给出从该点开始复制的顶点数。你可以使用顶点缓冲区上的函数{}{}vertex_get_number(){}来获取存储的顶点总数。","The final two arguments are used to specify the range of vertex data that you wish to copy into the newly created buffer. The start vertex can be anywhere between 0 and the number of vertices -1, and then you give the number of vertices from that point to copy. You can use the function&nbsp;{}{}vertex_get_number{}&nbsp;{}on the vertex buffer to get the total number of vertices stored.":"最后两个参数用于指定要复制到新创建的缓冲区中的顶点数据的范围。起始顶点可以是 0 到顶点数 -1 之间的任意位置，然后给出从该点开始复制的顶点数。您可以在顶点缓冲区上使用函数 {}{}vertex_get_number{}{} 来获取存储的顶点总数。","The function returns a reference to the buffer&nbsp;that should be stored in a variable and used for all further function calls to the buffer. The function takes a reference to the vertex buffer to use (as returned by the function {}{}vertex_create_buffer{}{}, for example) with the following constants being used to define the buffer type:":"该函数返回对缓冲区的引用，该引用应存储在变量中并用于对缓冲区的所有进一步函数调用。该函数获取要使用的顶点缓冲区的引用 (例如，由函数 {}{}vertex_create_buffer{}{} 返回)，并使用以下常量来定义缓冲区类型：","The starting vertex.":"起始顶点。","The total number of vertices to copy.":"要复制的顶点总数。","The type of buffer to create (see the constants list below).":"要创建的缓冲区的类型(参见下面的常量列表)。","The vertex buffer index to use.":"要使用的顶点缓冲区索引。","This function allocates a portion of memory as a buffer in your game and fills it with the vertex data of a range of vertices from a previously created {}vertex buffer{}.":"此函数分配一部分内存作为游戏中的缓冲区，并使用之前创建的 {} 顶点缓冲区 {} 中一系列顶点的顶点数据填充它。","This type of buffer is to be used as a vertex buffer only.":"这种类型的缓冲区只能用作顶点缓冲区。","You use this function to allocate a portion of memory as a buffer in your game filled with the data from a previously created {}vertex buffer{}. The function returns a unique {}buffer id{} that should be stored in a variable and used for all further function calls to the buffer. The function takes the id for the vertex buffer to use (as returned by the function {}{}vertex_create_buffer(){}{}, for example) with the following constants being used to define the buffer type:":"您可以使用此函数在游戏中分配一部分内存作为缓冲区，其中包含来自先前创建的{}顶点缓冲区{}的数据。该函数返回一个唯一的{}缓冲区id{}，该id应存储在变量中，并用于对缓冲区的所有其他函数调用。该函数采用要使用的顶点缓冲区的id (如函数{}{}vertex_create_buffer(){}{}, 例如)，其中以下常量用于定义缓冲区类型:","{}NOTE{}: It's important that you remove any dynamically created resources like this from memory when you no longer need them to prevent memory leaks, so when you are finished with the buffer that you have created you should free it up again using {}{}{}buffer_delete(){}{}{}. Also note that the vertex buffer used to create the new buffer is not removed from memory either and you should use the function {}{}{}vertex_delete_buffer(){}{}{} when it is no longer required.":"{}注意{}：当您不再需要此类动态创建的资源时，请务必将其从内存中移除，以防止内存泄漏，因此，当您完成创建的缓冲区后，应使用{}{}{}buffer_delete(){}{}{}再次将其释放。另请注意，用于创建新缓冲区的顶点缓冲区也不会从内存中移除，当不再需要函数时，应使用函数{}{}{}vertex_delete_buffer(){}{}{}。","{}NOTE{}: Vertex buffers are 1 byte aligned, but you can create the buffer with any alignment depending on how you want to treat the data, as the vertex data is simply a raw memory copy into the buffer.":"{}注意{}：顶点缓冲区是 1 字节对齐的，但你可以根据你想要如何处理数据来创建任意对齐的缓冲区，因为顶点数据只是缓冲区的原始内存副本。","{}{}NOTE{}{}&nbsp;It's important that you remove any dynamically created resources like this from memory when you no longer need them to prevent memory leaks, so when you are finished with the buffer that you have created you should free it up again using {}{}buffer_delete{}{}.":"{}{} 注意{}{} 当您不再需要此类动态创建的资源时，请务必将其从内存中删除，以防止内存泄漏，因此当您使用完创建的缓冲区后，应将其释放再次使用 {}{}buffer_delete{}{}。","{}{}{}NOTE{}{}{} Vertex buffers are 1 byte aligned, but you can create the buffer with any alignment depending on how you want to treat the data, as the vertex data is simply a raw memory copy into the buffer.":"{}{}{} 注意{}{}{} 顶点缓冲区是 1 字节对齐的，但您可以根据您想要如何处理数据来创建具有任何对齐方式的缓冲区，因为顶点数据只是原始内存复制到缓冲区。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.2.18.0_4"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>buffer_create_from_vertex_buffer_ext</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference page for buffer_create_from_vertex_buffer_ext"><meta name="rh-index-keywords" content="buffer_create_from_vertex_buffer_ext"><meta name="search-keywords" content="buffer_create_from_vertex_buffer_ext,buffer_fixed,buffer_grow,buffer_wrap,buffer_fast,buffer_vbuffer"><meta name="is_pure" content="true"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Buffers/buffer_delete.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Buffers/buffer_create_from_vertex_buffer.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="buffer_create_from_vertex_buffer_ext"><span>buffer_create_from_vertex_buffer_ext</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">buffer_create_from_vertex_buffer_ext</span></h1><p>This function allocates a portion of memory as a buffer in your game and fills it with the vertex data of a range of vertices from a previously created <a href="../Drawing/Primitives/Primitives_And_Vertex_Formats.htm">vertex buffer</a>.</p><p>The function returns a reference to the buffer&nbsp;that should be stored in a variable and used for all further function calls to the buffer. The function takes a reference to the vertex buffer to use (as returned by the function <span class="inline3_func"><a href="../Drawing/Primitives/vertex_create_buffer.htm">vertex_create_buffer</a></span>, for example) with the following constants being used to define the buffer type:</p><div data-conref="../../../assets/snippets/Table_Buffer_Type_Constant.hts"><table><colgroup><col><col></colgroup><tbody><tr><th colspan="2"><span data-keyref="Type_Constant_Buffer_Type"><a target="_blank" href="buffer_create.htm">Buffer Type Constant</a></span></th></tr><tr><th>Constant</th><th>Description</th></tr><tr><td><span class="inline">buffer_fixed</span></td><td>A buffer of fixed size.</td></tr><tr><td><span class="inline">buffer_grow</span></td><td>A buffer that will "grow" dynamically as data is added</td></tr><tr><td><span class="inline">buffer_wrap</span></td><td>A buffer where the data will "wrap". When the data being added reaches the limit of the buffer size, the overwrite will be placed back at the start of the buffer, and further writing will continue from that point.</td></tr><tr><td><span class="inline">buffer_fast</span></td><td>A special "stripped" buffer that is extremely fast to read/write to. Can only be used with <span class="inline">buffer_u8</span> <a href="buffer_write.htm">data types</a>, and <i>must</i> be 1 byte aligned.</td></tr></tbody></table></div><p>Apart from the buffer type, you will also have to set the <i>byte alignment</i> for the buffer. This value will vary depending on the data that you wish to store in the buffer, and in most cases a value of 1 is perfectly fine. However, be aware that for some operations a specific alignment is <i>essential</i>, and an incorrect alignment may cause errors (for further details on alignment see <a href="../../../Additional_Information/Guide_To_Using_Buffers.htm">Buffer Alignment</a>). The following is a general guide to show which values are most appropriate for each data type (when in doubt, use an alignment of 1):</p><ul class="colour"><li>Strings should be aligned to 1 byte.</li><li>Signed or unsigned 8bit integers can be aligned to any value, but note that for a fast buffer (see <span class="inline3_func"><a href="buffer_write.htm">buffer_write</a></span>) it <i>must</i> be aligned to 1.</li><li>Signed or unsigned 16bit integers should be aligned to 2 bytes.</li><li>Signed or unsigned 32bit integers should be aligned to 4 bytes</li><li>Floats of up to 16bits should be aligned to 2 bytes.</li><li>Floats of up to 32bits should be aligned to 4 bytes.</li><li>Floats of up to 64bits should be aligned to 8 bytes.</li></ul><p>The final two arguments are used to specify the range of vertex data that you wish to copy into the newly created buffer. The start vertex can be anywhere between 0 and the number of vertices -1, and then you give the number of vertices from that point to copy. You can use the function&nbsp;<span class="inline3_func"><a href="../Drawing/Primitives/vertex_get_number.htm">vertex_get_number</a>&nbsp;</span>on the vertex buffer to get the total number of vertices stored.</p><p class="note"><b><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span></b> Vertex buffers are 1 byte aligned, but you can create the buffer with any alignment depending on how you want to treat the data, as the vertex data is simply a raw memory copy into the buffer.</p><div data-conref="../../../assets/snippets/Note_Buffer_Delete_Dynamic.hts"><p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;It's important that you remove any dynamically created resources like this from memory when you no longer need them to prevent memory leaks, so when you are finished with the buffer that you have created you should free it up again using <span class="inline3_func"><a href="buffer_delete.htm">buffer_delete</a></span>.</p></div><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">buffer_create_from_vertex_buffer_ext</span>(vertex_buffer, type, alignment, start_vertex, num_vertices)</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>vertex_buffer</td><td><span data-keyref="Type_ID_Buffer_Vertex"><a target="_blank" href="../Drawing/Primitives/vertex_create_buffer.htm">Vertex Buffer</a></span></td><td>A reference to the vertex buffer to use.</td></tr><tr><td>type</td><td><span data-keyref="Type_Constant_Buffer_Type"><a target="_blank" href="buffer_create.htm">Buffer Type Constant</a></span></td><td>The type of buffer to create (see the constants list below).</td></tr><tr><td>alignment</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The byte alignment for the buffer.</td></tr><tr><td>start_vertex</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The starting vertex.</td></tr><tr><td>num_vertices</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The total number of vertices to copy.</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_ID_Buffer"><a target="_blank" href="buffer_create.htm">Buffer</a></span></p><p>&nbsp;</p><h4>Example:</h4><p class="code">var _v_num = vertex_get_number(model_buff);<br>player_buffer = <span data-field="title" data-format="default">buffer_create_from_vertex_buffer_ext</span>(model_buffer, buffer_grow, 1, 0, _v_num - 1);</p><p>The above code allocates memory to a buffer then copies the data of all vertices from the given vertex buffer into it, returning the new buffer. It is stored in the variable <span class="inline2">player_buffer</span>&nbsp;for future use.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Buffers.htm">Buffers</a></div><div style="float:right">Next:&nbsp;<a href="buffer_delete.htm">buffer_delete</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>