<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let o;o=a?e.attr(a):e.html();let s=t[removeHtml(o)];if(null!=s&&s.length){t=retHtml(o);let n=0;t&&t.forEach(function(e,t){var a=s.replace("{"+n+"}",e);s=a===s?s.replace("{}",e):a,n++}),a?e.attr(a,s):e.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Note that you can save out multiple buffers in one by calling this function multiple times between calls to {}{}buffer_async_group_begin(){}{} and {}{}buffer_async_group_end(){}{} (see those functions for further information on this).":"请注意，在调用{}{}buffer_async_group_begin(){}{}和{}{}buffer_async_group_end(){}{}之间多次调用此函数，可以将多个缓冲区保存为一个(有关详细信息，请参见那些函数)。","Note that you can save out multiple buffers in one by calling this function multiple times between calls to&nbsp;{}{}buffer_async_group_begin{}{} and&nbsp;{}{}buffer_async_group_end{}{} {}{} {}{}(see those functions for further information on this). ":"请注意，您可以通过在调用 {}{}buffer_async_group_begin{}{} 和 {}{}buffer_async_group_end{}{}{}{}{}{} 之间多次调用此函数，将多个缓冲区保存在一个缓冲区中 (请参阅这些函数有关此的更多信息)。",'The "offset" defines the start position within the buffer for saving (in bytes), and the "size" is the size of the buffer area to be saved from that offset onwards (also in bytes). This function works asynchronously, and so the game will continue running while being saved, and all files saved using this function will be placed in a "default" folder. This folder does {}not{} need to be included in the filename as it is added automatically by {}GameMaker{}. For example the filename path "{}Data\\Player_Save.sav{}" would actually be saved to "{}default\\Data\\Player_Save.sav{}". However, if you then load the file using the function {}{}buffer_load_async{}{}, you do not need to supply the "default" part of the path either (but any other file function {}will{} require it, except on consoles Xbox One, PS4 and Nintendo Switch).':'"offset" 定义了缓冲区内保存的起始位置 (以字节为单位)，"size" 是从该偏移量开始保存的缓冲区的大小 (也以字节为单位)。此功能异步工作，因此游戏在保存时将继续运行，并且使用此功能保存的所有文件将被放置在 " 默认 " 文件夹中。该文件夹 {} 不需要 {} 包含在文件名中，因为它是由 {}GameMaker{} 自动添加的。例如，文件名路径 "{}Data\\Player_Save.sav{}" 实际上会保存到 "{}default\\Data\\Player_Save.sav{}"。不过，如果您随后使用函数 {}{}buffer_load_async{}{} 加载文件，则也无需提供路径的 " 默认 " 部分 (但任何其他文件函数 {} 将 {} 需要它， Xbox One、PS4 和 Nintendo Switch 游戏机除外)。','The above code saves the contents of the buffer "{}buff{}" to the given save file, storing the ID of the function call in the variable "{}saveid{}". When the save is complete, the asynchronous Save/Load event will be triggered and you can parse the {}async_load{} map for the correct ID of the function, like this:':'上述代码将缓冲区"{}buff{}"的内容保存到给定的保存文件中，将函数调用的ID存储在变量"{}saveid{}"中。 保存完成后，异步保存/加载事件将被触发，您可以解析{}async_load{}映射以获取函数的正确ID，如下所示：',"The above code saves the contents of the buffer {}buff{}&nbsp;to the given save file, storing the ID of the function call in a variable {}saveid{}. When the save is complete, the asynchronous&nbsp;{}Save / Load{}&nbsp;event will be triggered and you can parse the&nbsp;{}{}async_load{}{} map for the correct ID of the function, like this:":"上述代码将缓冲区 {}buff{} 的内容保存到给定的保存文件，并将函数调用的 ID 存储在变量 {}saveid{} 中。保存完成后，将触发异步 {}Save / Load{} 事件，您可以解析 {}{}async_load{}{} 映射以获取函数的正确 ID，如下所示：","The above code will first check the ID of the DS map that has been created, then check the status of the callback, posting a debug message if there have been any issues.":"上面的代码将首先检查已创建的 DS 地图的 ID，然后检查回调的状态，如果有任何问题，则发布调试消息。","The above code will first check the id of the DS map that has been created, then check the status of the callback, posting a debug message if there has been any issues.":"上述代码将首先检查已创建的DS映射的id，然后检查回调的状态，如果出现任何问题，则发布调试消息。","The buffer to save.":"要保存的缓冲区。","The function will return a unique ID value and trigger an {}Asynchronous Save/Load&nbsp;Event{} where you can use the returned ID to check the {}async_load{} ID value, as shown in the extended example below. The {}{}async_load{}{} map in the event will have the following two key/value pairs:":"该函数将返回唯一的Id值并触发{}异步保存/加载事件{}，您可以在其中使用返回的Id检查{}async_load{}Id值，如下面的扩展示例所示。事件中的{}{}async_load{}{}映射将具有以下两个密钥/值对：","The function will return a unique ID value and trigger an {}Asynchronous Save/Load&nbsp;Event{} where you can use the returned ID to check the&nbsp;{}{}async_load{}{}'s ID value, as shown in the extended example below. The&nbsp;{}{}async_load{}{} {}{} {}{}map in the event will have the following two key/value pairs: ":"该函数将返回唯一的 ID 值并触发 {} 异步保存 / 加载事件 {}，您可以在其中使用返回的 ID 来检查 {}{}async_load{}{} 的 ID 值，如扩展示例中所示以下。事件中的 {}{}async_load{}{}{}{}{}{} 映射将具有以下两个键 / 值对：","The index of the buffer to save.":"要保存的缓冲区索引。","The name of the file to save as.":"要另存为的文件名。","The offset within the buffer to save from (in bytes).":"缓冲区内用于保存的偏移(以字节为单位)。","The size of the buffer area to save (in bytes).":"要保存的缓冲区的大小(以字节为单位)。","The {}buffer_save_async(){} function can be called from any event, and since it is asynchronous the callback can be almost instantaneous or could take several seconds. Calling the function is simple and would look something like this:":"{}buffer_save_async(){}函数可以从任何事件调用，由于它是异步的，所以回调可以几乎是瞬时的，或者可能需要几秒钟的时间。调用函数很简单，看起来如下：","The {}{}buffer_save_async{}{}&nbsp;function can be called from any event, and since it is asynchronous the callback can be almost instantaneous or could take several seconds. Calling the function is simple and would look something like this:":"{}{}buffer_save_async{}{} 函数可以从任何事件调用，并且由于它是异步的，因此回调几乎是瞬时的，也可能需要几秒钟的时间。调用该函数很简单，如下所示：","This function saves part of the contents of a buffer to a file asynchronously, ready to be read back into memory using any of the {}buffer_load_*{} functions.":"该函数将缓冲区的部分内容异步保存到文件中，准备好使用任何 {}buffer_load_*{} 函数读回内存。",'With this function you can save part of the contents of a buffer to a file, ready to be read back into memory using the {}{}buffer_load(){}{} function (or any of the other functions for loading buffers). The "offset" defines the start position within the buffer for saving (in bytes), and the "size" is the size of the buffer area to be saved from that offset onwards (also in bytes). This function works asynchronously, and so the game will continue running while being saved, and all files saved using this function will be placed in a "default" folder. This folder does {}not{} need to be included in the filename as it is added automatically by GameMaker. For example the filename path "{}Data\\Player_Save.sav{}" would actually be saved to "{}default\\Data\\Player_Save.sav{}". However, if you then load the file using the function {}{}buffer_load_async(){}{}, you do not need to supply the "default" part of the path either (but any other file function {}will{} require it, except on consoles Xbox One, PS4 and Nintendo Switch).':'使用此函数，您可以将缓冲区的一部分内容保存到文件中，该文件可以使用{}{}buffer_load(){}{}函数(或任何其他用于加载缓冲区的函数)读回内存。"偏移"定义缓冲区中用于保存的起始位置(以字节为单位)，"大小"是从该偏移量开始要保存的缓冲区的大小(也以字节为单位)。此函数异步运行，因此游戏将在保存的同时继续运行，使用此函数保存的所有文件将置于"默认"文件夹中。此文件夹{}不需要{}包含在文件名中，因为它由GameMaker自动添加。例如，文件名路径"{}Data\\Player_Save.sav{}"实际上将保存为"{}default\\Data\\Player_Save.sav{}"。 但是，如果随后使用函数{}{}buffer_load_async(){}{}加载文件，您也不需要提供路径的"默认"部分(但任何其它文件函数{}都需要{}，除了游戏主机 Xbox One、PS4和Nintendo Switch)。','{}"id": {}the ID of the async function as returned by the save function.':'{}"ID": {}save函数返回的异步函数的ID。','{}"status": {}will return {}true{} if the data was saved/loaded correctly, and {}false{} otherwise.':'{}"status": {}如果数据保存/加载正确，将返回{}true{}，否则返回{}false{}。','{}NOTE{}: On HTML5 "default/" is not added automatically and you may have to account for this in your code.':'{}注意{}：在HTML5上，" default/"不会自动添加，您可能需要在代码中考虑这一点。',"{}NOTE{}: On HTML5 the returned results are saved&nbsp;as base64 encoded strings when saved to a file.":"{}注意{}：在 HTML5 上，当保存到文件时，返回的结果被保存为 base64 编码字符串。","{}{}NOTE{}{}&nbsp;On HTML5 the returned results are saved&nbsp;as base64 encoded strings when saved to a file.":"{}{} 注意{}{} 在 HTML5 上，返回的结果在保存到文件时会保存为 Base64 编码的字符串。",'{}{}{}NOTE{}{}{} On HTML5 "default/" is not added automatically and you may have to account for this in your code.':'{}{}{} 注意{}{}{} 在 HTML5 上，"default/" 不会自动添加，您可能必须在代码中考虑到这一点。'},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.2.18.0_25"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>buffer_save_async</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference page for buffer_save_async"><meta name="rh-index-keywords" content="buffer_save_async"><meta name="search-keywords" content="buffer_save_async"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Buffers/buffer_load.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Buffers/buffer_save_ext.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="buffer_save_async"><span>buffer_save_async</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">buffer_save_async</span></h1><p>This function saves part of the contents of a buffer to a file asynchronously, ready to be read back into memory using any of the <span class="inline3_func">buffer_load_*</span> functions.</p><p>The "offset" defines the start position within the buffer for saving (in bytes), and the "size" is the size of the buffer area to be saved from that offset onwards (also in bytes). This function works asynchronously, and so the game will continue running while being saved, and all files saved using this function will be placed in a "default" folder. This folder does <i>not</i> need to be included in the filename as it is added automatically by <span data-keyref="GameMaker Name">GameMaker</span>. For example the filename path "<span class="inline">Data\Player_Save.sav</span>" would actually be saved to "<span class="inline">default\Data\Player_Save.sav</span>". However, if you then load the file using the function <span class="inline3_func"><a href="buffer_load_async.htm">buffer_load_async</a></span>, you do not need to supply the "default" part of the path either (but any other file function <i>will</i> require it, except on consoles Xbox One, PS4 and Nintendo Switch).</p><p class="note"><b><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span></b> On HTML5 "default/" is not added automatically and you may have to account for this in your code.</p><p>The function will return a unique ID value and trigger an <a href="../../../The_Asset_Editors/Object_Properties/Async_Events/Save_Load.htm">Asynchronous Save/Load&nbsp;Event</a> where you can use the returned ID to check the&nbsp;<span class="inline2"><a href="../../GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span>'s ID value, as shown in the extended example below. The&nbsp;<span class="inline2"><a href="../../GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span><font face="menlo, consolas, monospace"><span style="font-size:17px"></span></font> map in the event will have the following two key/value pairs:</p><ul><li><b>"id":</b> the ID of the async function as returned by the save function.</li><li><b>"status":</b> will return <span class="inline2">true</span> if the data was saved/loaded correctly, and <span class="inline2">false</span> otherwise.</li></ul><p>Note that you can save out multiple buffers in one by calling this function multiple times between calls to&nbsp;<span class="inline3_func"><a href="buffer_async_group_begin.htm">buffer_async_group_begin</a></span> and&nbsp;<span class="inline3_func"><a href="buffer_async_group_end.htm">buffer_async_group_end</a></span><font face="menlo, consolas, monospace"><span style="font-size:17px"></span></font> (see those functions for further information on this).</p><p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;On HTML5 the returned results are saved&nbsp;as base64 encoded strings when saved to a file.</p><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">buffer_save_async</span>(buffer, filename, offset, size);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>buffer</td><td><span data-keyref="Type_ID_Buffer"><a target="_blank" href="buffer_create.htm">Buffer</a></span></td><td>The buffer to save.</td></tr><tr><td>filename</td><td><span data-keyref="Type_String"><a target="_blank" href="../../GML_Overview/Data_Types.htm">String</a></span></td><td>The name of the file to save as.</td></tr><tr><td>offset</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The offset within the buffer to save from (in bytes).</td></tr><tr><td>size</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The size of the buffer area to save (in bytes).</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_ID_Async_Event"><a target="_blank" href="../Asynchronous_Functions/Asynchronous_Functions.htm">Async Request ID</a></span></p><p>&nbsp;</p><h4>Example:</h4><p>The <span class="inline3_func"><span data-field="title" data-format="default">buffer_save_async</span></span>&nbsp;function can be called from any event, and since it is asynchronous the callback can be almost instantaneous or could take several seconds. Calling the function is simple and would look something like this:</p><p class="code">saveid = buffer_save_async(buff, "Player_Save.sav", 0, 16384);</p><p>The above code saves the contents of the buffer <span class="inline2">buff</span>&nbsp;to the given save file, storing the ID of the function call in a variable <span class="inline2">saveid</span>. When the save is complete, the asynchronous&nbsp;<a href="../../../The_Asset_Editors/Object_Properties/Async_Events/Save_Load.htm">Save / Load</a>&nbsp;event will be triggered and you can parse the&nbsp;<span class="inline2"><a href="../../GML_Overview/Variables/Builtin_Global_Variables/async_load.htm">async_load</a></span> map for the correct ID of the function, like this:</p><p class="code">if (ds_map_find_value(async_load, "id") == saveid)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;if (ds_map_find_value(async_load, "status") == false)<br>&nbsp; &nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_debug_message("Save failed!");<br>&nbsp; &nbsp; }<br>}</p><p>The above code will first check the ID of the DS map that has been created, then check the status of the callback, posting a debug message if there have been any issues.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Buffers.htm">Buffers</a></div><div style="float:right">Next:&nbsp;<a href="buffer_load.htm">buffer_load</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>