<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,o){let a;a=o?e.attr(o):e.html();let l=t[removeHtml(a)];if(null!=l&&l.length){t=retHtml(a);let n=0;t&&t.forEach(function(e,t){var o=l.replace("{"+n+"}",e);l=o===l?l.replace("{}",e):o,n++}),o?e.attr(o,l):e.html(l)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Additive blending. Luminosity values of light areas are added.":"添加剂混合。将添加灯光区域的亮度值。","As you can see from the above table, these four blend modes are really composites of {}extended{} blend modes which can be found on the page describing {}{}gpu_set_blendmode_ext(){}{}.":"如上表所示，这四种混合模式实际上是{}扩展{}混合模式的组合，可在描述{}{}gpu_set_blendmode_ext(){}{}的页面上找到。","Blend Mode Constant":"混合模式常量","Guide To Using Blendmodes":"混合模式使用指南","Max blending. Similar to additive blending.":"最大混合。类似于添加剂混合。","Normal blending (the default blend mode).":"正常混合(默认混合模式)。","Subtractive blending. Luminosity values of light areas are subtracted.":"减法混合。减去灯光区域的亮度值。","The blend mode to use (see the table above)":"要使用的混合模式(请参见上表)","This function permits you to set the blend mode in four basic ways using the following constants:":"此函数允许您使用以下常量以四种基本方式设置混合模式：","This will turn the black into transparency, creating a 'glow' effect from the white being strong on the outside and gradually weakening further from the circle centre. The blend mode is reset after the circle is drawn to ensure additive blending is not also applied to everything else after it.":"这将使黑色变成透明，从白色在外面强烈到从圆心逐渐减弱的'发光'效果。绘制圆之后将重置混合模式，以确保在绘制圆之后不会将添加混合应用于其他任何对象。","To help you get the most from blend modes and to help understand how they work and how they affect the final image being drawn to the screen, we recommend that you read the following guide:":"为了帮助您充分利用混合模式，并帮助您了解它们如何工作以及它们如何影响绘制到屏幕的最终图像，建议您阅读以下指南：","When {}GameMaker{} goes to draw a pixel there is a source colour (the colour of the pixel we're going to draw) and a destination colour(the colour that's already in the pixel we're drawing to), so when determining the new colour of the pixel, the source and destination colours are calculated according to the chosen blend mode. Each component of the colours is stored as a floating point value between 0 and 1, and the new colour is calculated by multiply each component of the source colour by some factor and by multiplying each component of destination colour by some other factor and then adding the results together component by component.":"{}GameMaker{}在绘制像素时，会显示源颜色(我们要绘制的像素的颜色)和目标颜色(我们要绘制的像素中已有的颜色)，因此在确定像素的新颜色时，会根据所选的混合模式计算源颜色和目标颜色。将颜色的每个分量存储为介于0和1之间的浮点值，并且通过将源颜色的每个分量乘以某个因子，并通过将目标颜色的每个分量乘以某个其他因子，然后将结果与分量相加来计算新颜色。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.6.2.0_30"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>gpu_set_blendmode</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference for the function gpu_set_blendmode"><meta name="rh-index-keywords" content="gpu_set_blendmode,bm_normal,bm_add,bm_subtract,bm_reverse_subtract,bm_min,bm_max"><meta name="search-keywords" content="gpu_set_blendmode,bm_normal,bm_add,bm_subtract,bm_reverse_subtract,bm_min,bm_max"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_blendmode_ext.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Drawing/GPU_Control/gpu_set_cullmode.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="gpu_set_blendmode"><span>gpu_set_blendmode</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>gpu_set_blendmode</h1><p>When <span data-keyref="GameMaker Name">GameMaker</span> goes to draw a pixel there is a source colour (the colour of the pixel we're going to draw) and a destination colour (the colour that's already in the pixel we're drawing to), so when determining the new colour of the pixel, the source and destination colours are calculated according to the chosen blend mode.</p><p>Each component of the colours is stored as a floating point value between 0 and 1, and the new colour is calculated by multiplying each component of the source colour by some factor and by multiplying each component of destination colour by some other factor and then adding the results together component by component. The source and destination can also be mixed differently depending on the selected <a href="gpu_set_blendequation.htm">equation</a>.</p><p>This function permits you to set the blend mode in six basic ways using the following constants:</p><div data-conref="../../../../assets/snippets/Table_Gpu_blend_modes.hts"><table><colgroup><col><col><col><col></colgroup><tbody><tr><th colspan="4"><span data-keyref="Type_Constant_Draw_Blend_Mode"><a target="_blank" href="gpu_get_blendmode.htm">Blend Mode Constant</a></span></th></tr><tr><th>Constant</th><th>Description</th><th><a href="gpu_set_blendmode_ext.htm">Extended Blend Mode</a></th><th><a href="gpu_set_blendequation.htm">Blend Equation</a></th></tr><tr><td><span class="inline">bm_normal</span></td><td>Normal blending (the default blend mode).</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_inv_src_alpha</span>)</td><td><span class="inline">bm_eq_add</span></td></tr><tr><td><span class="inline">bm_add</span></td><td>Additive blending. Luminosity values of light areas are added.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_eq_add</span></td></tr><tr><td><span class="inline">bm_subtract</span></td><td>Subtractive blending. Source is subtracted from the destination.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_eq_subtract</span></td></tr><tr><td><span class="inline">bm_reverse_subtract</span></td><td>Reverse subtractive blending. Destination is subtracted from the source.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_eq_reverse_subtract</span></td></tr><tr><td><span class="inline">bm_min</span></td><td>Smaller value from source and destination is selected.</td><td>(<span class="inline">bm_one</span>, <span class="inline">bm_one</span>)</td><td><span class="inline">bm_eq_min</span></td></tr><tr><td><span class="inline">bm_max</span></td><td>Max blending. Similar to additive blending.</td><td>(<span class="inline">bm_src_alpha</span>, <span class="inline">bm_inv_src_colour</span>)</td><td><span class="inline">bm_eq_add</span></td></tr></tbody></table></div><p>As you can see from the above table, these blend modes are really composites of <i>extended</i> blend modes which can be found on the page describing <a href="gpu_set_blendmode_ext.htm"><span class="inline">gpu_set_blendmode_ext()</span></a>. Some of them also make use of a different <a href="gpu_set_blendequation.htm">blend equation</a>.</p><p>To help you get the most from blend modes and to help understand how they work and how they affect the final image being drawn to the screen, we recommend that you read the following guide:</p><ul class="colour"><li><a href="../../../../Additional_Information/Guide_To_Using_Blendmodes.htm">Guide To Using Blendmodes</a></li></ul><p>&nbsp;</p><h4>Syntax:</h4><p class="code">gpu_set_blendmode(mode);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>mode</td><td><span data-keyref="Type_Constant_Draw_Blend_Mode"><a target="_blank" href="gpu_get_blendmode.htm">Blend Mode Constant</a></span></td><td>The blend mode to use (see the table above)</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Void">N/A</span></p><p>&nbsp;</p><h4>Example:</h4><p class="code">gpu_set_blendmode(bm_add);<br>draw_circle_colour(100, 100, 50, c_white, c_black, 0);<br>gpu_set_blendmode(bm_normal);</p><p>This will turn the black into transparency, creating a 'glow' effect from the white being strong on the outside and gradually weakening further from the circle centre. The blend mode is reset after the circle is drawn to ensure additive blending is not also applied to everything else after it.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="GPU_Control.htm">GPU Control</a></div><div style="float:right">Next:&nbsp;<a href="gpu_set_blendmode_ext.htm">gpu_set_blendmode_ext</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>