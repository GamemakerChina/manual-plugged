<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let n;n=a?e.attr(a):e.html();let o=t[removeHtml(n)];if(null!=o&&o.length){t=retHtml(n);let s=0;t&&t.forEach(function(e,t){var a=o.replace("{"+s+"}",e);o=a===o?o.replace("{}",e):a,s++}),a?e.attr(a,o):e.html(o)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"As mentioned above, {}GameMaker{} doesn't actually render most things to the screen directly, but instead it renders them to the {}application surface{}. This is essentially a surface - just like any that you can make yourself using the surface functions -&nbsp;and as such it can be manipulated, drawn to, sent to shaders, etc. Basically,&nbsp;anything that you would normally do with a surface you created can also be applied to the application surface.":"如上所述，{}GameMaker{} 实际上并不将大多数内容直接渲染到屏幕上，而是将它们渲染到 {} 应用程序界面 {}。这本质上是一个表面 - 就像您可以使用表面函数自己制作的任何表面一样 - 因此它可以被操纵、绘制、发送到着色器等。基本上，您通常对您创建的表面执行的任何操作都可以也可应用于应用表面。","As mentioned above, {}GameMaker{} doesn't actually render most things to the screen directly, but instead it renders them to the {}application surface{}. This is essentially a surface - just like any that you can make yourself using the surface functions -&nbsp;and as such it can be manipulated, drawn to, sent to shaders, etc... Basically,&nbsp;anything that you would normally do with a surface you created can also be applied to the application surface.":"如上所述，{}GameMaker{}实际上并不直接将大部分内容渲染到屏幕，而是将它们渲染到{}应用程序表面{}。这本质上是一个表面，就像任何可以使用表面函数创建自己的表面一样，因此可以对其进行操作、绘制、发送到着色器等...基本上，通常对创建的表面执行的任何操作也可以应用于应用程序表面。","Draw GUI End event":"绘制 GUI 结束事件","Draw GUI end event":"绘制 GUI 结束事件","Draw GUI event":"绘制 GUI 事件","Finally, it is worth noting that drawing to a surface will take into consideration the colour&nbsp;{}and{}&nbsp;the alpha component of each pixel, both from the surface itself and also from what is being drawn to it. This may lead to some rather unintuitive results (for example, drawing a sprite with 0.5 alpha to a surface with 0 alpha will give a final alpha of 0.25). The reasons for this are explained on&nbsp;the following page, and we recommend that you read it before working with surfaces:&nbsp;{}Guide To Using Blendmodes{}":"最后，值得注意的是，绘制到表面将考虑每个像素的颜色{}和{}的Alpha分量，这两个分量既来自表面本身，也来自绘制到表面的内容。这可能会导致一些相当不直观的结果(例如，将具有0.5 Alpha的精灵绘制到具有0 Alpha的表面将给出0.25的最终Alpha)。下一页说明了这样做的原因，我们建议您在处理表面之前阅读这些原因：{}使用混合模式指南{}","Finally, you have two functions for storing and retrieving surfaces in {}Buffers{}:":"最后，您有两个用于在{}缓冲区{}中存储和检索表面的函数：","Finally, you would draw the surface (or use it in a shader, or whatever is required).":"最后，绘制表面(或者在着色器中使用，或者根据需要使用)。",'First, you should realise that surfaces ({}except{} the application surface) are "volatile". This means that if the device or window loses focus or is minimised (good examples are when you ALT +Tab&nbsp;to different window and back again on&nbsp;Windows, or on an Android device when the app loses focus due to a call) then the surface {}may be destroyed{}. This is because it is stored {}only{}&nbsp;in the texture memory ({}VRAM{}) and may be overwritten when the target platform needs that memory for something else which means that you should {}{}always{}{} have some type of fail-safe code in place, usually with the {}{}surface_exists(){}{} function.':'首先，您应该意识到表面(应用程序表面{}除外{})是"易变的"。这意味着，如果设备或窗口失去焦点或被最小化(很好的例子是，当您 Alt+ Tab 键切换到不同的窗口，然后在 Windows 上返回，或者当应用程序由于调用而失去焦点时，在 Android 设备上返回)，则表面{}可能会被破坏{}。这是因为它{}仅{}存储在纹理内存 ({}VRAM{})中，并且可能会在目标平台需要该内存进行其他操作时被覆盖，这意味着您应该{}{}始终{}{}具有某种类型的失败安全代码，通常具有 {}{}surface_exists(){}{} 函数。','First, you should realise that surfaces ({}except{} the application surface) are "volatile". This means that if the device or window loses focus or is minimised (good examples are when you ALT +Tab&nbsp;to different window and back again on&nbsp;Windows, or on an Android device when the app loses focus due to a call) then the surface {}may be destroyed{}. This is because it is stored {}only{}&nbsp;in the texture memory ({}VRAM{}) and may be overwritten when the target platform needs that memory for something else which means that you should {}{}always{}{} have some type of fail-safe code in place, usually with the&nbsp;{}{}surface_exists{}{} function.':'首先，您应该认识到表面 (应用程序表面{}除外{}) 是 " 易失性的"。这意味着，如果设备或窗口失去焦点或最小化 (很好的例子是，在 Windows 上，当您按 ALT +Tab 切换到不同的窗口并再次返回时，或者在 Android 设备上，当应用程序由于调用而失去焦点时)，则表面 {} 可能会被破坏 {}。这是因为它 {} 仅 {} 存储在纹理内存 ({}VRAM{}) 中，并且当目标平台需要该内存用于其他用途时可能会被覆盖，这意味着您应该 {}{} 始终 {}{} 具有某种类型的故障安全代码，通常使用 {}{}surface_exists{}{} 函数。',"Fourth, when drawing to a surface manually, the surface is {}always{} at the position of (0, 0). This means that you may need to convert {}absolute{} coordinates into {}relative{} coordinates for the surface. For example, if you have a camera-sized surface and wish to draw something that is currently visible in the camera to that surface, you should subtract the camera view x and y coordinates from the actual x and y coordinates to get a relative position to the surface (0, 0) position. So, the code would look something like this:":"第四，手动绘制表面时，表面 {} 始终 {} 位于 (0, 0) 位置。这意味着您可能需要将表面的 {} 绝对 {} 坐标转换为 {} 相对 {} 坐标。例如，如果您有一个相机大小的表面，并且希望将相机中当前可见的内容绘制到该表面，则应从实际 x 和 y 坐标中减去相机视图 x 和 y 坐标，以获得相对位置表面 (0, 0) 位置。所以，代码看起来像这样：","Fourth, when drawing to a surface manually, the surface is {}always{} at the position of (0,0). This means that you may need to convert {}absolute{} coordinates into {}relative{} coordinates for the surface. For example, if you have a camera-sized surface and wish to draw something that is currently visible in the camera to that surface, you should subtract the camera view x and y coordinates from the actual x and y coordinates to get a relative position to the surface (0,0) position. So, the code would look something like this:":"第四，当手动绘制到表面时，表面总是{}处于(0,0 )的位置。这意味着您可能需要将{}绝对{}坐标转换为表面的{}相对{}坐标。例如，如果具有摄影机大小的表面，并希望将摄影机中当前可见的内容绘制到该表面，则应从实际的x和y坐标中减去摄影机视图x和y坐标，以获得与表面(0,0 )位置的相对位置。因此，代码看起来像这样：",'However, apart from this application surface, you can also create your own surfaces and use them to create stunning or subtle special effects in your game. For example, you can use surfaces to "catch" instances, which can then be destroyed, and in this way you can create a decal effect where the sprite for the instance is displayed on the surface as if it still existed, permitting graphical effects like debris, blood, etc. without any real processing overhead. Another thing you can do with surfaces is use them as textures to be manipulated, or to create sprites "on the fly", or to create complex overlays. in fact, the uses for surfaces are endless!':'然而，除了这个应用程序表面之外，您还可以创建自己的表面并使用它们在游戏中创建令人惊叹或微妙的特殊效果。例如，您可以使用表面 " 捕获 " 实例，然后将其销毁，通过这种方式，您可以创建贴花效果，其中实例的精灵显示在表面上，就好像它仍然存在一样，允许诸如碎片、血液等，没有任何实际的处理开销。您可以使用表面做的另一件事是将它们用作要操纵的纹理，或 " 动态 " 创建精灵，或创建复杂的叠加层。事实上，表面的用途是无穷无尽的！','However, apart from this application surface, you can also create your own surfaces and use them to create stunning or subtle special effects in your game. For example, you can use surfaces to "catch" instances, which can then be destroyed, and in this way you can create a decal effect where the sprite for the instance is displayed on the surface as if it still existed, permitting graphical effects like debris, blood, etc... without any real processing overhead. Another thing you can do with surfaces is use them as textures to be manipulated, or to create sprites "on the fly", or to create complex overlays. in fact, the uses for surfaces are endless!':'但是，除了这个应用程序表面，你还可以创建自己的表面，并使用它们在游戏中创建令人惊叹或微妙的特殊效果。例如，可以使用表面来"捕捉"实例，然后可以销毁这些实例，通过这种方式，可以创建贴花效果，其中实例的精灵显示在表面上，就好像它仍然存在一样，允许出现碎片、血液等图形效果，而不会产生任何实际的处理开销。你可以对表面做的另一件事情是把它们当作纹理来操纵，或者创建"飞行中的精灵"，或者创建复杂的叠加，实际上对表面的用途是无穷的！','In the normal draw events, {}GameMaker{} doesn\'t actually draw directly to the screen, but rather draws to a {}surface{} called the {}application surface{}. This surface is basically a blank "canvas" that can then later be manipulated before being drawn to the screen when needed, and in most cases {}GameMaker{} handles this for you (although you can also manipulate it yourself in code for shaders, scaling and many other things - further details are given below).':'在正常绘制事件中，{}GameMaker{} 实际上并不直接绘制到屏幕，而是绘制到称为{}应用程序表面{}的{2}表面{3}。此表面基本上是一个空白的"画布"，稍后可以在需要时在绘制到屏幕之前对其进行操作，并且在大多数情况下 {}GameMaker{} 会为您处理此事件(尽管您也可以在着色器、缩放和许多其他事情的代码中自行操作它，但下面会提供进一步的详细信息)。',"Next, you would draw the things you wish as well as perform any other manipulations.":"接下来，您将绘制所需的内容以及执行任何其他操作。","Normal surfaces are quite easy to use, but there are a few basic rules to be followed when you use them:":"法线表面非常容易使用，但使用它们时需要遵循一些基本规则：","Once you are done you reset the drawing target so that all further drawing happens on the screen again.":"完成后，将重置绘制目标，以便所有进一步的绘制再次出现在屏幕上。","One thing to note is that should you require drawing the whole display to a surface (including tiles, backgrounds etc.) you can simply access the application surface itself (see below for further details) or you could assign a surface to a view port using the variable {}{}view_surface_id[0..7]{}{} as with this, all that is visible in that view port will be drawn to the corresponding surface.":"需要注意的一件事是，如果您需要将整个显示绘制到表面 (包括图块、背景等)，您可以简单地访问应用程序表面本身 (有关更多详细信息，请参阅下文)，或者您可以使用以下命令将表面分配给视口：变量 {}{}view_surface_id[0..7]{}{} 与此一样，该视口中的所有可见内容都将绘制到相应的表面。","One thing to note is that should you require drawing the whole display to a surface (including tiles, backgrounds etc...) you can simply access the application surface itself (see below for further details) or you could assign a surface to a view port using the variable {}{}view_surface_id[0..7]{}{} as with this, all that is visible in that view port will be drawn to the corresponding surface.":"需要注意的一点是，如果需要将整个显示绘制到一个表面(包括图块、背景等)，可以简单地访问应用程序表面本身(有关详细信息，请参阅下面的内容)，或者可以使用变量{}{}view_surface_id[ 0..7 ]{}{}将表面指定给视口，因此，在该视口中可见的所有内容都将绘制到相应的表面。","Pre-Draw event{} &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;--- &gt; {}the application surface is created (if it doesn't exist) and the render target is set{}":"预绘制事件 {}　　　--- &gt;{} 创建应用程序界面 (如果不存在) 并设置渲染目标 {}","Pre-draw event{} &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;--- &gt; {}the application surface is created (if it doesn't exist) and the render target is set{}":"绘制前事件{}---&gt;{}将创建应用程序表面(如果它不存在)并设置渲染目标{}","Second, you should note that surfaces can require large quantities of VRAM to be used, and so you should attempt to keep them as small as possible. Normally you would try and keep them no larger than the size of the view or display window.":"其次，应注意，表面可能需要大量 VRAM 才能使用，因此应尝试将其保持尽可能小的尺寸。通常，您会尝试使它们不大于视图或显示窗口的大小。",Surfaces:"表面","The basic use of a surface would be as follows:":"表面的基本用途如下：","The following functions exist for drawing surfaces:":"绘制表面具有以下函数：","The following functions exist to deal with surfaces (these functions are specific for creating and manipulating surfaces, but to actually draw them to the screen you should be using the specific draw functions that can be found&nbsp;below):":"以下函数用于处理表面(这些函数专用于创建和操作表面，但要将它们实际绘制到屏幕，应使用下面可以找到的特定绘制函数)：","The use of this surface means that you can easily create incredible transitions using shaders, or take the screen and wrap it around a 3D form, or simply scale a low-res game up to any resolution screen... The possibilities are endless!":"使用此表面意味着您可以使用着色器轻松创建令人难以置信的过渡，或者将屏幕包裹在3D形状周围，或者简单地将低分辨率游戏缩放到任何分辨率屏幕...可能性是无穷的！","Third, you should {}only create surfaces in the draw event{}. If you create a surface in the Create Event of an instance, you could potentially get the {}same{} index as the {}application_surface{}. This can then cause lots of problems and confusion as you think you are&nbsp;using your own surface, but you are actually using the current render target. You should also always try to limit {}drawing{} to a surface in the draw event too, since due to the optimised way in which {}GameMaker{} draws to the screen, it is recommended that you keep all draw functions {}within the draw event{} - this includes clearing a surface when it is first created, etc... Drawing to a surface outside of the draw event is possible and may even be necessary for some effects, but it's not how it {}should{} be done.":'第三，{}只应在绘制事件中创建表面{}。如果在实例的"创建事件"中创建表面，则可能会获得与 {}application_surface{} {2}相同的{3}个索引。这可能会导致许多问题和混淆，因为您认为使用的是自己的表面，但实际上使用的是当前渲染目标。您还应该始终尝试将{}绘制{}限制在绘制事件中的表面，因为 {}GameMaker{} 绘制到屏幕的优化方式，建议您将所有绘制函数{}保留在绘制事件{}-这包括在首次创建表面时清除表面，等等...绘制到绘制事件外部的表面是可能的，甚至对于某些效果可能是必需的，但这不是{}应该如何进行{}。',"Third, you should {}only create surfaces in the draw event{}. If you create a surface in the Create Event of an instance, you could potentially get the {}same{} index as the {}{}application_surface{}{}. This can then cause lots of problems and confusion as you think you are&nbsp;using your own surface, but you are actually using the current render target. You should also always try to limit {}drawing{} to a surface in the draw event too, since due to the optimised way in which {}GameMaker{} draws to the screen, it is recommended that you keep all draw functions {}within the draw event{} - this includes clearing a surface when it is first created, etc. Drawing to a surface outside of the draw event is possible and may even be necessary for some effects, but it's not how it {}should{} be done.":"第三，您应该 {} 仅在绘制事件中创建表面 {}。如果您在实例的 Create 事件中创建表面，您可能会获得与 {}{}application_surface{}{}{2} 相同的 {3} 索引。这可能会导致很多问题和混乱，因为您认为您正在使用自己的表面，但实际上您正在使用当前的渲染目标。您还应该始终尝试将 {} 绘制 {} 限制在绘制事件中的表面，因为由于 {}GameMaker{} 绘制到屏幕的优化方式，建议您保留所有绘制函数 {} 在绘制事件内 {}- 这包括在首次创建表面时清除表面等。在绘制事件之外绘制表面是可能的，甚至对于某些效果可能是必要的，但这不是它 {} 应该 {} 的方式做完了。","To access this surface, you need to use the built-in global variable {}application_surface{} which is explained on the following page:":"要访问此表面，您需要使用内置全局变量 {}application_surface{}，该变量在以下页面中进行了说明：","When you run your game, this surface is created the first time that the {}draw event{} is called in each new room that you enter, which means that nothing is drawn until that point. However, you can still get the application surface position and resize it in the {}Create Event{} or any other event without getting any errors and the values used will be relevant to the surface when it is created. The actual sequence of events for the creation&nbsp;and drawing of the application surface is as follows:":"运行游戏时，在您进入的每个新房间中第一次调用{}绘制事件{}时会创建此表面，这意味着在此之前不会绘制任何内容。但是，您仍然可以在{}创建事件{}或任何其他事件中获取应用程序表面位置并调整其大小，而不会出现任何错误，并且在创建表面时使用的值将与表面相关。创建和绘制应用程序表面的实际事件顺序如下：","You also have a few specialist functions that are designed {}only {}for use with the application surface:":"您还具有一些专业函数，这些函数仅设计为{}用于应用程序表面：","You first create a surface and assign it to a variable.":"首先创建一个表面并将其分配给一个变量。","You first create a surface and assign its index to a variable.":"首先创建表面并将其索引指定给变量。","You would then set the drawing target to the surface rather than the display.":"然后将绘制目标设置为表面而不是显示。","{}NOTE{}&nbsp;This is not true of the {}application surface{}, only user-created surfaces.":"{}注意{}这不适用于{}应用表面{}，只适用于用户创建的表面。","{}NOTE{}: The only thing you {}cannot{} do with the application surface is free it. It always exists, although the index value to access it may change.":"{}注意{}：{}不能对应用程序表面执行的唯一操作是将其释放。它始终存在，尽管用于访问它的索引值可能会更改。","{}NOTE{}{}&nbsp;{}This doesn't appear to happen with sprites or other visual assets (but actually does!) as they are also stored in regular memory (RAM) and when they are removed from texture memory (VRAM) they immediately get restored from regular memory when the game regains focus.":"{}注意{}{}{}这种情况似乎不会发生在精灵或其他视觉资源上(但实际上会发生！)，因为它们也存储在常规存储器 (RAM) 中，当它们从纹理存储器 (VRAM) 中移除时，当游戏重新聚焦时，它们会立即从常规存储器中恢复。","{}{}Draw GUI Begin event":"{}{}绘制 GUI 开始事件","{}{}Draw GUI begin event":"{}{}绘制 GUI 开始事件","{}{}For each visible view port, or, if no views ports are active, once {} {}Draw Begin event{} {}Draw event{} {}Draw End event{} &nbsp; &nbsp; &nbsp; &nbsp; --- &gt; {}the application surface render target is reset here{}{} {} ":"{}{}对于每个可见视口，或者，如果没有活动视口，则执行一次 {}{} 绘制开始事件 {}{} 绘制事件 {}{} 绘制结束事件 {}--- &gt;{} 应用程序表面渲染目标在此处重置 {}{}{}","{}{}For each visible view port, or, if no views ports are active, once {} {}Draw begin event{} {}Draw event{} {}Draw end event{} &nbsp; &nbsp; &nbsp; &nbsp; --- &gt; {}the application surface render target is reset here{}{} {} ":"{}{}对于每个可见视图端口，或者，如果没有活动的视图端口，则执行一次{}{}绘制开始事件{}{}绘制事件{}{}绘制结束事件{}---&gt;{}此处重置应用程序表面渲染目标{}{}{}","{}{}NOTE{}&nbsp;{}When working with surfaces there is the possibility that they can cease to exist at any time due to them being stored in texture memory. You should&nbsp;{}ALWAYS{}&nbsp;check that a surface exists using&nbsp;{}{}{}surface_exists(){}{}{}&nbsp;before referencing them directly.":"{}{}注意{}{}使用表面时，由于表面存储在纹理内存中，因此表面可能随时停止存在。在直接引用表面之前，应该{}始终{}使用{}{}{}surface_exists(){}{}{}检查表面是否存在。","{}{}NOTE{}{}&nbsp;This doesn't appear to happen with sprites or other visual assets (but actually does!) as they are also stored in regular memory (RAM) and when they are removed from texture memory (VRAM) they immediately get restored from regular memory when the game regains focus.":"{}{} 注意{}{} 对于精灵或其他视觉资源，这种情况似乎不会发生 (但实际上会发生！)，因为它们也存储在常规内存 (RAM) 中，并且当它们从纹理内存 (VRAM) 中删除时当游戏重新获得焦点时，它们会立即从常规记忆中恢复。","{}{}NOTE{}{}&nbsp;This is not true of the {}application surface{}, only user-created surfaces.":"{}{} 注意{}{} 这不适用于 {} 应用程序界面 {}，仅适用于用户创建的界面。","{}{}NOTE{}{}&nbsp;When working with surfaces there is the possibility that they can cease to exist at any time due to them being stored in texture memory. You should {}ALWAYS{} check that a surface exists using&nbsp;{}{}surface_exists{}{} {} {}before referencing them directly. ":"{}{} 注意 {}{} 在处理表面时，由于表面存储在纹理内存中，因此它们可能随时不再存在。在直接引用表面之前，您应该 {} 始终 {} 使用 {}{}surface_exists{}{}{}{} 检查表面是否存在。","{}{}Post draw event{} &nbsp; &nbsp; &nbsp; &nbsp; --- &gt; {}the application surface is now drawn to the {}display buffer{} by default{} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{}(although you can switch this off using&nbsp;{}{}application_surface_draw_enable(){}{})":"{}{}绘制后事件{}---&gt;{}默认情况下，应用程序表面将绘制到{}显示缓冲区{}中{}{}(虽然您可以使用 {}{}application_surface_draw_enable(){}{} 关闭此函数)","{}{}Post-Draw event{} &nbsp; &nbsp; &nbsp; &nbsp; --- &gt; {}the application surface is now drawn to the {}display buffer{} by default{} &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{}(although you can switch this off using&nbsp;{}{}application_surface_draw_enable{}{})":"{}{}绘制后事件 {}　　　--- &gt;{} 现在，应用程序表面默认绘制到 {} 显示缓冲区 {}{}　　　{}( 不过您可以使用 {}{}application_surface_draw_enable{}{} 将其关闭)","{}{}{}NOTE{}{}&nbsp;{}The only thing you {}cannot{} do with the application surface is free it. It always exists, although the handle to access it may change.":"{}{}{} 注意{}{}{} 您对应用程序界面唯一 {} 不能 {} 做的就是释放它。它始终存在，尽管访问它的句柄可能会改变。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.6.8"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Surfaces</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference section for the Surface functions and variables"><meta name="rh-index-keywords" content=""><meta name="search-keywords" content="Surfaces,application_surface,application surface,app surface"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Drawing/Surfaces/surface_exists.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_submit_ext.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Surfaces"><span>Surfaces</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Surfaces</span></h1><h2>Application Surface</h2><p>In the normal draw events, <span data-keyref="GameMaker Name">GameMaker</span> doesn't actually draw directly to the screen, but rather draws to a <b>surface</b> called the <i>application surface</i>.</p><p>This surface is basically a blank "canvas" that can be manipulated before being drawn to the screen when needed, and in most cases <span data-keyref="GameMaker Name">GameMaker</span> handles this for you (although you can also manipulate it yourself in code for shaders, scaling and many other things - further details are given below).</p><h2>Custom Surfaces</h2><p>Apart from the application surface, you can also create your own surfaces and use them to create stunning or subtle special effects in your game.</p><p>For example, you can use surfaces to "catch" instances, which can then be destroyed, and in this way you can create a decal effect where the sprite for the instance is displayed on the surface as if it still existed, permitting graphical effects like debris, blood, etc. without any real processing overhead.</p><p>Another thing you can do with surfaces is use them as textures to be manipulated, or to create sprites "on the fly", or to create complex overlays. In fact, the uses for surfaces are endless!</p><h2>Using Surfaces</h2><p>The basic use of a surface would be as follows:</p><ul class="colour"><li>You first create a variable to hold the surface, e.g. in the Create event:</li></ul><p class="code">surf = -1;</p><ul class="colour"><li>In a Draw event (or any other event)&nbsp;<em>before</em>&nbsp;you want to draw something to the surface, do a check to see if it exists, and if not, create it:</li></ul><p class="code">if (!surface_exists(surf))<br>{<br>&nbsp; &nbsp; surf = surface_create(960, 540);<br>}</p><ul class="colour"><li>In case the surface is automatically removed from the memory while you need it, this will catch that and recreate the surface.</li><li>You would then set the drawing target to the surface rather than the display, when you actually want to draw something to it, e.g. in the Draw event:</li></ul><p class="code">surface_set_target(surf);</p><ul class="colour"><li>Next, you would draw the things you wish as well as perform any other manipulations. It is recommended to clear the surface before drawing anything.</li></ul><p class="code">draw_clear_alpha(c_black, 0);<br>draw_sprite(spr_icon, 0, 48, 48);</p><ul class="colour"><li>Once you are done drawing to the surface, you reset the draw target so that all further drawing happens on the screen again.</li></ul><p class="code">surface_reset_target();</p><ul class="colour"><li>Finally, you would draw the surface (or <a href="../Textures/texture_set_stage.htm">use it in a shader</a>, or whatever is required).</li></ul><p class="code">draw_surface(surf, 0, 0);</p><ul class="colour"><li>When you no longer need the surface, remove it from memory:</li></ul><p class="code">surface_free(surf);</p><h2>Surface Rules</h2><p>Normal surfaces are quite easy to use, but there are a few basic rules to be followed when you use them:</p><ul class="colour"><li>First, you should realise that surfaces (<i>except</i> the application surface) are "volatile". This means that if the device or window loses focus or is minimised (good examples are when you ALT +Tab&nbsp;to different window and back again on&nbsp;Windows, or on an Android device when the app loses focus due to a call) then the surface <strong>may be destroyed</strong>. This is because it is stored <em>only</em>&nbsp;in the texture memory (<a class="tooltip" title="VRAM is the amount of memory available for video, ie: the memory space that can store textures and images.">VRAM</a>) and may be overwritten when the target platform needs that memory for something else which means that you should <i><b>always</b></i> have some type of fail-safe code in place, usually with the&nbsp;<span class="inline3_func"><a href="surface_exists.htm">surface_exists</a></span> function.</li></ul><p class="note" style="padding-top:.5em;padding-right:1em;padding-bottom:.5em;padding-left:4em"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;This doesn't appear to happen with sprites or other visual assets (but actually does!) as they are also stored in regular memory (RAM) and when they are removed from texture memory (VRAM) they immediately get restored from regular memory when the game regains focus.</p><ul class="colour"><li>Second, you should note that surfaces can require large quantities of VRAM to be used, and so you should attempt to keep them as small as possible. Normally you would try and keep them no larger than the size of the view or display window.</li><li>Third, you should <b>only create surfaces in the draw event</b>. If you create a surface in the Create Event of an instance, you could potentially get the <i>same</i> index as the <span class="inline2"><a href="application_surface.htm">application_surface</a></span>. This can then cause lots of problems and confusion as you think you are&nbsp;using your own surface, but you are actually using the current render target. You should also always try to limit <i>drawing</i> to a surface in the draw event too, since due to the optimised way in which <span data-keyref="GameMaker Name">GameMaker</span> draws to the screen, it is recommended that you keep all draw functions <i>within the draw event</i> - this includes clearing a surface when it is first created, etc. Drawing to a surface outside of the draw event is possible and may even be necessary for some effects, but it's not how it <em>should</em> be done.</li><li>Fourth, when drawing to a surface manually, the surface is <i>always</i> at the position of (0, 0). This means that you may need to convert <em>absolute</em> coordinates into <em>relative</em> coordinates for the surface. For example, if you have a camera-sized surface and wish to draw something that is currently visible in the camera to that surface, you should subtract the camera view x and y coordinates from the actual x and y coordinates to get a relative position to the surface (0, 0) position. So, the code would look something like this:</li></ul><p class="code">if (view_current == 0)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;surface_set_target(surf);<br>&nbsp;&nbsp;&nbsp;&nbsp;with (obj_Effect)<br>&nbsp; &nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var _vx = camera_get_view_x(view_camera[1]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var _vy = camera_get_view_y(view_camera[1]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;draw_sprite(sprite_index, image_index, x - _vx, y - _vy);<br>&nbsp; &nbsp; }<br>&nbsp;&nbsp;&nbsp;&nbsp;surface_reset_target();<br>}<br>else<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;draw_surface(surf, 0, 0);<br>}</p><ul class="colour"><li>Finally, it is worth noting that drawing to a surface will take into consideration the colour&nbsp;<em>and</em>&nbsp;the alpha component of each pixel, both from the surface itself and also from what is being drawn to it. This may lead to some rather unintuitive results (for example, drawing a sprite with 0.5 alpha to a surface with 0 alpha will give a final alpha of 0.25). The reasons for this are explained on&nbsp;the following page, and we recommend that you read it before working with surfaces:&nbsp;<a href="../../../../Additional_Information/Guide_To_Using_Blendmodes.htm">Guide To Using Blendmodes</a></li></ul><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;This is not true of the <a href="application_surface.htm">application surface</a>, only user-created surfaces.</p><p>One thing to note is that should you require drawing the whole display to a surface (including tiles, backgrounds etc.) you can simply access the application surface itself (see below for further details) or you could assign a surface to a view port using the variable <a href="../../Cameras_And_Display/Cameras_And_Viewports/view_surface_id.htm"><span class="inline">view_surface_id[0..7]</span></a> as with this, all that is visible in that view port will be drawn to the corresponding surface.</p><h2>Function Reference</h2><p>The following functions exist to deal with surfaces (these functions are specific for creating and manipulating surfaces, but to actually draw them to the screen you should be using the specific draw functions that can be found&nbsp;below):</p><ul class="colour"><li><a href="surface_exists.htm">surface_exists</a></li><li><a href="surface_create.htm">surface_create</a></li><li><a href="surface_create_ext.htm">surface_create_ext</a></li><li><a href="surface_resize.htm">surface_resize</a></li><li><a href="surface_set_target.htm">surface_set_target</a></li><li><a href="surface_set_target_ext.htm">surface_set_target_ext</a></li><li><a href="surface_get_target.htm">surface_get_target</a></li><li><a href="surface_get_target_ext.htm">surface_get_target_ext</a></li><li><a href="surface_reset_target.htm">surface_reset_target</a></li><li><a href="surface_copy.htm">surface_copy</a></li><li><a href="surface_copy_part.htm">surface_copy_part</a></li><li><a href="surface_depth_disable.htm">surface_depth_disable</a></li><li><a href="surface_get_height.htm">surface_get_height</a></li><li><a href="surface_get_width.htm">surface_get_width</a></li><li><a href="surface_get_texture.htm">surface_get_texture</a></li><li><a href="surface_get_depth_disable.htm">surface_get_depth_disable</a></li><li><a href="surface_getpixel.htm">surface_getpixel</a></li><li><a href="surface_getpixel_ext.htm">surface_getpixel_ext</a></li><li><a href="surface_get_format.htm">surface_get_format</a></li><li><a href="surface_format_is_supported.htm">surface_format_is_supported</a></li><li><a href="surface_free.htm">surface_free</a></li><li><a href="surface_save.htm">surface_save</a></li><li><a href="surface_save_part.htm">surface_save_part</a></li></ul><p>The following functions exist for drawing surfaces:</p><div data-conref="../../../../assets/snippets/Note_Surface_Check_If_Exists.hts"><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;When working with surfaces there is the possibility that they can cease to exist at any time due to them being stored in texture memory. You should <b>ALWAYS</b> check that a surface exists using&nbsp;<span class="inline3_func"><a href="surface_exists.htm">surface_exists</a></span><font face="menlo, consolas, monospace"></font> before referencing them directly.</p></div><ul class="colour"><li><a href="draw_surface.htm">draw_surface</a></li><li><a href="draw_surface_ext.htm">draw_surface_ext</a></li><li><a href="draw_surface_part.htm">draw_surface_part</a></li><li><a href="draw_surface_part_ext.htm">draw_surface_part_ext</a></li><li><a href="draw_surface_stretched.htm">draw_surface_stretched</a></li><li><a href="draw_surface_stretched_ext.htm">draw_surface_stretched_ext</a></li><li><a href="draw_surface_tiled.htm">draw_surface_tiled</a></li><li><a href="draw_surface_tiled_ext.htm">draw_surface_tiled_ext</a></li><li><a href="draw_surface_general.htm">draw_surface_general</a></li></ul><p>Finally, you have two functions for storing and retrieving surfaces in <a href="../../Buffers/Buffers.htm">Buffers</a>:</p><ul class="colour"><li><a href="../../Buffers/buffer_get_surface.htm">buffer_get_surface</a></li><li><a href="../../Buffers/buffer_set_surface.htm">buffer_set_surface</a></li></ul><h2>Application Surface Event Order</h2><p>As mentioned above, <span data-keyref="GameMaker Name">GameMaker</span> doesn't actually render most things to the screen directly, but instead it renders them to the <b>application surface</b>. This is essentially a surface - just like any that you can make yourself using the surface functions -&nbsp;and as such it can be manipulated, drawn to, sent to shaders, etc. Basically,&nbsp;anything that you would normally do with a surface you created can also be applied to the application surface.</p><p class="note"><b><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;</b>The only thing you <b>cannot</b> do with the application surface is free it. It always exists, although the handle to access it may change.</p><p>When you run your game, this surface is created the first time that a <a href="../../../../The_Asset_Editors/Object_Properties/Draw_Events.htm">draw event</a> is called in each new room that you enter, which means that nothing is drawn until that point. However, you can still get the application surface position and resize it in the <b>Create Event</b> or any other event without getting any errors and the values used will be relevant to the surface when it is created. The actual sequence of events for the creation&nbsp;and drawing of the application surface is as follows:</p><ul class="colour"><li>Pre-Draw event<br>&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;--- &gt; <b>the application surface is created (if it doesn't exist) and the render target is set</b></li><li><b></b>For each visible view port, or, if no views ports are active, once<ul class="colour"><li>Draw Begin event</li><li>Draw event</li><li>Draw End event<br>&nbsp; &nbsp; &nbsp; &nbsp; --- &gt; <b>the application surface render target is reset here</b></li></ul></li><li><b></b>Post-Draw event<br>&nbsp; &nbsp; &nbsp; &nbsp; --- &gt; <b>the application surface is now drawn to the <a class="tooltip" title="The display buffer is the 'canvas' where everything is finally drawn. Some events target this directly (like the Pre Draw event), while others will first draw to the application surface and then draw that to the display buffer.">display buffer</a> by default<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</b>(although you can switch this off using&nbsp;<span class="inline3_func"><a href="application_surface_draw_enable.htm">application_surface_draw_enable</a></span>)</li><li><b></b>Draw GUI Begin event</li><li>Draw GUI event</li><li>Draw GUI End event</li></ul><p>The use of this surface means that you can easily create incredible transitions using shaders, or take the screen and wrap it around a 3D form, or simply scale a low-res game up to any resolution screen... The possibilities are endless!</p><p>To access this surface, you need to use the built-in global variable <span class="inline">application_surface</span> which is explained on the following page:</p><ul class="colour"><li><a href="application_surface.htm">application_surface</a></li></ul><p>&nbsp;</p><p>You also have a few functions that are designed <em>only</em> for use with the application surface:</p><ul class="colour"><li><a href="application_surface_enable.htm">application_surface_enable</a></li><li><a href="application_surface_is_enabled.htm">application_surface_is_enabled</a></li><li><a href="application_get_position.htm">application_get_position</a></li><li><a href="application_surface_draw_enable.htm">application_surface_draw_enable</a></li></ul><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../Drawing.htm">Drawing</a></div><div style="float:right">Next: <a href="../Lighting/Lighting.htm">Lighting</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>