<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,n){let o;o=n?e.attr(n):e.html();let r=t[removeHtml(o)];if(null!=r&&r.length){t=retHtml(o);let a=0;t&&t.forEach(function(e,t){var n=r.replace("{"+a+"}",e);r=n===r?r.replace("{}",e):n,a++}),n?e.attr(n,r):e.html(r)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"If set to {}true{} the depth buffer will be disabled for created surfaces.":"如果设置为{}true{}，则将对创建的表面禁用深度缓冲区。","The above code stores the current depth buffer setting in a variable and then creates two surfaces, one with depth buffering enabled and one without, before restoring the original setting again.":"上述代码将当前深度缓冲区设置存储在变量中，然后创建两个表面，一个启用了深度缓冲，另一个不启用，然后再次恢复原始设置。","This function disables the automatic depth buffer generation for {}all{} surfaces that are created after it has been disabled. Normally all surfaces have depth buffers so if you draw 3D objects to them then it'll sort them properly by depth in order to maintain functional parity between rendering to surfaces and rendering to the back buffer, however allocating depth buffers essentially doubles the amount of memory required for surfaces, which could be an excessive and unnecessary overhead especially if your game is very memory intensive, and for 2D games they aren't generally required.":"此函数禁用在禁用后创建的{}所有{}表面的自动深度缓冲区生成。通常情况下，所有表面都有深度缓冲区，因此如果绘制3D对象到这些表面，它将按深度对它们进行正确排序为了在渲染到表面和渲染到后缓冲区之间保持函数奇偶校验，然而，分配深度缓冲区实际上使表面所需的内存量加倍，这可能是过度的和不必要的开销尤其是如果您的游戏非常耗费内存，并且2D游戏通常不需要这些内容。","To use this function you would call it {}before{} creating a surface, and then you can enable it again after (if required). All surfaces created when the depth buffer is disabled will no longer use a depth buffer when being drawn to, this results in the things being drawn to the surface having parity of depth. The images below illustrate this in practice:":"若要使用此函数，请在{}创建表面之前调用它{}，然后可以在创建表面之后再次启用它(如果需要)。禁用深度缓冲区时创建的所有表面在绘制到时将不再使用深度缓冲区，这将产生在具有同等深度的物体被吸引到表面上。下图说明了实践中的情况：","{}In the above image, we are drawing a rectangle and a triangle using a vertex buffer in 3D. The coordinates for the red triangle places it behind the green rectangle, but the code for drawing the triangle is called {}after{} the code for the rectangle, and when the depth buffer is enabled, the triangle is still drawn behind the rectangle as the 3D depth is being respected. However when we disable the depth buffer for the surface, only the code order is respected and so the triangle is drawn over the rectangle.":"{}在上图中，我们使用3D中的顶点缓冲区绘制矩形和三角形。的红色三角形的坐标将其置于绿色矩形的后面，但绘制三角形的代码在{}矩形的代码之后被称为{}，并且当启用深度缓冲区时，三角形仍然绘制在矩形的后面因为3D深度受到尊重。但是，当我们禁用表面的深度缓冲区时，只遵循代码顺序，因此在矩形上绘制三角形。","{}NOTE{}: If your game is 100% 2D or you know that you don't need a surface depth buffer, then it should be fine to simply call this function once at the start of the game to disable the buffer.":"{}注意{}：如果您的游戏为100% 2D，或者您知道不需要表面深度缓冲区，则在游戏开始时只需调用此函数一次即可禁用缓冲区。","{}NOTE{}: To properly preserve depth in 3D when using surfaces, not only should you have the depth buffer enabled, but you should also have z-writing and z-testing enabled. See the functions {}{}{}gpu_set_ztestenable(){}{}{} and {}{}{}gpu_set_zwriteenable(){}{}{} for more information.":"{}注意{}：要在使用表面时正确保留 3D 深度，不仅应启用深度缓冲区，还应启用 Z 写入和 Z 测试。有关详细信息，请参阅函数 {}{}{}gpu_set_ztestenable(){}{}{} 和 {}{}{}gpu_set_zwriteenable(){}{}{}。","{}{}{}NOTE{}{}&nbsp;{}If your game is 100% 2D or you know that you don't need a surface depth buffer, then it should be fine to simply call this function once at the start of the game to disable the buffer.":"{}{}{} 注意{}{}{} 如果您的游戏是 100% 2D 或者您知道不需要表面深度缓冲区，那么只需在游戏开始时调用此函数一次就可以了。游戏禁用缓冲区。","{}{}{}NOTE{}{}&nbsp;{}To properly preserve depth in 3D when using surfaces, not only should you have the depth buffer enabled, but you should also have z-writing and z-testing enabled. See the functions&nbsp;{}{}gpu_set_ztestenable{}{} and&nbsp;{}{}gpu_set_zwriteenable{}{} for more information.":"{}{}{} 注意{}{}{} 为了在使用表面时正确保留 3D 深度，您不仅应该启用深度缓冲区，还应该启用 z 写入和 z 测试。有关详细信息，请参阅函数 {}{}gpu_set_ztestenable{}{} 和 {}{}gpu_set_zwriteenable{}{}。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.6.8.0_12"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>surface_depth_disable</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference for surface_depth_disable"><meta name="rh-index-keywords" content="surface_depth_disable"><meta name="search-keywords" content="surface_depth_disable"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Drawing/Surfaces/surface_get_height.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Drawing/Surfaces/surface_copy_part.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="surface_depth_disable"><span>surface_depth_disable</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">surface_depth_disable</span></h1><p>This function disables the automatic depth buffer generation for <i>all</i> surfaces that are created after it has been disabled. Normally all surfaces have depth buffers so if you draw 3D objects to them then it'll sort them properly by depth in order to maintain functional parity between rendering to surfaces and rendering to the back buffer, however allocating depth buffers essentially doubles the amount of memory required for surfaces, which could be an excessive and unnecessary overhead especially if your game is very memory intensive, and for 2D games they aren't generally required.</p><p>To use this function you would call it <i>before</i> creating a surface, and then you can enable it again after (if required). All surfaces created when the depth buffer is disabled will no longer use a depth buffer when being drawn to, this results in the things being drawn to the surface having parity of depth. The images below illustrate this in practice:</p><p><img alt="Surface depth buffer example" class="center" src="../../../../assets/Images/Scripting_Reference/GML/Reference/Drawing/Surface_Depth_Buffer.png">In the above image, we are drawing a rectangle and a triangle using a vertex buffer in 3D. The coordinates for the red triangle places it behind the green rectangle, but the code for drawing the triangle is called <i>after</i> the code for the rectangle, and when the depth buffer is enabled, the triangle is still drawn behind the rectangle as the 3D depth is being respected. However when we disable the depth buffer for the surface, only the code order is respected and so the triangle is drawn over the rectangle.</p><p class="note"><b><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;</b>To properly preserve depth in 3D when using surfaces, not only should you have the depth buffer enabled, but you should also have z-writing and z-testing enabled. See the functions&nbsp;<span class="inline3_func"><a href="../GPU_Control/gpu_set_ztestenable.htm">gpu_set_ztestenable</a></span> and&nbsp;<span class="inline3_func"><a href="../GPU_Control/gpu_set_zwriteenable.htm">gpu_set_zwriteenable</a></span> for more information.</p><p class="note"><b><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;</b>If your game is 100% 2D or you know that you don't need a surface depth buffer, then it should be fine to simply call this function once at the start of the game to disable the buffer.</p><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">surface_depth_disable</span>(disable);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>disable</td><td><span data-keyref="Type_Bool"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Boolean</a></span></td><td>If set to <span class="inline">true</span> the depth buffer will be disabled for created surfaces.</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Void">N/A</span></p><p>&nbsp;</p><h4>Example:</h4><p class="code">var _depth_setting = surface_get_depth_disable();<br>surface_depth_disable(false);<br>surface_with_depth = surface_create(room_width, room_height);<br>surface_depth_disable(true);<br>surface_without_depth = surface_create(room_width, room_height);<br>surface_depth_disable(_depth_setting);</p><p>The above code stores the current depth buffer setting in a variable and then creates two surfaces, one with depth buffering enabled and one without, before restoring the original setting again.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Surfaces.htm">Surfaces</a></div><div style="float:right">Next:&nbsp;<a href="surface_get_height.htm">surface_get_height</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>