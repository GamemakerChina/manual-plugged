<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,a,t){let i;i=t?e.attr(t):e.html();let o=a[removeHtml(i)];if(null!=o&&o.length){a=retHtml(i);let n=0;a&&a.forEach(function(e,a){var t=o.replace("{"+n+"}",e);o=t===o?o.replace("{}",e):t,n++}),t?e.attr(t,o):e.html(o)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Any one of the following formats can be used when creating a surface:":"创建表面 时，可以使用以下任何一种格式：",Formats:"格式","It is highly recommended that all surfaces are created with a size that is a power of 2, e.g. 16, 128, 512 or 1024 pixels in size. This is not exactly necessary on certain platforms (like Windows and MacOS) but it will certainly increase compatibility on those targets, while for HTML5 and devices it is essential and very it's important that you remember this or you may run into problems later.":"强烈建议所有表面的大小均为 2 的幂，例如大小为 16、128、512 或 1024 像素。这在某些平台 (如 Windows 和 MacOS) 上并不是完全必要的，但它肯定会提高这些目标的兼容性，而对于 HTML5 和设备来说，这是必不可少的，并且记住这一点非常重要，否则以后可能会遇到问题。","It is highly recommended that all surfaces be created with a size that is a power of 2, i.e. 16, 128, 512 or 1024 pixels in size, for example. This is not exactly necessary on certain platforms (like Windows and MacOS) but it will certainly increase compatibility on those targets, while for HTML5 and devices it is essential and very it's important that you remember this or you may run into problems later.":"强烈建议创建的所有表面 的大小均为 2 的幂，例如，大小为 16、128、512 或 1024 像素。这在某些平台 (如 Windows 和 MacOS) 上并不是完全必要的，但它肯定会增加这些目标上的兼容性，而对于 HTML5 和设备来说，这是必不可少的，而且非常重要的是，你要记住这一点，否则你以后可能会遇到问题。","It is highly recommended that all surfaces be created with a size that is a power of 2, ie: 16, 128, 512 or 1024 pixels in size, for example. This is not exactly necessary on certain platforms (like Windows and MacOS) but it will certainly increase compatibility on those targets, while for HTML5 and devices it is essential and very it's important that you remember this or you may run into problems later.":"强烈建议创建大小为2的所有表面，即：例如，尺寸为16, 128,512或1024像素。在某些平台(如Windows和MacOS)上，这并不是完全必要的，但它肯定会提高这些目标的兼容性，而对于HTML5和设备来说，这是至关重要的，记住这一点非常重要，否则以后可能会遇到问题。","Surface Format Type Constant":"表面格式类型常量",'The above code checks to see if a surface exists and if it does not it will create a surface that is 1024 pixels wide and 1024 pixels high, assigning it to the variable "surf". The drawing target is then set to the new surface, which is cleared and made transparent before having the drawing target reset to the display. Finally the surface is assigned to a view.':'上面的代码检查表面是否存在，如果不存在，则会创建一个宽 1024 像素、高 1024 像素的表面，并将其分配给变量 "surf"。然后将绘图目标设置为新表面，在将绘图目标重置为显示器之前，该表面将被清除并变得透明。最后将表面分配给视图。','The above code checks to see if a surface exists and if it does not it will create a surface that is 1024 pixels wide and 1024 pixels high, assigning the index to the variable "surf". The drawing target is then set to the new surface, which is cleared and made transparent before having the drawing target reset to the display. Finally the surface is assigned to a view.':'上述代码检查表面是否存在，如果不存在，将创建一个宽度为1024像素、高度为1024像素的表面，并将索引指定给可变的"浏览"。然后将绘制目标设置为新表面，在将绘制目标重置为显示之前，新表面将被清除并变为透明。最后，将表面指定给视图。',"The height of the surface to be created":"要创建的表面的高度","The height of the surface to be created.":"要创建的表面的高度。","The width of the surface to be created":"要创建的表面的宽度","The width of the surface to be created.":"要创建的表面的宽度。","This format supports 4 channels (red, green, blue, alpha) with 4 bits each, meaning each channel has a 0-15 range":"此格式支持 4 个通道 (红、绿、蓝、Alpha)，每个通道有 4 位，这意味着每个通道的范围为 0-15","This format supports 4 channels (red, green, blue, alpha) with each channel being a 16-bit float, providing a higher precision{} {} An example use case is HDR, as this format would allow you to use values past the default 0-255 colour range ":"此格式支持 4 个通道 (红、绿、蓝、Alpha)，每个通道为 16 位浮点数，可提供更高的精度 {}{}HDR 是一个示例用例，因为此格式允许您使用超出默认 0-255 颜色范围的值","This format supports 4 channels (red, green, blue, alpha) with each channel being a 32-bit float, providing the highest precision, however this is slower to render to than 16-bit formats and is not as widely supported":"此格式支持 4 个通道 (红、绿、蓝、Alpha)，每个通道为 32 位浮点，可提供最高精度，但渲染速度慢于 16 位格式，且不受广泛支持","This format supports a single channel (red) with a 16-bit floating point value{} {} Since it only contains one channel, it takes a quarter of the space compared to the format above (which stores RGBA){} {} When read in a shader, all channels except red will be 0 ":"此格式支持具有 16 位浮点值的单个通道 (红色){}{} 因为它只包含一个通道，所以与上面的格式 (存储 RGBA) 相比，它占用空间的四分之一。{}{} 在着色器中读取时，除红色外的所有通道都将为 0","This format supports a single channel (red) with a 32-bit floating point value":"此格式支持具有 32 位浮点值的单个通道 (红色)","This format supports a single channel (red) with an 8-bit value (0-255){} {} Since it only contains one channel, it takes a quarter of the space compared to the format above (which stores RGBA){} {} When read in a shader, all channels except red will be 0 ":"此格式支持具有 8 位值 (0-255) 的单个通道(红色){}{} 因为它只包含一个通道，所以与上面的格式 (存储 RGBA) 相比，它占用的空间是上面格式的四分之一。{}{} 在着色器中读取时，除红色外的所有通道都将为 0","This function creates a new surface and returns it.":"该函数创建一个新表面并返回它。",'This function is used to create a surface and will return the index of the surface which should be stored in a variable for future function calls. When the surface is first created, it may contain "noise" as basically it is just an area of memory that is put aside for the purpose (and that memory may still contain information), so you may want to clear the surface before use with a function like {}{}draw_clear_alpha(){}{}.':'此函数用于创建表面，并将返回表面的索引，该索引应存储在变量中，以供将来调用函数时使用。首次创建表面时，它可能包含"噪波"，因为基本上它只是为此目的而放在一边的内存区域(该内存可能仍包含信息)，因此您可能希望在使用诸如{}{}draw_clear_alpha(){}{}之类的函数之前清除表面。',"This is similar to the format above, however it contains two channels: red and green":"这与上面的格式类似，但它包含两个通道：红色和绿色",'When the surface is first created, it may contain "noise" as basically it is just an area of memory that is put aside for the purpose (and that memory may still contain information), so you may want to clear the surface before use with a function like {}{}draw_clear_alpha{}{}.':'首次创建表面时，它可能包含 " 噪声"，因为基本上它只是为此目的而保留的内存区域 (并且该内存可能仍然包含信息)，因此您可能需要在使用之前清除表面类似 {}{}draw_clear_alpha{}{} 的函数。',"You can optionally specify the format that will be used to store the surface data in memory. The default format is {}surface_rgba8unorm{}.":"您可以选择指定将用于在内存中存储表面 数据的格式。默认格式为 {}surface_rgba8unorm{}。",'{}(Default) {}This format supports 4 channels (red, green, blue, alpha) with 8 bits each, meaning each channel has a 0-255 range{} {} "unorm" refers to these values being normalised into a 0-1 range when read in shaders ':'{}(默认){} 此格式支持 4 个通道 (红、绿、蓝、Alpha)，每个通道 8 位，这意味着每个通道的范围为 0-255{}{} "unorm" 是指在读取着色器时将这些值归一化为 0-1 范围',"{}{}OPTIONAL{}{}&nbsp;The format to use for storing surface data, default is&nbsp;{}surface_rgba8unorm{}":"{}{}可选{}{} 用于存储表面数据的格式，默认为 {}surface_rgba8unorm{}"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.6.8.0_2"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>surface_create</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference for surface_create"><meta name="rh-index-keywords" content="surface_create,surface_rgba8unorm,surface_r16float,surface_r32float,surface_rgba4unorm,surface_r8unorm,surface_rg8unorm,surface_rgba16float,surface_rgba32float"><meta name="search-keywords" content="surface_create,surface_rgba8unorm,surface_r8unorm,surface_rg8unorm,surface_rgba4unorm,surface_rgba16float,surface_r16float,surface_rgba32float,surface_r32float"><meta name="is_pure" content="true"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Drawing/Surfaces/surface_create_ext.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Drawing/Surfaces/surface_exists.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="surface_create"><span>surface_create</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">surface_create</span></h1><p>This function creates a new surface and returns it.</p><p>When the surface is first created, it may contain "noise" as basically it is just an area of memory that is put aside for the purpose (and that memory may still contain information), so you may want to clear the surface before use with a function like <span class="inline3_func"><a href="../Colour_And_Alpha/draw_clear_alpha.htm#h">draw_clear_alpha</a></span>.</p><p>It is highly recommended that all surfaces are created with a size that is a power of 2, e.g. 16, 128, 512 or 1024 pixels in size. This is not exactly necessary on certain platforms (like Windows and MacOS) but it will certainly increase compatibility on those targets, while for HTML5 and devices it is essential and very it's important that you remember this or you may run into problems later.</p><h2 id="formats">Formats</h2><p>You can optionally specify the format that will be used to store the surface data in memory. The default format is <span class="inline2">surface_rgba8unorm</span>.</p><p>Any one of the following formats can be used when creating a surface:</p><table id="surface_format_constant"><colgroup><col style="width:33.33%"><col style="width:33.33%"></colgroup><tbody><tr><th colspan="2"><span data-keyref="Type_Constant_Surface_Format"><a target="_blank" href="#surface_format_constant">Surface Format Constant</a></span></th></tr><tr><th>Constant</th><th>Description</th></tr><tr><td><span class="inline">surface_rgba8unorm</span></td><td><strong>(Default)</strong> This format supports 4 channels (red, green, blue, alpha) with 8 bits each, meaning each channel has a 0-255 range<br><br>"unorm" refers to these values being normalised into a 0-1 range when read in shaders</td></tr><tr><td><span class="inline">surface_r8unorm</span></td><td>This format supports a single channel (red) with an 8-bit value (0-255)<br><br>Since it only contains one channel, it takes a quarter of the space compared to the format above (which stores RGBA)<br><br>When read in a shader, all channels except red will be 0</td></tr><tr><td><span class="inline">surface_rg8unorm</span></td><td>This is similar to the format above, however it contains two channels: red and green</td></tr><tr><td><span class="inline">surface_rgba4unorm</span></td><td>This format supports 4 channels (red, green, blue, alpha) with 4 bits each, meaning each channel has a 0-15 range</td></tr><tr><td><span class="inline">surface_rgba16float</span></td><td>This format supports 4 channels (red, green, blue, alpha) with each channel being a 16-bit float, providing a higher precision<br><br>An example use case is HDR, as this format would allow you to use values past the default 0-255 colour range</td></tr><tr><td><span class="inline">surface_r16float</span></td><td>This format supports a single channel (red) with a 16-bit floating point value<br><br>Since it only contains one channel, it takes a quarter of the space compared to the format above (which stores RGBA)<br><br>When read in a shader, all channels except red will be 0</td></tr><tr><td><span class="inline">surface_rgba32float</span></td><td>This format supports 4 channels (red, green, blue, alpha) with each channel being a 32-bit float, providing the highest precision, however this is slower to render to than 16-bit formats and is not as widely supported</td></tr><tr><td><span class="inline">surface_r32float</span></td><td>This format supports a single channel (red) with a 32-bit floating point value</td></tr></tbody></table><p>&nbsp;</p><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">surface_create</span>(w, h, [format]);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>w</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The width of the surface to be created</td></tr><tr><td>h</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The height of the surface to be created</td></tr><tr><td>format</td><td><span data-keyref="Type_Constant_Surface_Format"><a target="_blank" href="#surface_format_constant">Surface Format Constant</a></span></td><td><span data-conref="../../../../assets/snippets/Tag_optional.hts"><span class="optional">OPTIONAL</span></span>&nbsp;The format to use for storing surface data, default is&nbsp;<span class="inline2">surface_rgba8unorm</span></td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_ID_Surface"><a target="_blank" href="surface_create.htm">Surface</a></span>&nbsp;(or -1 if anything went wrong)</p><p>&nbsp;</p><h4>Example:</h4><p class="code">if (!surface_exists(surf))<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;surf = <span data-field="title" data-format="default">surface_create</span>(1024, 1024);<br>&nbsp;&nbsp;&nbsp;&nbsp;surface_set_target(surf);<br>&nbsp;&nbsp;&nbsp;&nbsp;draw_clear_alpha(c_black, 0);<br>&nbsp;&nbsp;&nbsp;&nbsp;surface_reset_target();<br>&nbsp;&nbsp;&nbsp;&nbsp;view_surface_id[0] = surf;<br>}</p><p>The above code checks to see if a surface exists and if it does not it will create a surface that is 1024 pixels wide and 1024 pixels high, assigning it to the variable "surf". The drawing target is then set to the new surface, which is cleared and made transparent before having the drawing target reset to the display. Finally the surface is assigned to a view.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Surfaces.htm">Surfaces</a></div><div style="float:right">Next:&nbsp;<a href="surface_create_ext.htm">surface_create_ext</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>