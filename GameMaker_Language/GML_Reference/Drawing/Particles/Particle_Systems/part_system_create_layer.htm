<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let n;n=a?e.attr(a):e.html();let o=t[removeHtml(n)];if(null!=o&&o.length){t=retHtml(n);let s=0;t&&t.forEach(function(e,t){var a=o.replace("{"+s+"}",e);o=a===o?o.replace("{}",e):a,s++}),a?e.attr(a,o):e.html(o)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"A system not flagged as persistent is automatically destroyed at the end of the room it was created in (this is the same as if you had called the function {}{}part_system_destroy{}{}&nbsp;and will also destroy any emitters associated with the system). However, when flagged as persistent, the system will be carried to the next room when the room is changed, and if the following room does {}not{} have a layer with the same name or depth as the one assigned, then a new layer will be created for the system that is persisting across the rooms, and it will be named the same as the original layer. When changing rooms, if there is another layer in the following rooms with the same name, then the persisted instance will be assigned to the layer with that name {}regardless of the depth of the layer{}. Finally, if a persisted system moves to a room with a layer at the same depth as the layer the system was created on, it will {}not{} be assigned to this layer, but instead a new layer will be created at the same depth (with the same name as the original layer).":"未标记为持久的系统将在创建它的房间结束时自动销毁（这与调用函数 {}{}part_system_destroy{}{} 相同， 并且还会销毁与系统关联的所有发射器）。<br>\n但是，当标记为持久性时，系统将在房间更改时转到下一个房间，并且如果下一个房间 {} 不 {} 具有与所分配的层具有相同名称或深度的层，则将为跨房间持久性的系统创建新层，并将其命名为与原始层相同的名称。<br>\n当更改房间时，如果在以下房间中存在另一个同名的层，则持久化实例将被分配给具有该名称的层 {}，而不管层 {} 的深度如何。<br>\n最后，如果一个持久化系统移动到一个房间，而该房间的层与创建该系统的层具有相同的深度，则它将 {} 不会 {} 指定给该层，而是在相同的深度创建一个新层（与原始层具有相同的名称）。","Flag the particle system as persistent (set to {}true{}) or not (set to {}false{})":"将粒子系统标记为持久(设置为{}true{})或不(设置为{}false{})","Optionally you can provide a&nbsp;{}{}Particle System Asset{}{}&nbsp;created using&nbsp;{}The Particle System Editor{}. Doing so will create the system defined in that asset, with all of its emitters.":"也可以提供使用{4}粒子系统编辑器{5}创建的{}{}粒子系统资源{}{}。执行此操作将创建在该资源中定义的系统及其所有发射器。","The above code will create a new particle system on the given layer and flag it as persisting over subsequent rooms. The ID for the particle system is stored in a global scope variable for future reference.":"上述代码将在给定图层上创建新的粒子系统，并将其标记为在后续房间上保留。粒子系统的Id存储在全局范围变量中，以供将来参考。","The above code will create a new particle system on the given layer from the {}ps_Explosion{} asset, and flag it as persisting over subsequent rooms. The ID for the particle system is stored in a global scope variable {}p_sys{} for future reference.":"以上代码将在给定层上从 {}ps_Explosion{} 资源创建一个新粒子系统，并将其标记为在后续房间中保持。 粒子系统的 ID 存储在全局作用域变量 {}p_sys{} 中，以供将来参考。","The function will return a unique ID value for the particle system that should be used in all further function calls where you need to give a system ID.":"该函数将为粒子系统返回一个唯一的Id值，该值应在需要提供系统Id的所有其他函数调用中使用。","The layer ID (or name) to assign the particle system to (can be any layer type)":"要指定粒子系统的图层Id(或名称)(可以是任何图层类型)","This function creates a new particle system on a given layer&nbsp;and returns its unique index number.":"此函数在给定层上创建新粒子系统 并返回其唯一索引号。",'This function will create a new particle system on a given layer. You give the unique layer ID as returned by the function {}{}layer_create(){}{} or the name of the layer to use as a string - for example "instance_layer" - and then flag the system as being persistent or not. If the system is not flagged as persistent then it will be automatically destroyed at the end of the room it was created in (this is the same as if you had called the function {}{}part_system_destroy(){}{} and will also destroy any emitters associated with the system). However, when flagged as persistent, the system will be carried to the next room when the room is changed, and if the following room does {}not{} have a layer with the same name or depth as the one assigned, then a new layer will be created for the system that is persisting across the rooms, and it will be named the same as original layer. When changing rooms, if there is another layer in the following rooms with the same name, then the persisted instance will be assigned to the layer with the that name {}regardless of the depth of the layer{}. Finally, if a persisted system moves to a room with a layer at the same depth as the layer the system was created on, it will {}not{} be assigned to this layer, but instead a new layer will be created at the same depth (with the same name as the original layer).':'此函数将在给定层上创建新的粒子系统。为函数{}{}layer_create(){}{}返回的唯一层ID或要用作字符串的层的名称(例如"instance_layer")指定，然后将系统标记为持久或不持久。如果系统未标记为持久性，则会在创建它的房间末尾自动销毁(这与您调用函数{}{}part_system_destroy(){}{}相同，并且还会销毁与系统关联的任何发射器)。但是，如果标记为"持久"，则在更改房间时系统将被带到下一个房间，并且如果下面的房间{}没有与指定的房间具有相同名称或深度的图层，则将为房间中持续存在的系统创建一个新图层，并且该图层将被命名为与原始图层相同的图层。更换房间时，如果下列房间中有另一个同名图层，则无论图层{}的深度如何，都会将持久化实例指定给同名图层{}。最后，如果持久化系统移动到与创建系统时所在的图层深度相同的房间，则不会将其{}指定给此图层，而是在相同深度(与原始图层同名)创建新图层。','You give the unique layer ID as returned by the function&nbsp;{}{}layer_create{}{} or the name of the layer to use as a string - for example "instance_layer" - and then flag the system as being persistent or not.':"您可以提供函数&nbsp;{}{}layer_create{}{}返回的唯一层ID或用作字符串的层名称（例如“instance_layer”），然后将系统标记为持久性或非持久性。","{}IMPORTANT!{} If you flag the particle system as persistent, then it (and any emitters assigned to it) will need to be cleaned up manually using the appropriate destroy functions when not in use, otherwise you risk a memory leak that will negatively impact your final game.":"{}重要！{}如果将粒子系统标记为持久性，则在不使用粒子系统时，需要使用相应的销毁函数手动清除粒子系统(以及分配给粒子系统的任何发射器)，否则将面临内存泄漏的风险，从而对最终游戏造成负面影响。","{}{}IMPORTANT{}{}&nbsp;If you flag the particle system as persistent, then it (and any emitters assigned to it) will need to be cleaned up manually using the appropriate destroy functions when not in use, otherwise you risk a memory leak that will negatively impact your final game.":"{}{} 重要{}{} 如果您将粒子系统标记为持久，则需要在不使用时使用相应的销毁功能手动清理该粒子系统（以及指定给它的任何发射器），否则您将面临内存泄漏的风险，这将对最终游戏产生负面影响。","{}{}OPTIONAL{}{}&nbsp;The particle system asset to create an instance of":"{}{}可选{}{} 要创建实例的粒子系统资源"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../../..",gTopicId="8.2.2.6.10.1.0_3"</script><script type="text/javascript" src="../../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>part_system_create_layer</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../../assets/css/default.css" type="text/css"><script src="../../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference page for part_system_create_layer"><meta name="rh-index-keywords" content="part_system_create_layer"><meta name="search-keywords" content="part_system_create_layer"><meta name="is_pure" content="true"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Drawing/Particles/Particle_Systems/part_system_get_layer.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Drawing/Particles/Particle_Systems/part_system_create.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="part_system_create_layer"><span>part_system_create_layer</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">part_system_create_layer</span></h1><p>This function creates a new particle system on a given layer&nbsp;and returns its unique index number.</p><p>You give the unique layer ID as returned by the function&nbsp;<span class="inline3_func"><a href="../../../Asset_Management/Rooms/General_Layer_Functions/layer_create.htm">layer_create</a></span> or the name of the layer to use as a string - for example "instance_layer" - and then flag the system as being persistent or not.</p><p>Optionally you can provide a&nbsp;<span data-keyref="Type_Asset_ParticleSystem"><a target="_blank" href="../../../../../The_Asset_Editors/Particle_Systems.htm">Particle System Asset</a></span>&nbsp;created using&nbsp;<a href="../../../../../The_Asset_Editors/Particle_Systems.htm">The Particle System Editor</a>. Doing so will create the system defined in that asset, with all of its emitters.</p><p>A system not flagged as persistent is automatically destroyed at the end of the room it was created in (this is the same as if you had called the function <span class="inline3_func"><a href="part_system_destroy.htm">part_system_destroy</a></span>&nbsp;and will also destroy any emitters associated with the system). However, when flagged as persistent, the system will be carried to the next room when the room is changed, and if the following room does <i>not</i> have a layer with the same name or depth as the one assigned, then a new layer will be created for the system that is persisting across the rooms, and it will be named the same as the original layer. When changing rooms, if there is another layer in the following rooms with the same name, then the persisted instance will be assigned to the layer with that name <i>regardless of the depth of the layer</i>. Finally, if a persisted system moves to a room with a layer at the same depth as the layer the system was created on, it will <i>not</i> be assigned to this layer, but instead a new layer will be created at the same depth (with the same name as the original layer).</p><p class="note"><span data-conref="../../../../../assets/snippets/Tag_important.hts"><span class="important">IMPORTANT</span></span>&nbsp;If you flag the particle system as persistent, then it (and any emitters assigned to it) will need to be cleaned up manually using the appropriate destroy functions when not in use, otherwise you risk a memory leak that will negatively impact your final game.</p><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">part_system_create_layer</span>(layer_id, persistent, [partsys]);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>layer</td><td><span data-keyref="Type_String"><a target="_blank" href="../../../../GML_Overview/Data_Types.htm">String</a></span>&nbsp;or&nbsp;<span data-keyref="Type_ID_Layer"><a target="_blank" href="../../../Asset_Management/Rooms/General_Layer_Functions/layer_get_id.htm">Layer</a></span></td><td>The layer ID (or name) to assign the particle system to (can be any layer type)</td></tr><tr><td>persistent</td><td><span data-keyref="Type_Bool"><a target="_blank" href="../../../../GML_Overview/Data_Types.htm">Boolean</a></span></td><td>Flag the particle system as persistent (set to <span class="inline">true</span>) or not (set to <span class="inline">false</span>)</td></tr><tr><td>partsys</td><td><span data-keyref="Type_Asset_ParticleSystem"><a target="_blank" href="../../../../../The_Asset_Editors/Particle_Systems.htm">Particle System Asset</a></span></td><td><span data-conref="../../../../../assets/snippets/Tag_optional.hts"><span class="optional">OPTIONAL</span></span>&nbsp;The particle system asset to create an instance of</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_ID_PartSys"><a target="_blank" href="part_system_create.htm">Particle System Instance</a></span></p><p>&nbsp;</p><h4>Example:</h4><p class="code">global.p_sys = <span data-field="title" data-format="default">part_system_create_layer</span>("effects_layer", true, ps_Explosion);</p><p>The above code will create a new particle system on the given layer from the <span class="inline2">ps_Explosion</span> asset, and flag it as persisting over subsequent rooms. The ID for the particle system is stored in a global scope variable <span class="inline2">p_sys</span> for future reference.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="Particle_Systems.htm">Particle Systems</a></div><div style="float:right">Next:&nbsp;<a href="part_system_get_layer.htm">part_system_get_layer</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>