<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let n;n=a?e.attr(a):e.html();let s=t[removeHtml(n)];if(null!=s&&s.length){t=retHtml(n);let o=0;t&&t.forEach(function(e,t){var a=s.replace("{"+o+"}",e);s=a===s?s.replace("{}",e):a,o++}),a?e.attr(a,s):e.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"A single floating point value":"单个浮点值","Blend weights are usually stored in an array and then accessed using blend indices, but you can see here that instead of defining {}in_BlendIndices{} as an {}ivec4{} attribute, it's a {}vec4{}, then cast to an {}ivec4{} in the code. This is then used to index the array created using the {}gm_Matrix{} (you can only access an array using an {}INT{} value - not a float).":"混合权重通常存储在数组中，然后使用混合索引进行访问，但您可以在此看到，它不是将{}in_BlendIndices{}定义为{}ivec 4{}属性，而是将其转换为代码中的{}ivec 4{}。然后，这将用于为使用{}gm_Matrix{}创建的数组编制索引(您只能使用{}Int{}值而不能使用浮点数访问数组)。","Four component unsigned byte values (from 0 to 255)":"四个分量无符号字节值(从0到255)","Four component values (r, g, b, a)":"四个分量值(r、g、b、a)","Four floating point values":"四个浮点值","GLSL ES does {}not{} support integer attributes, so passing in {}ivec4{}'s does not work (this type is usually used when passing in {}vertex_usage_blendindices{}). What you need to do is pass in texture coordinates and then in the shader, convert them to {}ivec4{} like this:":"GLSL ES {}{}不支持整数属性，因此传入{}ivec 4{}不起作用(通常在传入{}vertex_usage_blendindices{}时使用此类型)。需要做的是传入纹理坐标，然后在着色器中，将它们转换为{}ivec 4{}，如下所示：","In general you should use {}vertex_usage_textcoord{} for all extra parameters where possible, as types like {}vertex_usage_blendweight{} and {}vertex_usage_tangent{} are close to deprecated in most shader languages, and probably won't convert properly. Instead use {}vec{}, {}vec2{}, {}vec3{} or {}vec4{} types {}vertex_usage_textcoord{} and everything should work fine.":"通常，应尽可能对所有额外参数使用{}vertex_usage_textcoord{}，因为在大多数着色器语言中，类型(如{}vertex_usage_blendweight{}和{}vertex_usage_tangent{})接近不推荐使用的类型，并且可能无法正确转换。而是使用{}向量{}、{}vec 2{}、{}vec 3{}或{}vec 4{}类型{}vertex_usage_textcoord{}，一切都应该正常。","The above code creates a new vertex format with just texture and 3 custom floating point values for position. It then stores the format in the variable {}my_format{}.":"上面的代码创建了一个新的顶点格式，仅包含纹理和 3 个自定义浮点值的位置。然后，它将格式存储在变量 {}my_format{} 中。",'The above code will create a new vertex format with just texture and 3 custom floating point values for position. It is then stores the format id in the variable "my_format".':'上述代码将创建一个新的顶点格式，只有纹理和3个用于定位的自定义浮点值。然后将格式ID存储在变量"my_format"中。',"The available values to use are defined by the data type constant that you choose, listed below:&nbsp;":"要使用的可用值由您选择的数据类型常量定义，如下所示：","The data type that this custom vertex data will hold (see the {}{}type constants{}{} listed above).":"此自定义顶点数据将保留的数据类型(请参阅上面列出的{}{}类型常量{}{})。","The use that the data will get (see the {}{}usage constants{}{} listed above).":"数据将获得的用途 (请参阅上面列出的 {}{} 使用常量 {}{})。","The use that the data will get(see the {}{}usage constants{}{} listed above).":"数据将获得的用途(请参阅上面列出的{}{}使用常量{}{})。","The {}vertex_format_add_custom(){} function only supports {}vertex_usage_position{}, {}vertex_usage_colour{}, {}vertex_usage_normal{} and {}vertex_usage_textcoord{} when using GLSL shaders. These will map to the shader attributes {}in_Position{}, {}in_Colour[0 - ...]{}, {}in_Normal{} respectively (anything that is not one of these three attributes - e.g.: texture coordinates - can be mapped to any attribute you define).":"使用 GLSL 着色器时，{}vertex_format_add_custom(){} 函数仅支持 {}vertex_usage_position{}、{}vertex_usage_colour{}、{}vertex_usage_normal{} 和 {}vertex_usage_textcoord{}。这些将分别映射到着色器属性 {}in_Position{}、{}in_Colour[0 - ...]{}、{}in_Normal{}( 任何不是这三个属性之一的属性 - 例如：纹理坐标 - 都可以是映射到您定义的任何属性)。","The {}vertex_format_add_custom(){} function only supports {}vertex_usage_position{}, {}vertex_usage_colour{}, {}vertex_usage_normal{} and {}vertex_usage_textcoord{} when using GLSL shaders. These will map to the shader attributes {}in_Position{}, {}in_Colour[0 - ...]{}, {}in_Normal{} respectively (anything that is not one of these three attributes - eg: texture coordinates - can be mapped to any attribute you define).":"{}vertex_format_add_custom(){}函数在使用Glsl着色器时仅支持{}vertex_usage_position{}、{}vertex_usage_colour{}、{}vertex_usage_normal{}和{}vertex_usage_textcoord{}。这些属性将分别映射到着色器属性{}in_Position{}、{}in_Colour[ 0-...]{}、{}in_Normal{}(不属于这三个属性之一的任何属性-例如：纹理坐标-可以映射到您定义的任何属性)。","This function adds a custom data type for specific vertex format attributes as part of the new vertex format being created.":"此函数为特定顶点格式属性添加自定义数据类型，作为创建的新顶点格式的一部分。","This function permits you to use a custom data type for specific vertex format attributes as part of the new vertex format being created. The available values to use are defined by the data type constant that you choose, listed below:":"此函数允许您将特定顶点格式属性的自定义数据类型用作正在创建的新顶点格式的一部分。可用的值由您选择的数据类型常量定义，如下所示：","Three floating point values":"三个浮点值","Two floating point values":"两个浮点值","UV coordinates (u, v)":"UV坐标(u， v)","Vertex Data Type Constant":"顶点数据类型常量","Vertex Usage Type Constant":"顶点使用类型常量","binormal values":"二元值","colour values (r, g, b, a)":"颜色值(r，g，b，a)","fog values":"雾值","position values (x, y, z)":"位置值(x、y、z)","sampler index":"取样指数","tangent values":"切线值","the blendweight of the input matrix (for skeletal animation, for example)":"输入矩阵的混合权重(例如，对于骨骼动画)","the indices of the matrices to use (for skeletal animation, for example)":"矩阵的索引(例如骨骼动画)","vertex depth buffer value":"顶点深度缓冲区值","vertex normal values (nx, ny, nz)":"顶点法线值(nx, ny, nz)","{} The use that these constants will be put to&nbsp;also needs to be defined so that the values can be \"bound\" properly within the shader being created. This is necessary due to the fact that DirectX and OpenGL have different requirements so if you don't bind them properly, they won't come through right in the shader. The available usage constants that you can choose are listed below and those you use will depend on the specifics of the shader being created:&nbsp;":'{} 还需要定义这些常量的用途，以便可以在所创建的着色器中正确 " 绑定 " 这些值。这是必要的，因为 DirectX 和 OpenGL 有不同的要求，因此如果您没有正确绑定它们，它们将无法在着色器中正确通过。下面列出了您可以选择的可用使用常量，您使用的常量取决于所创建的着色器的具体情况：',"{} The use that these constants will be put too also needs to be defined so that the values can be \"bound\" properly within the shader being created. This is necessary due to the fact that DX and OpenGL have different requirements so if you don't bind them properly, they won't come through right in the shader. The available usage constants that you can choose are listed below and those you use will depend on the specifics of the shader being created:":'{}还需要定义这些常量的用法，以便可以在要创建的着色器中正确"绑定"这些值。这是必要的，因为Dx和OpenGL有不同的要求，所以如果没有正确绑定它们，它们将不会直接在着色器中显示。下面列出了您可以选择的可用使用常量，您使用的常量将取决于正在创建的着色器的具体信息：',"{} There are some important things to note when using custom formats like these:":"{}在使用这些自定义格式时，需要注意一些重要事项："},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.6.7.0_14"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>vertex_format_add_custom</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference for vertex_format_add_custom"><meta name="rh-index-keywords" content="vertex_format_add_custom,vertex_type_float1,vertex_type_float2,vertex_type_float3,vertex_type_float4,vertex_type_colour,vertex_type_ubyte4,vertex_usage_position,vertex_usage_colour,vertex_usage_normal,vertex_usage_textcoord,vertex_usage_blendweight,vertex_usage_blendindices,vertex_usage_depth,vertex_usage_tangent,vertex_usage_binormal,vertex_usage_fog,vertex_usage_sample"><meta name="search-keywords" content="vertex_format_add_custom,vertex_type_float1,vertex_type_float2,vertex_type_float3,vertex_type_float4,vertex_type_colour,vertex_type_ubyte4,vertex_usage_position,vertex_usage_colour,vertex_usage_normal,vertex_usage_textcoord,vertex_usage_blendweight,vertex_usage_blendindices,vertex_usage_depth,vertex_usage_tangent,vertex_usage_binormal,vertex_usage_fog,vertex_usage_sample"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_format_end.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Drawing/Primitives/vertex_format_add_normal.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="vertex_format_add_custom"><span>vertex_format_add_custom</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">vertex_format_add_custom</span></h1><p>This function adds a custom data type for specific vertex format attributes as part of the new vertex format being created.</p><p>The available values to use are defined by the data type constant that you choose, listed below:&nbsp;</p><table><colgroup><col><col></colgroup><tbody><tr><th colspan="2"><span data-keyref="Type_Constant_Draw_Vertex_Data_Type"><a target="_blank" href="vertex_format_add_custom.htm">Vertex Data Type Constant</a></span></th></tr><tr><th>Constant</th><th>Description</th></tr><tr><td><span class="inline">vertex_type_float1</span></td><td>A single floating point value</td></tr><tr><td><span class="inline">vertex_type_float2</span></td><td>Two floating point values</td></tr><tr><td><span class="inline">vertex_type_float3</span></td><td>Three floating point values</td></tr><tr><td><span class="inline">vertex_type_float4</span></td><td>Four floating point values</td></tr><tr><td><span class="inline">vertex_type_colour</span></td><td>Four component values (r, g, b, a)</td></tr><tr><td><span class="inline">vertex_type_ubyte4</span></td><td>Four component unsigned byte values (from 0 to 255)</td></tr></tbody></table><p><br>The use that these constants will be put to&nbsp;also needs to be defined so that the values can be "bound" properly within the shader being created. This is necessary due to the fact that DirectX and OpenGL have different requirements so if you don't bind them properly, they won't come through right in the shader. The available usage constants that you can choose are listed below and those you use will depend on the specifics of the shader being created:&nbsp;</p><table><colgroup><col><col></colgroup><tbody><tr><th colspan="2"><span data-keyref="Type_Constant_Draw_Vertex_Usage"><a target="_blank" href="vertex_format_add_custom.htm">Vertex Usage Type Constant</a></span></th></tr><tr><th>Constant</th><th>Description</th></tr><tr><td><span class="inline">vertex_usage_position</span></td><td>position values (x, y, z)</td></tr><tr><td><span class="inline">vertex_usage_colour</span></td><td>colour values (r, g, b, a)</td></tr><tr><td><span class="inline">vertex_usage_normal</span></td><td>vertex normal values (nx, ny, nz)</td></tr><tr><td><span class="inline">vertex_usage_textcoord</span></td><td>UV coordinates (u, v)</td></tr><tr><td><span class="inline">vertex_usage_blendweight</span></td><td>the blendweight of the input matrix (for skeletal animation, for example)</td></tr><tr><td><span class="inline">vertex_usage_blendindices</span></td><td>the indices of the matrices to use (for skeletal animation, for example)</td></tr><tr><td><span class="inline">vertex_usage_depth</span></td><td>vertex depth buffer value</td></tr><tr><td><span class="inline">vertex_usage_tangent</span></td><td>tangent values</td></tr><tr><td><span class="inline">vertex_usage_binormal</span></td><td>binormal values</td></tr><tr><td><span class="inline">vertex_usage_fog</span></td><td>fog values</td></tr><tr><td><span class="inline">vertex_usage_sample</span></td><td>sampler index</td></tr></tbody></table><p><br>There are some important things to note when using custom formats like these:</p><ul class="colour"><li>The <span class="inline">vertex_format_add_custom()</span> function only supports <span class="inline">vertex_usage_position</span>, <span class="inline">vertex_usage_colour</span>, <span class="inline">vertex_usage_normal</span> and <span class="inline">vertex_usage_textcoord</span> when using GLSL shaders. These will map to the shader attributes <span class="inline">in_Position</span>, <span class="inline">in_Colour[0 - ...]</span>, <span class="inline">in_Normal</span> respectively (anything that is not one of these three attributes - e.g.: texture coordinates - can be mapped to any attribute you define).</li><li>In general you should use <span class="inline">vertex_usage_textcoord</span> for all extra parameters where possible, as types like <span class="inline">vertex_usage_blendweight</span> and <span class="inline">vertex_usage_tangent</span> are close to deprecated in most shader languages, and probably won't convert properly. Instead use <span class="inline">vec</span>, <span class="inline">vec2</span>, <span class="inline">vec3</span> or <span class="inline">vec4</span> types <span class="inline">vertex_usage_textcoord</span> and everything should work fine.</li><li>GLSL ES does <i>not</i> support integer attributes, so passing in <span class="inline">ivec4</span>'s does not work (this type is usually used when passing in <span class="inline">vertex_usage_blendindices</span>). What you need to do is pass in texture coordinates and then in the shader, convert them to <span class="inline">ivec4</span> like this:</li></ul><p>&nbsp;</p><p class="code">attribute vec3 in_Position;<br>attribute vec4 in_BlendIndices;<br>attribute vec4 in_BlendWeights;<br><br>varying vec4 v_vColour;<br>varying mat4 v_mat;<br><br>void main()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * vec4( in_Position.xyz, 1.0);<br>&nbsp;&nbsp;&nbsp;&nbsp;v_vColour = in_BlendWeights;<br>&nbsp;&nbsp;&nbsp;&nbsp; ivec4 t = ivec4(in_BlendIndices);<br>&nbsp;&nbsp;&nbsp;&nbsp; v_mat = gm_Matrices[ t.x ];<br>}</p><ul class="colour"><li>Blend weights are usually stored in an array and then accessed using blend indices, but you can see here that instead of defining <span class="inline">in_BlendIndices</span> as an <span class="inline">ivec4</span> attribute, it's a <span class="inline">vec4</span>, then cast to an <span class="inline">ivec4</span> in the code. This is then used to index the array created using the <span class="inline">gm_Matrix</span> (you can only access an array using an <span class="inline">INT</span> value - not a float).</li></ul><p>&nbsp;</p><ul class="colour"><br>&nbsp;</ul><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">vertex_format_add_custom</span>(type, usage);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>type</td><td><span data-keyref="Type_Constant_Draw_Vertex_Data_Type"><a target="_blank" href="vertex_format_add_custom.htm">Vertex Data Type Constant</a></span></td><td>The data type that this custom vertex data will hold (see the <b><i>type constants</i></b> listed above).</td></tr><tr><td>usage</td><td><span data-keyref="Type_Constant_Draw_Vertex_Usage"><a target="_blank" href="vertex_format_add_custom.htm">Vertex Usage Type Constant</a></span></td><td>The use that the data will get (see the <b><i>usage constants</i></b> listed above).</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Void">N/A</span></p><p>&nbsp;</p><h4>Example:</h4><p class="code">vertex_format_begin();<br>vertex_format_add_texcoord();<br>vertex_format_add_custom(vertex_type_float3, vertex_usage_position);<br>my_format = vertex_format_end();</p><p>The above code creates a new vertex format with just texture and 3 custom floating point values for position. It then stores the format in the variable <span class="inline2">my_format</span>.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="Primitives_And_Vertex_Formats.htm">Primitives&nbsp;And Vertex Formats</a></div><div style="float:right">Next:&nbsp;<a href="vertex_format_end.htm">vertex_format_end</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>