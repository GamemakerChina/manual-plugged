<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,i){let r;r=i?e.attr(i):e.html();let o=t[removeHtml(r)];if(null!=o&&o.length){t=retHtml(r);let n=0;t&&t.forEach(function(e,t){var i=o.replace("{"+n+"}",e);o=i===o?o.replace("{}",e):i,n++}),i?e.attr(i,o):e.html(o)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"A primitive is a type of drawing done using points to define what is shown on the screen. They can be made up of single points, lines or triangles and can be coloured, have alpha blending and even be given a texture, which means that they can be used to create some very exciting effects in your 2D and 3D games!":"图元是一种使用点来定义屏幕上显示内容的绘图类型。它们可以由单个点、线或三角形组成，可以着色、进行 Alpha 混合，甚至可以赋予纹理，这意味着它们可以用来在 2D 和 3D 游戏中创建一些非常令人兴奋的效果！",'A primitive is a type of drawing done using points to define what is shown on the screen. They can be made up of single points, lines, or triangles and can be coloured, have alpha blending and even be given a texture, which means that they can be used to create some very exciting effects in a 2D game! For example, you can create a rectangle using multiple triangle primitives, then texture it with a flag sprite and in the draw event of an instance have that flag "wave" in the wind and distort the sprite you used by simply modifying the points that form the primitive.':'基元(图形基元,图元,图形输出原语)是一种使用点来定义屏幕上显示的内容的绘制类型。它们可以由单点、线或三角形组成，可以着色，有阿尔法混合，甚至可以赋予纹理，这意味着它们可以用来在2D游戏中创造一些非常令人兴奋的效果！例如，您可以使用多个三角形基元创建一个矩形，然后使用标志精灵对其进行纹理化，并且在实例的绘制事件中，通过简单地修改形成基元的点来使标志"波浪"在风中扭曲您使用的精灵。',"A {}vertex format{} lists the attributes that are stored for a vertex in order. You start defining one with&nbsp;{}{}vertex_format_begin{}{}, then add the attributes using the {}vertex_format_add_*{} functions and finally end it using&nbsp;{}{}vertex_format_end{}{}.":"{} 顶点格式 {} 按顺序列出为顶点存储的属性。您首先使用 {}{}vertex_format_begin{}{} 定义一个属性，然后使用 {}vertex_format_add_*{} 函数添加属性，最后使用 {}{}vertex_format_end{}{} 结束。","Creating Primitives":"创建基元","For an overview of how to build primitives using the vertex functions, see:":"有关如何使用顶点函数构建基元的概述，请参阅：",'For example, you can create a rectangle using two triangle primitives, then texture it with a flag sprite and in the Draw event of an instance have that flag "wave" in the wind and distort the sprite you used by simply modifying the points that form the primitive.{}{}':'例如，您可以使用两个三角形基元创建一个矩形，然后使用标志精灵对其进行纹理化，并在实例的绘制事件中让该标志在风中 " 波动"，并通过简单地修改形成的点来扭曲您使用的精灵原语。{}{}',"Function Reference":"功能参考","Guide To Primitives And Vertex Building":"基元和顶点构建指南","In the code examples above, the UVs are provided differently for vertex buffers. This is because the UVs are interpreted differently by both sets of functions:&nbsp;":"在上面的代码示例中，为顶点缓冲区提供了不同的 UV。这是因为两组函数对 UV 的解释不同：","Information on drawing primitives can be found on the following pages:":"有关绘制基元的信息，请参见以下页面：","Once you have created your vertex format (see the section above) you can then use it to build the primitives that you want to draw using the following veretx buffer functions:":"创建顶点格式后(请参阅上面的部分)，您可以使用它来构建要使用以下veretx缓冲区函数绘制的基元：","Once you have created your vertex format (see the section above) you can then use it to build the primitives that you want to draw using the following vertex buffer functions:":"创建顶点格式后 (请参阅上面的部分)，您可以使用它来构建您想要使用以下顶点缓冲区函数绘制的图元：","Primitive Functions":"基元函数",Primitives:"基元","Primitives And Vertex Formats":"基元和顶点格式","Texture Coordinates":"纹理坐标","The following is a complete example that makes use of&nbsp;{}GameMaker{}'s default&nbsp;{}passthrough vertex format{}:&nbsp;":"以下是使用 {}GameMaker{} 的默认 {} 直通顶点格式 {} 的完整示例：","The function&nbsp;{}{}vertex_texcoord{}{}&nbsp;doesn't map the texture coordinates that you pass it to any sprite in a texture page. Therefore, (0, 0) is the top-left corner of the texture page and (1, 1) is the bottom-right corner of the texture page, i.e. the range [0, 1] covers the entire texture page.":"函数 {}{}vertex_texcoord{}{} 不会将您传递的纹理坐标映射到纹理页面中的任何精灵。因此，(0, 0) 是纹理页的左上角，(1, 1) 是纹理页的右下角，即范围 [0, 1] 覆盖了整个纹理页。","The functions&nbsp;{}{}draw_vertex_texture{}{}&nbsp;and&nbsp;{}{}draw_vertex_texture_colour{}{}&nbsp;map (0, 0) to the top-left corner of the sprite's region on the texture page and (1, 1) to the bottom-right corner of the sprite's region on the texture page.":"函数 {}{}draw_vertex_texture{}{} 和 {}{}draw_vertex_texture_colour{}{} 将 (0, 0) 映射到纹理页面上精灵区域的左上角，将 (1, 1) 映射到底部- 纹理页面上精灵区域的右角。","The points of a primitive are called {}vertices{} (singular {}{}vertex{}{}) and store data about their position, colour, texture and possibly other information. The GPU then draws these vertices using the primitive {}type{}&nbsp;that you provide:&nbsp;":"图元的点称为 {} 顶点 {}( 单个 {}{} 顶点 {}{})，并存储有关其位置、颜色、纹理和可能的其他信息的数据。然后，GPU 使用您提供的原始 {} 类型 {} 绘制这些顶点：","The primitive functions: the&nbsp;{}draw_primitive_*{} and {}draw_vertex_*{} functions":"基元函数：{}draw_primitive_*{} 和 {}draw_vertex_*{} 函数","The {}draw_primitive_*{} functions allow you to define primitives and draw them directly to the screen (or to a {}surface{}). You call&nbsp;{}{}draw_primitive_begin{}{}&nbsp;or&nbsp;{}{}draw_primitive_begin_texture{}{}, then define the vertices with any of the {}draw_vertex_*{} functions and finally call&nbsp;{}{}draw_primitive_end{}{}&nbsp;to draw the primitive.":"{}draw_primitive_*{} 函数允许您定义基元并将其直接绘制到屏幕 (或 {} 表面 {})。您调用 {}{}draw_primitive_begin{}{} 或 {}{}draw_primitive_begin_texture{}{}，然后使用任意 {}draw_vertex_*{} 函数定义顶点，最后调用 {}{}draw_primitive_end{}{} 以绘制图元。","Vertex Buffers":"顶点缓冲区","Vertex Formats":"顶点格式","Vertex buffers":"顶点缓冲区",'Vertex buffers are the more advanced way to define reusable primitives. They are&nbsp;{}Buffers{}&nbsp;that store data about vertices specifically ("vertex data").&nbsp;With vertex buffers you split up the definition of the primitive and its drawing.':'顶点缓冲区是定义可重用图元的更高级方法。它们是专门存储有关顶点的数据 (" 顶点数据 ") 的 {} 缓冲区 {}。使用顶点缓冲区，您可以将图元的定义及其绘制分开。',"You create a new, empty vertex buffer using&nbsp;{}{}vertex_create_buffer{}{}&nbsp;/&nbsp;{}{}vertex_create_buffer_ext{}{} or create one and fill it with the data in a buffer using&nbsp;{}{}vertex_create_buffer_from_buffer{}{}&nbsp;/&nbsp;{}{}vertex_create_buffer_from_buffer_ext{}{}:":"您可以使用 {}{}vertex_create_buffer{}{}/{}{}vertex_create_buffer_ext{}{} 创建一个新的空顶点缓冲区，或者使用 {}{}vertex_create_buffer_from_buffer{}{} 创建一个缓冲区并用缓冲区中的数据填充它 /{}{}vertex_create_buffer_from_buffer_ext{}{}：","You draw a vertex buffer by submitting it at any time in Draw events using&nbsp;{}{}vertex_submit{}{}, or just part&nbsp;of it using{}{}vertex_submit_ext{}{}.":"您可以使用 {}{}vertex_submit{}{} 在 Draw 事件中随时提交顶点缓冲区，或者使用 {}{}vertex_submit_ext{}{} 提交其中的一部分来绘制顶点缓冲区。","{}GameMaker{}&nbsp;offers two ways to draw and create primitives:&nbsp;":"{}GameMaker{} 提供两种绘制和创建基元的方法：","{}GameMaker{}&nbsp;permits you to define your own vertex formats from which you can create your own custom primitives. This can greatly speed up shader operations or can be used to extend their capabilities and create surprising effects.":"{}GameMaker{} 允许您定义自己的顶点格式，您可以从中创建自己的自定义基元。这可以大大加快着色器操作的速度，或者可以用来扩展其功能并创建令人惊讶的效果。","{}GameMaker{}&nbsp;permits you to define your own {}vertex formats{} from which you can create your own custom primitives. This can greatly speed up shader operations or can be used to extend their capabilities and create surprising effects. You can find information on this in the following sections:":"{}GameMaker{}允许您定义自己的{}顶点格式{}，您可以从中创建自己的自定义基元。这可以大大加快着色器操作，或者可以用来扩展它们的函数并创建令人惊讶的效果。您可以在以下部分中找到相关信息：","{}IMPORTANT!{} The primitives that you build should follow the format that you have set using the Vertex Format functions, so if you have defined a vertex format with only positional data, there is no point building your primitive with colour data. You should note that the order in which you add properties to the primitive you are building is defined by the order in which you added these properties when creating the vertex format, so if you have defined the vector format with the order position, colour and texture coordinate, you {}must{} add these properties to the primitive being built in the same order otherwise you will get errors.":"{}重要！{}您构建的基元应遵循使用顶点格式函数设置的格式，因此，如果您仅使用位置数据定义了顶点格式，则使用颜色数据构建基元是没有意义的。您应该注意，您向正在构建的原语添加属性的顺序是由您在创建顶点格式时添加这些属性的顺序定义的，因此如果您使用顺序位置、颜色和纹理坐标定义了向量格式，则{}必须{}将这些属性以相同的顺序添加到正在构建的基元中，否则您将获得错误。","{}Primitives&nbsp;And Vertex Formats{}":"{} 基元和顶点格式 {}","{}WARNING! {}These functions do not work with the HTML5 module unless you have enabled OpenGL in the {}Game Options{}.":"{}警告！{}除非您在{}游戏选项{}中启用了OpenGL，否则这些函数不能与HTML5模块一起使用。","{}{}IMPORTANT{}{}&nbsp;The primitives that you build should follow the format that you have set using the Vertex Format functions, so if you have defined a vertex format with only positional data, there is no point building your primitive with colour data. You should note that the order in which you add properties to the primitive you are building is defined by the order in which you added these properties when creating the vertex format, so if you have defined the vector format with the order position, colour and texture coordinate, you {}must{} add these properties to the primitive being built in the same order otherwise you will get errors.":'{}{} 重要信息{}{} 您构建的基元应遵循您使用 " 顶点格式 " 函数设置的格式，因此，如果您定义了仅包含位置数据的顶点格式，则没有必要使用颜色构建基元数据。您应该注意，向正在构建的图元添加属性的顺序是由创建顶点格式时添加这些属性的顺序定义的，因此，如果您已使用顺序位置、颜色和纹理定义了矢量格式坐标，您 {} 必须 {} 将这些属性添加到以相同顺序构建的基元中，否则您会收到错误。',"{}{}NOTE{}{}&nbsp;See the&nbsp;{}Guide To Primitives And Vertex Building{}&nbsp;for more info on how to work with vertex buffers.":"{}{} 注意{}{} 有关如何使用顶点缓冲区的详细信息，请参阅 {} 基元和顶点构建指南 {}。","{}{}NOTE{}{}&nbsp;See&nbsp;{}Transferring Data Between Buffers{}&nbsp;for more info on how to pass data between the two buffer types.":"{}{} 注意{}{} 有关如何在两种缓冲区类型之间传递数据的详细信息，请参阅 {} 在缓冲区之间传输数据 {}。","{}{}NOTE{}{}&nbsp;You can use the functions&nbsp;{}{}sprite_get_uvs{}{},&nbsp;{}{}font_get_uvs{}{}&nbsp;and&nbsp;{}{}tileset_get_uvs{}{}&nbsp;to get a specific asset's UV range on the texture page.":"{}{} 注意{}{} 您可以使用函数 {}{}sprite_get_uvs{}{}、{}{}font_get_uvs{}{} 和 {}{}tileset_get_uvs{}{} 获取特定资源的 UV 范围在纹理页面上。","{}{}{}WARNING{}{}&nbsp;{}These functions do not work with the HTML5 module unless you have enabled WebGL in the {}Game Options{}.":"{}{}{} 警告{}{}{} 除非您在 {} 游戏选项 {} 中启用了 WebGL，否则这些函数无法与 HTML5 模块配合使用。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.6.7"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Primitives&nbsp;And Vertex Formats</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference section for the Primitive&nbsp;And Vertex Format functions and variables"><meta name="rh-index-keywords" content=""><meta name="search-keywords" content="Primitives&nbsp;And Vertex Formats,Primitives,Vertex Buffers,Vertex Formats"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Drawing/Primitives/draw_primitive_begin.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Drawing/Text/draw_highscore.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Primitives&nbsp;And Vertex Formats"><span>Primitives&nbsp;And Vertex Formats</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Primitives&nbsp;And Vertex Formats</span></h1><p>A primitive is a type of drawing done using points to define what is shown on the screen. They can be made up of single points, lines or triangles and can be coloured, have alpha blending and even be given a texture, which means that they can be used to create some very exciting effects in your 2D and 3D games!</p><p>The points of a primitive are called <em>vertices</em> (singular <em><a class="tooltip" title="A vertex is the name given to a single point of a polygon that contains various characteristics that define it's position, its colour and its texture. In computer graphics, this usually means a corner of a triangle that is used to create a primitive, and a combination of such primitives is what makes the graphics on the screen.">vertex</a></em>) and store data about their position, colour, texture and possibly other information. The GPU then draws these vertices using the primitive <em>type</em>&nbsp;that you provide:&nbsp;</p><p><img alt="The different primitive types" class="center" height="436" src="../../../../assets/Images/Scripting_Reference/GML/Reference/Drawing/primitive_types.png" width="573"></p><p>For example, you can create a rectangle using two triangle primitives, then texture it with a flag sprite and in the Draw event of an instance have that flag "wave" in the wind and distort the sprite you used by simply modifying the points that form the primitive.<b></b></p><div data-conref="../../../../assets/snippets/Note_Primitives_Enable_WebGL_On_HTML5.hts"><p class="note"><b><span data-conref="../../../../assets/snippets/Tag_warning.hts"><span class="warning">WARNING</span></span>&nbsp;</b>These functions do not work with the HTML5 module unless you have enabled WebGL in the <a href="../../../../Settings/Game_Options/HTML5.htm">Game Options</a>.</p></div><h2>Creating Primitives</h2><p><span data-keyref="GameMaker Name">GameMaker</span>&nbsp;offers two ways to draw and create primitives:&nbsp;</p><ul class="colour"><li>The primitive functions: the&nbsp;<span class="inline3_func">draw_primitive_*</span> and <span class="inline3_func">draw_vertex_*</span> functions</li><li>Vertex buffers</li></ul><h3>Primitive Functions</h3><p>The <span class="inline3_func">draw_primitive_*</span> functions allow you to define primitives and draw them directly to the screen (or to a <a href="../Surfaces/Surfaces.htm">surface</a>). You call&nbsp;<span class="inline3_func"><a href="draw_primitive_begin.htm">draw_primitive_begin</a></span>&nbsp;or&nbsp;<span class="inline3_func"><a href="draw_primitive_begin_texture.htm">draw_primitive_begin_texture</a></span>, then define the vertices with any of the <span class="inline3_func">draw_vertex_*</span> functions and finally call&nbsp;<span class="inline3_func"><a href="draw_primitive_end.htm">draw_primitive_end</a></span>&nbsp;to draw the primitive.</p><p class="code_heading">Draw Event</p><p class="code">var _tex = sprite_get_texture(spr_image, 0);<br>draw_primitive_begin_texture(pr_trianglestrip, _tex);<br>draw_vertex_texture(0, 0, 0, 0);<br>draw_vertex_texture(100, 0, 1, 0);<br>draw_vertex_texture(0, 100, 0, 1);<br>draw_vertex_texture(100, 100, 1, 1);<br>draw_primitive_end();</p><h3>Vertex Buffers</h3><p>Vertex buffers are the more advanced way to define reusable primitives. They are&nbsp;<a href="../../Buffers/Buffers.htm">Buffers</a>&nbsp;that store data about vertices specifically ("vertex data").&nbsp;With vertex buffers you split up the definition of the primitive and its drawing.</p><p>You create a new, empty vertex buffer using&nbsp;<span class="inline3_func"><a href="vertex_create_buffer.htm">vertex_create_buffer</a></span>&nbsp;/&nbsp;<span class="inline3_func"><a href="vertex_create_buffer_ext.htm">vertex_create_buffer_ext</a></span> or create one and fill it with the data in a buffer using&nbsp;<span class="inline3_func"><a href="vertex_create_buffer_from_buffer.htm">vertex_create_buffer_from_buffer</a></span>&nbsp;/&nbsp;<span class="inline3_func"><a href="vertex_create_buffer_from_buffer_ext.htm">vertex_create_buffer_from_buffer_ext</a></span>:</p><p class="code_heading">Create Event</p><p class="code">// Create an empty vertex buffer<br>vb = vertex_create_buffer();<br><br>// Create a vertex buffer filled with data from a buffer<br>var _buff = buffer_load("model.mod");<br>vb_model = vertex_create_buffer_from_buffer(_buff, format);<br>buffer_delete(_buff);</p><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;See&nbsp;<a href="../../Buffers/Transferring_Data_Between_Buffers.htm">Transferring Data Between Buffers</a>&nbsp;for more info on how to pass data between the two buffer types.</p><p>You draw a vertex buffer by submitting it at any time in Draw events using&nbsp;<span class="inline3_func"><a href="vertex_submit.htm">vertex_submit</a></span>, or just part&nbsp;of it using<span class="inline3_func"><a href="vertex_submit_ext.htm">vertex_submit_ext</a></span>.</p><p>The following is a complete example that makes use of&nbsp;<span data-keyref="GameMaker Name">GameMaker</span>'s default&nbsp;<a href="../../../../Additional_Information/Guide_To_Primitives_And_Vertex_Building.htm">passthrough vertex format</a>:&nbsp;</p><p class="code_heading">Create Event</p><p class="code">var _uv_data = sprite_get_uvs(spr_image, 0);<br>var _umin = _uv_data[0], _vmin = _uv_data[1], _umax = _uv_data[2], _vmax = _uv_data[3];<br><br>vb = vertex_create_buffer();<br><br>vertex_begin(vb, format);<br><br>vertex_position_3d(vb,&nbsp; &nbsp;0,&nbsp; &nbsp;0, 0); vertex_color(vb, c_white, 1); vertex_texcoord(vb, _umin, _vmin);<br>vertex_position_3d(vb, 100,&nbsp; &nbsp;0, 0); vertex_color(vb, c_white, 1); vertex_texcoord(vb, _umax, _vmin);<br>vertex_position_3d(vb,&nbsp; &nbsp;0, 100, 0); vertex_color(vb, c_white, 1); vertex_texcoord(vb, _umin, _vmax);<br>vertex_position_3d(vb, 100, 100, 0); vertex_color(vb, c_white, 1); vertex_texcoord(vb, _umax, _vmax);<br><br>vertex_end(vb);</p><p class="code_heading">Draw Event</p><p class="code">var _tex = sprite_get_texture(spr_image, 0);<br>vertex_submit(vb, pr_trianglestrip, _tex);</p><p class="code_heading">Cleanup Event</p><p class="code">vertex_delete_buffer(vb);</p><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;See the&nbsp;<a href="../../../../Additional_Information/Guide_To_Primitives_And_Vertex_Building.htm">Guide To Primitives And Vertex Building</a>&nbsp;for more info on how to work with vertex buffers.</p><h3>Texture Coordinates</h3><p>In the code examples above, the UVs are provided differently for vertex buffers. This is because the UVs are interpreted differently by both sets of functions:&nbsp;</p><ul class="colour"><li>The functions&nbsp;<span class="inline3_func"><a href="draw_vertex_texture.htm">draw_vertex_texture</a></span>&nbsp;and&nbsp;<span class="inline3_func"><a href="draw_vertex_texture_colour.htm">draw_vertex_texture_colour</a></span>&nbsp;map (0, 0) to the top-left corner of the sprite's region on the texture page and (1, 1) to the bottom-right corner of the sprite's region on the texture page.</li><li>The function&nbsp;<span class="inline3_func"><a href="vertex_texcoord.htm">vertex_texcoord</a></span>&nbsp;doesn't map the texture coordinates that you pass it to any sprite in a texture page. Therefore, (0, 0) is the top-left corner of the texture page and (1, 1) is the bottom-right corner of the texture page, i.e. the range [0, 1] covers the entire texture page.</li></ul><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;You can use the functions&nbsp;<span class="inline3_func"><a href="../../Asset_Management/Sprites/Sprite_Information/sprite_get_uvs.htm">sprite_get_uvs</a></span>,&nbsp;<span class="inline3_func"><a href="../../Asset_Management/Fonts/font_get_uvs.htm">font_get_uvs</a></span>&nbsp;and&nbsp;<span class="inline3_func"><a href="../../Asset_Management/Tilsets/tileset_get_uvs.htm">tileset_get_uvs</a></span>&nbsp;to get a specific asset's UV range on the texture page.</p><h2 id="func_ref">Function Reference</h2><h3 id="func_ref_primitives">Primitives</h3><ul class="colour"><li><a href="draw_primitive_begin.htm">draw_primitive_begin</a></li><li><a href="draw_primitive_begin_texture.htm">draw_primitive_begin_texture</a></li><li><a href="draw_primitive_end.htm">draw_primitive_end</a></li><li><a href="draw_vertex.htm">draw_vertex</a></li><li><a href="draw_vertex_colour.htm">draw_vertex_colour</a></li><li><a href="draw_vertex_texture.htm">draw_vertex_texture</a></li><li><a href="draw_vertex_texture_colour.htm">draw_vertex_texture_colour</a></li></ul><h3 id="func_ref_vertex_formats">Vertex Formats</h3><p><span data-keyref="GameMaker Name">GameMaker</span>&nbsp;permits you to define your own vertex formats from which you can create your own custom primitives. This can greatly speed up shader operations or can be used to extend their capabilities and create surprising effects.</p><p>A <strong>vertex format</strong> lists the attributes that are stored for a vertex in order. You start defining one with&nbsp;<span class="inline3_func"><a href="vertex_format_begin.htm">vertex_format_begin</a></span>, then add the attributes using the <span class="inline2">vertex_format_add_*</span> functions and finally end it using&nbsp;<span class="inline3_func"><a href="vertex_format_end.htm">vertex_format_end</a></span>.</p><ul class="colour"><li><a href="vertex_format_begin.htm">vertex_format_begin</a></li><li><a href="vertex_format_add_colour.htm">vertex_format_add_colour</a></li><li><a href="vertex_format_add_position.htm">vertex_format_add_position</a></li><li><a href="vertex_format_add_position_3d.htm">vertex_format_add_position_3d</a></li><li><a href="vertex_format_add_texcoord.htm">vertex_format_add_texcoord</a></li><li><a href="vertex_format_add_normal.htm">vertex_format_add_normal</a></li><li><a href="vertex_format_add_custom.htm">vertex_format_add_custom</a></li><li><a href="vertex_format_end.htm">vertex_format_end</a></li><li><a href="vertex_format_delete.htm">vertex_format_delete</a></li><li><a href="vertex_format_get_info.htm">vertex_format_get_info</a></li></ul><h3 id="func_ref_vertex_buffers">Vertex Buffers</h3><p>Once you have created your vertex format (see the section above) you can then use it to build the primitives that you want to draw using the following vertex buffer functions:</p><ul class="colour"><li><a href="vertex_create_buffer.htm">vertex_create_buffer</a></li><li><a href="vertex_create_buffer_ext.htm">vertex_create_buffer_ext</a></li><li><a href="vertex_create_buffer_from_buffer.htm">vertex_create_buffer_from_buffer</a></li><li><a href="vertex_create_buffer_from_buffer_ext.htm">vertex_create_buffer_from_buffer_ext</a></li><li><a href="vertex_update_buffer_from_buffer.htm">vertex_update_buffer_from_buffer</a></li><li><a href="vertex_update_buffer_from_vertex.htm">vertex_update_buffer_from_vertex</a></li><li><a href="vertex_get_buffer_size.htm">vertex_get_buffer_size</a></li><li><a href="vertex_get_number.htm">vertex_get_number</a></li><li><a href="vertex_delete_buffer.htm">vertex_delete_buffer</a></li><li><a href="vertex_begin.htm">vertex_begin</a></li><li><a href="vertex_colour.htm">vertex_colour</a></li><li><a href="vertex_normal.htm">vertex_normal</a></li><li><a href="vertex_position.htm">vertex_position</a></li><li><a href="vertex_position_3d.htm">vertex_position_3d</a></li><li><a href="vertex_argb.htm">vertex_argb</a></li><li><a href="vertex_texcoord.htm">vertex_texcoord</a></li><li><a href="vertex_float1.htm">vertex_float1</a></li><li><a href="vertex_float2.htm">vertex_float2</a></li><li><a href="vertex_float3.htm">vertex_float3</a></li><li><a href="vertex_float4.htm">vertex_float4</a></li><li><a href="vertex_ubyte4.htm">vertex_ubyte4</a></li><li><a href="vertex_end.htm">vertex_end</a></li><li><a href="vertex_freeze.htm">vertex_freeze</a></li><li><a href="vertex_submit.htm">vertex_submit</a></li><li><a href="vertex_submit_ext.htm">vertex_submit_ext</a></li></ul><p class="note"><span data-conref="../../../../assets/snippets/Tag_important.hts"><span class="important">IMPORTANT</span></span>&nbsp;The primitives that you build should follow the format that you have set using the Vertex Format functions, so if you have defined a vertex format with only positional data, there is no point building your primitive with colour data. You should note that the order in which you add properties to the primitive you are building is defined by the order in which you added these properties when creating the vertex format, so if you have defined the vector format with the order position, colour and texture coordinate, you <i>must</i> add these properties to the primitive being built in the same order otherwise you will get errors.</p><p>For an overview of how to build primitives using the vertex functions, see:</p><ul class="colour"><li><a href="../../../../Additional_Information/Guide_To_Primitives_And_Vertex_Building.htm">Guide To Primitives And Vertex Building</a></li></ul><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../Drawing.htm">Drawing</a></div><div style="float:right">Next: <a href="../Surfaces/Surfaces.htm">Surfaces</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>