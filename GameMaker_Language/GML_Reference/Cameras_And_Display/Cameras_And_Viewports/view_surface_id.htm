<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let o;o=a?e.attr(a):e.html();let i=t[removeHtml(o)];if(null!=i&&i.length){t=retHtml(o);let n=0;t&&t.forEach(function(e,t){var a=i.replace("{"+n+"}",e);i=a===i?i.replace("{}",e):a,n++}),a?e.attr(a,i):e.html(i)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Draw the surface in the Draw GUI or Post Draw event of an instance, since these events are independent of views.":'在实例的"绘制GUI"或"后期绘制"事件中绘制表面，因为这些事件与视图无关。',"Enable a new view and draw the surface only in that view (using {}{}view_current{}{} to check which view is being drawn)":"启用新视图并仅在该视图中绘制表面(使用 {}{}view_current{}{} 检查正在绘制的视图)","In this extended example, we will create a surface and assign it to view port[0] so it captures the camera view assigned to that port, then draw that to the screen in the Draw GUI event. To start with we need to initialise our surface variable in the {}Create Event{} of a controller instance:":"在此扩展示例中，我们将创建一个表面并将其指定给 viewport[0]，以便它捕获指定给该端口的相机视图，然后将其绘制到 绘制GUI 事件中的屏幕。首先，我们需要在控制器实例的{}创建事件{}中初始化表面变量：","Note that you can also set a view port to a surface using the function {}{}view_set_surface_id(){}{}.":"请注意，还可以使用函数 {}{}view_set_surface_id(){}{} 将视口设置为表面。","Surfaces are {}volatile{} meaning that they could be removed from memory at any time due to OS memory management and other things, so here we check to see if our surface exists and if it doesn't we create it and assign it to the view 0. With that done, everything that would appear in view 0 will now be drawn to the surface we have created instead. If you do nothing else at this point, when you run your game you will simply get a blank screen as all drawing is being done on the surface, but the surface itself is not being drawn anywhere. Therefore we now need to draw the surface to the screen in the {}Draw GUI{} event like this:":"表面是{}易失性{}，这意味着由于系统内存管理和其他原因，它们可以随时从内存中删除，因此我们在这里检查表面是否存在，如果表面不存在，我们将创建表面并将其分配给视图0。完成此操作后，视图0中出现的所有内容现在都将被绘制到我们创建的表面。如果此时不执行任何其他操作，则在运行游戏时，您只会看到一个空白屏幕，因为所有绘制都是在表面上完成的，但表面本身不会在任何地方绘制。因此，我们现在需要在{}绘制GUI{}事件中将表面绘制到屏幕，如下所示：","This code will now draw the surface that we have created from the view camera stretched to fill the entire GUI layer.":"此代码现在将绘制我们从拉伸的视图的相机创建的表面，以填充整个 GUI 层。","We set the surface variable to -1, as all surface functions should really be used in the {}Draw{} events to prevent odd errors or undefined behaviours. So, with that done, we would then have this in the main {}Draw{} event:":"我们将表面变量设置为-1，因为所有表面函数都应该真正用于{}绘制{}事件，以防止出现奇怪错误或未定义的行为。因此，完成此操作后，我们将在主{}绘制{}事件中执行以下操作：","With this variable you can set the contents of a given view port to draw to a surface, or get a reference to the current surface if one has been assigned to a view port. When working with surfaces, it is often required that you capture the {}whole{} visible region of the screen to the surface, and so you would assign it to a view port using this variable. This means that everything that is shown in the chosen view will now be drawn to the assigned surface. The view will now {}not{} be drawn to the screen, meaning that you will need to either:":"使用此变量，您可以设置给定视口的内容以绘制到表面，或者获取对当前表面的引用 (如果已将其分配给视口)。使用表面时，通常需要将屏幕的 {} 整个 {} 可见区域捕获到表面，因此您可以使用此变量将其分配给视口。这意味着所选视图中显示的所有内容现在都将绘制到指定的表面上。现在，视图将 {} 不会 {} 绘制到屏幕上，这意味着您需要：","With this variable you can set the contents of a given view port to draw to a surface, or get the current surface id if one has been assigned to a view port. When working with surfaces, it is often required that you capture the {}whole{} visible region of the screen to the surface, and so you would assign it to a view port using this variable. This means that everything that is shown in the chosen view will now be drawn to the assigned surface. The view will now {}not{} be drawn to the screen, meaning that you will need to either:":"使用此变量，可以将给定视口的内容设置为绘制到面，或者获取当前面 ID (如果已将其指定给视口)。使用面时，通常需要将屏幕的{}整个{}可见区域捕捉到面，以便使用此变量将其指定给视口。这意味着选定视图中显示的所有内容现在都将绘制到指定的面。现在将{}不会{}将视图绘制到屏幕上，这意味着您需要：","You can also read this variable to get the index of the surface that has been assigned to the chosen view or it will return -1 if no surface has been assigned, and generally the surface used for this function should be the size of the view camera itself (not the view port). The extended example below shows a basic setup for capturing a view and drawing it in the {}Draw GUI{} event, and for more information on surfaces see the section {}Surfaces{}.":"您也可以读取此变量以获取已指定给所选视图的表面的索引，或者，如果未指定表面，它将返回-1，并且通常用于此函数的表面应为视图的相机本身的大小(而不是视口)。下面的扩展示例显示了在{}绘制GUI{}事件中捕获视图和绘制视图的基本设置，有关表面的详细信息，请参见{}表面{}一节。","You can also read this variable to get the surface that has been assigned to the chosen view or it will return -1 if no surface has been assigned, and generally the surface used for this function should be the size of the view camera itself (not the view port). The extended example below shows a basic setup for capturing a view and drawing it in the {}Draw GUI{} event, and for more information on surfaces see the section {}Surfaces{}.":"您还可以读取此变量来获取已分配给所选视图的表面，如果没有分配表面，则返回 -1，通常用于此功能的表面应该是视图相机本身的大小 (而不是视口)。下面的扩展示例展示了捕获视图并在 {}Draw GUI{} 事件中绘制视图的基本设置，有关表面的更多信息，请参阅 {} 表面 {} 部分。","{}IMPORTANT{}&nbsp;Care must be taken when drawing surfaces or textures to a view with a surface assigned to it, because if you try to draw the view's assigned surface (or its texture) inside that same view, you will get an error as you are essentially trying to draw a texture onto itself.":"{}重要{} 在为具有指定表面的视图绘制表面或纹理时必须小心，因为如果您尝试在同一视图内绘制视图的指定表面(或其纹理)，则会遇到一个错误，因为您正在尝试将纹理绘制到自身上。","{}{}Surface ID{}{}&nbsp;or -1 (if no surface has been assigned)":"{}{}表面 ID {}{}或 -1 (如果未指定表面)","{}{}Surface{}{}&nbsp;or -1 (if no surface has been assigned)":"{}{} 表面 {}{} 或 -1( 如果未指定表面)"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.7.1.0_43"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>view_surface_id</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference page for view_surface_id"><meta name="rh-index-keywords" content="view_surface_id"><meta name="search-keywords" content="view_surface_id"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Cameras_And_Display/Cameras_And_Viewports/view_get_camera.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Cameras_And_Display/Cameras_And_Viewports/view_hport.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="view_surface_id"><span>view_surface_id</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">view_surface_id</span></h1><p>With this variable you can set the contents of a given view port to draw to a surface, or get a reference to the current surface if one has been assigned to a view port. When working with surfaces, it is often required that you capture the <i>whole</i> visible region of the screen to the surface, and so you would assign it to a view port using this variable. This means that everything that is shown in the chosen view will now be drawn to the assigned surface. The view will now <i>not</i> be drawn to the screen, meaning that you will need to either:</p><ul class="colour"><li>Enable a new view and draw the surface only in that view (using <a href="view_current.htm"><span class="inline">view_current</span></a> to check which view is being drawn)</li><li>Draw the surface in the Draw GUI or Post Draw event of an instance, since these events are independent of views.</li></ul><p>You can also read this variable to get the surface that has been assigned to the chosen view or it will return -1 if no surface has been assigned, and generally the surface used for this function should be the size of the view camera itself (not the view port). The extended example below shows a basic setup for capturing a view and drawing it in the <b>Draw GUI</b> event, and for more information on surfaces see the section <a href="../../Drawing/Surfaces/Surfaces.htm">Surfaces</a>.</p><p>Note that you can also set a view port to a surface using the function <a href="view_set_surface_id.htm"><span class="inline">view_set_surface_id()</span></a>.</p><div data-conref="../../../../assets/snippets/Recursive_Surface_Draw_Error.hts"><p class="note"><span class="important">IMPORTANT</span>&nbsp;Care must be taken when drawing surfaces or textures to a view with a surface assigned to it, because if you try to draw the view's assigned surface (or its texture) inside that same view, you will get an error as you are essentially trying to draw a texture onto itself.</p></div><div data-conref="../../../../assets/snippets/GML_Not_real_array.hts"><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;This variable does not hold a real GML array, so you cannot run any <a href="../../Variable_Functions/Array_Functions.htm">array functions</a> on it or serialise it (convert it to a string). The only operation you can run on it is accessing a value at an index, with the <span class="inline2"><span data-field="title" data-format="default">view_surface_id</span>[index]</span> syntax.</p></div><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">view_surface_id</span>[0...7]</p><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_ID_Surface"><a target="_blank" href="../../Drawing/Surfaces/surface_create.htm">Surface</a></span>&nbsp;or -1 (if no surface has been assigned)</p><p>&nbsp;</p><h4>Extended Example:</h4><p>In this extended example, we will create a surface and assign it to view port[0] so it captures the camera view assigned to that port, then draw that to the screen in the Draw GUI event. To start with we need to initialise our surface variable in the <b>Create Event</b> of a controller instance:</p><p class="code">surf = -1;</p><p>We set the surface variable to -1, as all surface functions should really be used in the <b>Draw</b> events to prevent odd errors or undefined behaviours. So, with that done, we would then have this in the main <b>Draw</b> event:</p><p class="code">if !surface_exists(surf)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;surf = surface_create(camera_get_view_width(view_camera[0]), camera_get_view_height(view_camera[0]));<br>&nbsp;&nbsp;&nbsp;&nbsp;view_surface_id[0] = surf;<br>}</p><p>Surfaces are <i>volatile</i> meaning that they could be removed from memory at any time due to OS memory management and other things, so here we check to see if our surface exists and if it doesn't we create it and assign it to the view 0. With that done, everything that would appear in view 0 will now be drawn to the surface we have created instead. If you do nothing else at this point, when you run your game you will simply get a blank screen as all drawing is being done on the surface, but the surface itself is not being drawn anywhere. Therefore we now need to draw the surface to the screen in the <b>Draw GUI</b> event like this:</p><p class="code">if surface_exists(surf)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;draw_surface_stretched(surf, 0, 0, display_get_gui_width(), display_get_gui_height());<br>}</p><p>This code will now draw the surface that we have created from the view camera stretched to fill the entire GUI layer.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="Cameras_And_View_Ports.htm">Cameras And View Ports</a></div><div style="float:right">Next:&nbsp;<a href="view_get_camera.htm">view_get_camera</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>