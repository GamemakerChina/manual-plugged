<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,n,t){let a;a=t?e.attr(t):e.html();let s=n[removeHtml(a)];if(null!=s&&s.length){n=retHtml(a);let i=0;n&&n.forEach(function(e,n){var t=s.replace("{"+i+"}",e);s=t===s?s.replace("{}",e):t,i++}),t?e.attr(t,s):e.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Care should be taken when writing any returned&nbsp;JSON&nbsp;string to an {}ini{} file, as the {}ini{} specifications can cause issues when using quotes and escape characters. See the function {}{}ini_write_string(){}{} for more information.":"将任何返回的 JSON 字符串写入 {}ini{} 文件时应小心，因为 {}ini{} 规范在使用引号和转义字符时可能会导致问题。 有关详细信息，请参阅函数 {}{}ini_write_string(){}{}。","Conversion Notes":"转换说明","Filter Function&nbsp;{}{}OPTIONAL{}{}":"过滤功能 {}{} 可选 {}{}",'If the provided struct contains any circular references, such as references back to the main struct itself (forming an infinite loop) or references to structs within the main struct forming such infinite loops, such references will be converted to {}"null"{} upon stringifying.':'如果提供的结构包含任何循环引用，例如回溯到主结构本身的引用 (形成无限循环) 或对形成这种无限循环的主结构内的结构的引用，则此类引用将在字符串化时转换为 {}"null"{}。',"If the provided struct contains any circular references, such as references back to the main struct itself (forming an infinite loop) or references to structs within the main struct forming such infinite loops, such references will be converted to {}null{}&nbsp;upon stringifying.":"如果提供的结构体包含任何循环引用，例如对主结构体本身的引用 (形成无限循环) 或对形成此类无限循环的主结构体中的结构体的引用，则此类引用将在字符串化时转换为 {}null{}。","If the value is a {}{}Real{}{}, it {}rounds{} it, if it's {}undefined{}, it changes it to 0, otherwise it simply returns the same value (meaning it remains unchanged).":"如果该值是 {}{}Real{}{}，则对其进行 {} 舍入 {}; 如果是 {} 未定义 {}，则将其更改为 0，否则仅返回相同的值 (意味着它保持不变)。",'If you include an int64 in the values to convert to&nbsp;JSON it will write it as an {}int{} if it is in the valid range for an int32, as a {}double{} if it can do so without losing precision or (if neither of those cases is applicable) as a {}string{} with an identifier "{}@i64@{}" before it and "{}$i64${}" after it. When you come to parse the JSON&nbsp;again {}GameMaker{} will pick these identifiers up and re-convert the value back into an int64. This does mean that if the JSON is intended for a server or some other non-GameMaker target, these values will not be appropriate and so should be avoided.':"如果您在要转换为 JSON 的值中包含一个 int64，如果它在 int32 的有效范围内，它将把它写成 {}int{}，如果它可以在不损失精度的情况下写成 {}double{} 或 (如果这两种情况都不适用) 作为 {} 字符串 {}，其前面有标识符“{}@i64@{}”，后面有“{}$i64${}”。 当您再次解析 JSON 时，{}GameMaker{} 将选取这些标识符并将值重新转换回 int64。 这确实意味着如果 JSON 用于服务器或其他一些非 GameMaker 目标，则这些值将不合适，因此应避免使用。",'If you include an int64 in the values to convert to&nbsp;JSON, it will write it as an {}int{} if it is in the valid range for an int32, as a {}double{} if it can do so without losing precision, or, if neither of those cases is applicable, as a {}string{} with an identifier "{}@i64@{}" before it and "{}$i64${}" after it. When you come to parse the JSON&nbsp;again {}GameMaker{} will pick these identifiers up and re-convert the value back into an int64 (unless conversion is disabled). This does mean that if the JSON is intended for a server or some other non-GameMaker target, these values will not be appropriate and so should be avoided.':'如果您在要转换为 JSON 的值中包含 int64，则如果它在 int32 的有效范围内，它会将其写入为 {}int{}，如果可以在不丢失精度的情况下写入为 {}double{} 或者，如果这两种情况都不适用，则作为 {} 字符串 {}，其前面带有标识符 "{}@i64@{}"，后面带有标识符 "{}$i64${}"。当您再次解析 JSON 时，{}GameMaker{} 将选取这些标识符并将值重新转换回 int64( 除非禁用转换)。这确实意味着，如果 JSON 用于服务器或其他一些非 GameMaker 目标，则这些值将不合适，因此应避免。','If you include {}infinity{}, {}-infinity{} or {}NaN{}&nbsp;in the values to convert to JSON, they will be encoded as strings as these values are not part of the JSON standard, and on parsing the resulting JSON they will {}not {}be converted back into their runtime values and&nbsp;will stay as strings. Note that {}NaN{} will be converted into "nan" (lowercase) upon stringifying.':"如果您在要转换为 JSON 的值中包含 {}infinity{}、{}-infinity{} 或 {}NaN{}，它们将被编码为字符串，因为这些值不是 JSON 标准的一部分，并且在 在解析生成的 JSON 时，它们 {} 不会 {} 转换回它们的运行时值，并且将保留为字符串。 请注意，{}NaN{} 将在字符串化时转换为“nan”(小写)。",'If you include {}{}undefined{}{} in the struct, it will be encoded as {}"null"{}, and upon reading that back into GameMaker you will get {}{}pointer_null{}{}.':'如果在结构中包含 {}{}undefined{}{}，它将被编码为 {}"null"{}，在读回 GameMaker 时，您将获得 {}{}pointer_null{}{}。',"If you include {}{}undefined{}{} in the struct, it will be encoded as {}null{}, which will be read back as {}undefined{} when {}parsing{}.":"如果您在结构中包含 {}{}undefined{}{}，它将被编码为 {}null{}，在 {} 解析 {} 时将被读回为 {}undefined{}。",'If you include{}&nbsp;{}{}infinity{},{}&nbsp;{}{}-infinity{}{}&nbsp;{}or{}&nbsp;{}{}NaN{}&nbsp;in the values to convert to JSON, they will be encoded as strings as these values are not part of the JSON standard, and on parsing the resulting JSON they will{}&nbsp;{}{}not{}&nbsp;{}{}be converted back into their runtime values and&nbsp;will stay as strings. Note that{}&nbsp;{}{}NaN{}{}&nbsp;{}will be converted into {}"nan"{} (lowercase) upon stringifying. {} {}{}On HTML5 however, {}infinity{}{} and {}{}NaN{}{} will be written into the JSON as {}"@@infinity$"{} ({}"@@-infinity$"{} for negative) and {}"@@nan$"{} respectively. These values will be correctly loaded back into memory when the JSON is loaded with {}{}json_parse{}{}.{} {} ':'如果包含{} {}{}infinity{}，{} {}{}-infinity{}{} {}或{} {}{}NaN{} 在要转换为 JSON 的值，它们将被编码为字符串，因为这些值不是 JSON 标准的一部分，并且在解析得到的 JSON 时，它们将{}{}{}不会{}{}{}转换回它们的运行时值，而将保留为字符串。请注意，在字符串注册时，{} {}{}NaN{}{} {}将转换为{}"nan"{}(小写)。{}{}{} 然而，在 HTML5 上，{}infinity{}{} 和 {}{}NaN{}{} 将分别作为 {}"@@infinity$"{}({}"@@-infinity$"{} 表示否定)和 {}"@@NaN$"{} 写入 JSON。当 JSON 加载了 {}{}json_parse{}{}时，这些值将正确加载到内存中.{}{}',"It takes two arguments&nbsp;{}(key, value){} where {}key{} is the struct key name ({}{}String{}{}) or array index ({}{}Real{}{}), and {}value{} is what's stored in that key/index.":"它需要两个参数 {}(key, value){}，其中 {}key{} 是结构体键名称 ({}{}String{}{}) 或数组索引 ({}{}Real{}{})，{} 值 {} 是存储在该键 / 索引中的内容。",'The above code converts the {}_contents{} struct into a JSON string and stores it in a variable. With the {}pretty_print{} parameter set to {}true{}, the struct\'s contents are {}pretty printed{} to the string, i.e. indentation and line breaks are inserted to make the resulting string look "pretty" and more readable. The string then looks like this:&nbsp;':'上面的代码将 {}_contents{} 结构转换为 JSON 字符串并将其存储在变量中。当 {}pretty_print{} 参数设置为 {}true{} 时，结构的内容将被{}美化输出{}到字符串中，即插入缩进和换行符，以使结果字符串看起来"漂亮"且更具可读性。然后，字符串看起来如下所示：',"The above code takes a struct and stringifies it to JSON, pretty-printing it, and using a filter function to modify some types of values.":"上面的代码采用一个结构并将其字符串化为 JSON，漂亮地打印它，并使用过滤器函数来修改某些类型的值。","The above code will convert&nbsp;the {}_contents{} struct into a JSON string and store the string in a variable. The returned string would look like this:":"上面的代码会将 {}_contents{} 结构转换为 JSON 字符串并将该字符串存储在一个变量中。 返回的字符串如下所示：","The above code will convert&nbsp;the {}_contents{} struct into a JSON string and stores the string in a variable. The returned string would look like this:":"上面的代码会将 {}_contents{} 结构转换为 JSON 字符串并将该字符串存储在一个变量中。 返回的字符串如下所示：","The filter function can return a new value, which replaces the key's value in the final converted format returned by&nbsp;{}{}json_stringify{}{}.":"过滤器函数可以返回一个新值，该值会替换 {}{}json_stringify{}{} 返回的最终转换格式中的键值。","The function optionally takes a&nbsp;{}{}Function{}{}, which runs once for each value in the structure, including all nested structs/arrays and all the values inside them.":"该函数可以选择采用 {}{}Function{}{}，该函数对结构中的每个值运行一次，包括所有嵌套结构 / 数组及其内部的所有值。",'The function will convert just about any value into a "valid" JSON string, however the actual values contained in the string may not be exactly what you expect due to the way that the JSON standard operates:{} {} "JSON is agnostic about numbers. In any programming language, there can be a variety of number types of various capacities and complements, fixed or floating, binary or decimal. That can make interchange between different programming languages difficult. JSON instead offers only the representation of numbers that humans use: a sequence of digits. All programming languages know how to make sense of digit sequences even if they disagree on internal representations."{} {} For more information see the {}ECMA JSON Standard{}. ':"该函数将几乎任何值转换为“有效的”JSON 字符串，但是由于 JSON 标准的操作方式，字符串中包含的实际值可能不是您所期望的 :{}{}“JSON 与数字无关。在任何编程语言中，都可以有各种容量和补数的数字类型，固定的或浮动的，二进制或十进制的。这可能会使不同编程语言之间的交换变得困难。相反，JSON 只提供人类使用的数字表示 : 数字序列。所有的编程语言都知道如何理解数字序列，即使它们在内部表示上存在分歧。“{}{} 更多信息请参见 {}ECMA JSON 标准 {}。",'The function will convert just about any value into a "valid" JSON string, however the actual values contained in the string may not be exactly what you expect due to the way that the JSON standard operates:{} {} {}"JSON is agnostic about numbers. In any programming language, there can be a variety of number types of various capacities and complements, fixed or floating, binary or decimal. That can make interchange between different programming languages difficult. JSON instead offers only the representation of numbers that humans use: a sequence of digits. All programming languages know how to make sense of digit sequences even if they disagree on internal representations."{}{} {} For more information see the {}ECMA JSON Standard{}. ':'该函数将几乎将任何值转换为 " 有效 " 的 JSON 字符串，但是由于 JSON 标准运行的方式，字符串中包含的实际值可能不是您所期望的：{}{}{}" JSON 对数字不可知。编程语言，可能会有各种类型的各种能力和补充，固定或浮动，二进制或十进制。这可能会使不同的编程语言之间的互换很难互换。JSON 仅提供人类使用的数字的表示：数字。所有编程语言都知道如何理解数字序列，即使它们在内部表示方面不同意。"{}{}{}有关更多信息，请参见 {}ECMA JSON 标准{}。',"The function will&nbsp;{}not&nbsp;{}&nbsp;convert DS maps, lists or any other data structure into JSON, and will simply store the internal index value for the structure (which is of little use as the index will change between runs of the game), and as such you should not try to stringify any value that may contain references to data structures (for that you have {}{}json_encode(){}{}).":"函数将 {} 不会 {} 将 DS 映射、列表或任何其他数据结构转换为 JSON，并将简单地存储结构的内部索引值 (这没什么用，因为索引会在游戏运行期间发生变化)，因此你不应该尝试字符串化任何可能包含数据结构引用的值 (因为你有 {}{}json_encode(){}{})。",'The function will&nbsp;{}not{}{}&nbsp;{}serialise the data contained {}inside{} assets, data structures and other runtime resources&nbsp;into JSON, and will simply store the internal handle reference for the resource (which is of little use as the index will change between runs of the game). {} {}Upon {}parsing{} the JSON, these will be converted back into runtime references so the resources can be used normally in functions. This includes any resource type that is represented as a {}handle{}&nbsp;(see the "{}Handles{}" section on the linked page). This conversion can be disabled when parsing.{} {}Keep in mind that this will not be useful between game sessions as asset and resource information may have changed, depending on the type of resource. Assets are saved using their names so these references maintain their links as long as the asset name does not change.{} {}If you want to serialise data structures (specifically lists and maps), use the {}{}json_encode{}{} function.{} {} ':'该函数 {}不会{}{}{}将资产、数据结构和其他运行时资源{}中{}包含的数据序列化为 JSON，而只会存储资源的内部句柄引用 (这没什么用，因为索引会在游戏运行之间发生变化)。{}{}解析{}{} JSON 后，这些资源将被转换回运行时引用，以便资源可以在函数中正常使用。这包括表示为{}句柄{}的任何资源类型 (请参阅链接页面上的 " {}句柄{} " 部分)。解析时可以禁用此转换。{}{}请记住，这在游戏会话之间没有用，因为资产和资源信息可能会发生变化，具体取决于资源类型。资产使用其名称进行保存，因此只要资产名称不更改，这些引用就会保持其链接。{}{}如果要序列化数据结构 (特别是列表和映射)，请使用{}{} json_encode{}{} 函数。{}{}',"The reference value for a struct or array to convert into a JSON string":"要转换为 JSON 字符串的结构或数组的引用值","When using this function there are some important things to note:":"在使用这个函数时，有一些重要的事情需要注意:","With this function you can convert single or nested structs and arrays into a valid JSON string.":"通过这个函数，您可以将单个或嵌套的结构和数组转换为有效的 JSON 字符串。",'With this function you can convert single or nested structs and arrays into a valid JSON string. You supply the initial value to use (an array index or a struct reference) and then the function will "stringify" it, converting it into a JSON&nbsp;string (converting GameMaker arrays into JSON arrays,&nbsp;and GameMaker structs into JSON objects).':"通过这个函数，您可以将单个或嵌套的结构和数组转换为有效的 JSON 字符串。你提供使用的初始值 (数组索引或结构引用)，然后函数将其“字符串化 (stringify)”，将其转换为 JSON 字符串 (将 GameMaker 数组转换为 JSON 数组，和 GameMaker 结构转换为 JSON 对象)。",'You supply the initial value to use (an array index or a struct reference) and then the function will "stringify" it, converting it into a JSON&nbsp;string (converting GameMaker arrays into JSON arrays,&nbsp;and GameMaker structs into JSON objects). You can optionally choose to "pretty print" it, meaning the final JSON will be formatted for easy readability.':'你提供使用的初始值 (数组索引或结构引用)，然后函数将其"字符串化 (stringify)"，将其转换为 JSON 字符串 (将 GameMaker 数组转换为 JSON 数组，和 GameMaker 结构转换为 JSON 对象)。 您可以选择"美化输出"它，这意味着最终的 JSON 将被格式化以便于阅读。',"{}{}NOTE{}{}&nbsp;When overriding a key's value in the filter function (using {}return{}), make sure you check its type first, as the filter function runs for the root structure and any nested structures as well, meaning accidentally overriding them will result in a broken final structure. See&nbsp;{}Example 3{} at the bottom.":"{}{} 注意{}{} 在过滤器函数中覆盖键的值 (使用 {}return{}) 时，请确保首先检查其类型，因为过滤器函数也会针对根结构和任何嵌套结构运行，这意味着意外覆盖它们将导致最终结构损坏。请参阅底部的 {} 示例 3{}。","{}{}OPTIONAL{}{}&nbsp;Filter function that processes each item. Syntax:&nbsp;{}function(key, value) -&gt; new_value{}":"{}{} 可选{}{} 处理每个项目的过滤器函数。语法：{} function(key, value) -&gt; new_value {}","{}{}OPTIONAL{}{}&nbsp;Whether to pretty print the string, i.e. insert indentation and line breaks for readability":"{}{}可选{}{} 是否美化输出字符串，即插入缩进和换行符以提高可读性",'{}{}infinity{}{} and {}{}NaN{}{} will be written into the JSON as {}"@@infinity$"{} ({}"@@-infinity$"{} for negative) and {}"@@nan$"{} respectively. These values will be correctly loaded back into memory when the JSON is loaded with {}{}json_parse{}{}&nbsp;(unless conversion is disabled).':'{}{}infinity{}{} 和 {}{}NaN{}{} 将作为 {}"@@infinity$"{}({}"@@-infinity$"{} 写入 JSON 分别为负数) 和 {}"@@nan$"{}。当使用 {}{}json_parse{}{} 加载 JSON 时，这些值将正确加载回内存 (除非禁用转换)。','{}{}infinity{}{} and {}{}NaN{}{} will be written into the JSON as {}"@@infinity$"{} ({}"@@-infinity$"{} for negative) and {}"@@nan$"{} respectively. These values will be correctly loaded back into memory when the JSON is loaded with {}{}json_parse{}{}.':'{}{}infinity{}{} 和 {}{}NaN{}{} 将分别作为 {}"@@infinity$"{}({}"@@-infinity$"{} 表示负数) 和 {}"@@nan$"{} 写入 JSON。当使用 {}{}json_parse{}{} 加载 JSON 时，这些值将正确加载回内存。'},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.17.6.0_3"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>json_stringify</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference page for json_stringify"><meta name="rh-index-keywords" content="json_stringify"><meta name="search-keywords" content="json_stringify"><meta name="is_pure" content="true"><meta name="brsnext" value="GameMaker_Language/GML_Reference/File_Handling/Encoding_And_Hashing/json_parse.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/File_Handling/Encoding_And_Hashing/json_decode.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="json_stringify"><span>json_stringify</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">json_stringify</span></h1><p>This function converts a single struct or a hierarchy of nested structs and arrays into a valid JSON string.</p><p>You supply the initial value to use (a&nbsp;<span data-keyref="Type_Struct"><a target="_blank" href="../../../GML_Overview/Structs.htm">Struct</a></span>&nbsp;or an&nbsp;<span data-keyref="Type_Array"><a target="_blank" href="../../../GML_Overview/Arrays.htm">Array</a></span>) and then the function will "stringify" it, i.e. convert it into a JSON&nbsp;string (converting&nbsp;<span data-keyref="GameMaker Name">GameMaker</span> arrays into JSON arrays,&nbsp;and&nbsp;<span data-keyref="GameMaker Name">GameMaker</span> structs into JSON objects). You can optionally choose to "prettify" it, meaning the final JSON will be formatted for easy readability.</p><h3>Usage Notes</h3><ul class="colour"><li>The function will&nbsp;<strong>not</strong><em>&nbsp;</em>serialise the data contained <em>inside</em> assets, data structures and other runtime&nbsp;assets into JSON, and will simply store the internal handle reference for the asset (which is of little use as the index will change between runs of the game).<ul><li>Upon <a href="json_parse.htm">parsing</a> the JSON, these will be converted back into runtime references so the assets can be used normally in functions. This includes any asset type that is represented as a <a href="../../../GML_Overview/Data_Types.htm">handle</a>&nbsp;(see the "<strong>Handles</strong>" section on the linked page). This conversion can be disabled when parsing.</li><li>Keep in mind that this will not be useful between game sessions as asset information may have changed, depending on the type of asset. Assets are saved using their names so these references maintain their links as long as the asset name does not change.</li><li>If you want to serialise data structures (specifically lists and maps), use the <span class="inline3_func"><a href="json_encode.htm">json_encode</a></span> function.</li></ul></li><li style="margin-top:22px;margin-bottom:-5px"><span data-keyref="GameMaker Name">GameMaker</span>&nbsp;encodes certain values in the JSON as a string so they can be read back correctly later.&nbsp;See&nbsp;<a href="../../../../Additional_Information/Guide_To_Using_JSON.htm#data_conversions">Data Conversions</a> for an overview of these conversions.</li></ul><div data-conref="../../../../assets/snippets/Note_See_Guide_To_Using_JSON.hts"><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;See&nbsp;<a href="../../../../Additional_Information/Guide_To_Using_JSON.htm">Guide To Using JSON</a>&nbsp;for detailed information on how to work with JSON in&nbsp;<span data-keyref="GameMaker Name">GameMaker</span>.</p></div><div data-conref="../../../../assets/snippets/JSON_Filter_Function_Description.hts"><h3>Filter Function&nbsp;<span data-conref="../../../../assets/snippets/Tag_optional.hts"><span class="optional">OPTIONAL</span></span></h3><p>The function optionally takes a&nbsp;<span data-keyref="Type_Function"><a target="_blank" href="../../../GML_Overview/Script_Functions.htm">Function</a></span>, which runs once for each value in the structure, including all nested structs/arrays and all the values inside them.</p><p>It takes two arguments&nbsp;<span class="inline2">(key, value)</span> where <span class="inline2">key</span> is the struct key name (<span data-keyref="Type_String"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">String</a></span>) or array index (<span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span>), and <span class="inline2">value</span> is what's stored in that key/index.</p><p>The filter function must always return a value. It can return a new value, which replaces the key's value in the final converted format returned by&nbsp;<span class="inline3_func"><span data-field="title" data-format="lower-alpha">json_stringify</span></span>. If no new value should be returned for a particular key, the function must return the original <span class="inline2">value</span>.</p><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;When overriding a key's value in the filter function (using <a href="../../../GML_Overview/Language_Features/return.htm">return</a>), make sure you check its type first, as the filter function runs for the root structure and any nested structures as well, meaning accidentally overriding them will result in a broken final structure. See&nbsp;<strong>Example 3</strong> at the bottom.</p></div><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">json_stringify</span>(val, [pretty_print], [filter_func]);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>val</td><td><span data-keyref="Type_Struct"><a target="_blank" href="../../../GML_Overview/Structs.htm">Struct</a></span>&nbsp;or&nbsp;<span data-keyref="Type_Array"><a target="_blank" href="../../../GML_Overview/Arrays.htm">Array</a></span></td><td>The reference value for a struct or array to convert into a JSON string</td></tr><tr><td>prettify</td><td><span data-keyref="Type_Bool"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Boolean</a></span></td><td><span data-conref="../../../../assets/snippets/Tag_optional.hts"><span class="optional">OPTIONAL</span></span>&nbsp;Whether to prettify the string, i.e. insert indentation and line breaks for readability</td></tr><tr><td>filter_func</td><td><span data-keyref="Type_Function"><a target="_blank" href="../../../GML_Overview/Script_Functions.htm">Function</a></span></td><td><span data-conref="../../../../assets/snippets/Tag_optional.hts"><span class="optional">OPTIONAL</span></span>&nbsp;Filter function that processes each item. Syntax:&nbsp;<span class="inline2">function(key, value) -&gt; new_value</span></td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_String"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">String</a></span></p><p>&nbsp;</p><h4>Example 1:</h4><p class="code">var _contents&nbsp;=<br>{<br>&nbsp; &nbsp; version : "1.0.0",<br>&nbsp;&nbsp; &nbsp;data:<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; coins : 4,<br>&nbsp; &nbsp; &nbsp; &nbsp; mana : 15,<br>&nbsp; &nbsp; &nbsp; &nbsp; playername : "Gurpreet",<br>&nbsp; &nbsp; &nbsp; &nbsp; items :<br>&nbsp; &nbsp; &nbsp; &nbsp; [<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ITEM.SWORD,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ITEM.BOW,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ITEM.GUITAR<br>&nbsp; &nbsp; &nbsp; &nbsp; ]<br>&nbsp;&nbsp; &nbsp;}<br>};<br><br>var _json_string = json_stringify(_contents);</p><p>The above code will convert&nbsp;the <span class="inline2">_contents</span> struct into a JSON string and stores the string in a variable. The returned string would look like this:</p><p class="code">{ "data": { "items": [ 0.0, 1.0, 2.0 ], "coins": 4.0, "mana": 15.0, "playername": "Gurpreet" }, "version": "1.0.0" }</p><p>&nbsp;</p><h4>Example 2: Pretty Print</h4><p class="code">var _contents =&nbsp;<br>{<br>&nbsp; &nbsp; version: "1.0.0",<br>&nbsp; &nbsp; data:<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; coins : 5,<br>&nbsp; &nbsp; &nbsp; &nbsp; mana : 0,<br>&nbsp; &nbsp; &nbsp; &nbsp; playername : "Bart",<br>&nbsp; &nbsp; &nbsp; &nbsp; items :<br>&nbsp; &nbsp; &nbsp; &nbsp; [<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ITEM.SWORD,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ITEM.BOW,<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ITEM.PIANO<br>&nbsp; &nbsp; &nbsp; &nbsp; ]<br>&nbsp; &nbsp; }<br>}<br>var _json_string = json_stringify(_contents, true);</p><p>The above code converts the <span class="inline2">_contents</span> struct into a JSON string and stores it in a variable. With the <span class="inline2">pretty_print</span> parameter set to <span class="inline2">true</span>, the struct's contents are <em>pretty printed</em> to the string, i.e. indentation and line breaks are inserted to make the resulting string look "pretty" and more readable. The string then looks like this:&nbsp;</p><p class="code">{<br>&nbsp; "data":{<br>&nbsp; &nbsp; "mana":0.0,<br>&nbsp; &nbsp; "playername":"Bart",<br>&nbsp; &nbsp; "items":[<br>&nbsp; &nbsp; &nbsp; 0,<br>&nbsp; &nbsp; &nbsp; 1,<br>&nbsp; &nbsp; &nbsp; 2<br>&nbsp; &nbsp; ],<br>&nbsp; &nbsp; "coins":5.0<br>&nbsp; },<br>&nbsp; "version":"1.0.0"<br>}</p><p>&nbsp;</p><h4>Example 3: Filter Function</h4><p class="code">var data =<br>{<br>&nbsp; &nbsp; x: 5.2344,<br>&nbsp; &nbsp; y: 10.601,<br>&nbsp; &nbsp; last_clicked: undefined,<br>&nbsp; &nbsp; values : &nbsp;[ 2000.1, 30.56, undefined, { slot : 10, skin : undefined } ]<br>}<br><br>var json = json_stringify(data, true, function(key, value)<br>{<br>&nbsp;&nbsp; &nbsp;if (is_real(value)) return round(value);<br>&nbsp;&nbsp; &nbsp;if (is_undefined(value)) return 0;<br>&nbsp;&nbsp; &nbsp;return value;<br>});<br><br>show_debug_message(json);</p><p>The above code takes a struct and stringifies it to JSON, pretty-printing it, and using a filter function to modify some types of values.</p><p>If the value is a <span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span>, it <a href="../../Maths_And_Numbers/Number_Functions/round.htm">rounds</a> it, if it's <span class="inline2">undefined</span>, it changes it to 0, otherwise it simply returns the same value (meaning it remains unchanged).</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Encoding_And_Hashing.htm">File Encoding</a></div><div style="float:right">Next: <a href="json_parse.htm">json_parse</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>