<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,n){let o;o=n?e.attr(n):e.html();let s=t[removeHtml(o)];if(null!=s&&s.length){t=retHtml(o);let a=0;t&&t.forEach(function(e,t){var n=s.replace("{"+a+"}",e);s=n===s?s.replace("{}",e):n,a++}),n?e.attr(n,s):e.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"After parsing the JSON string above, if you know its structure, you can use various&nbsp;{}Variable Functions{}&nbsp;to check and read its contents:":"解析完上面的 JSON 字符串，如果你知道它的结构，你可以使用各种 {} 变量函数 {} 来检查和读取它的内容:","Any runtime values serialised by&nbsp;{}{}json_stringify{}{}&nbsp;will be converted back to runtime values (e.g. {}handles{} and values like {}int64{}, {}NaN{} and {}infinity{}), however this conversion can be disabled by passing {}true{} into the optional&nbsp;{}{}inhibit_string_convert{} argument, meaning these will remain as strings.{}":"由 {}{}json_stringify{}{} 序列化的任何运行时值都将转换回运行时值 (例如 {}handles{} 以及 {}int64{}、{}NaN{} 和 {}infinity{} 等值)，不过，可以通过将 {}true{} 传递到可选的 {}{}inhibit_string_convert{} 参数来禁用此转换，这意味着这些转换将保留为字符串。{}","Filter Function&nbsp;{}{}OPTIONAL{}{}":"过滤功能 {}{} 可选 {}{}","If the supplied JSON string includes {}undefined{}&nbsp;as a value for any property, it will be converted to {}pointer_null{} upon being parsed.":"如果提供的 JSON 字符串包含 {}undefined{} 作为任何属性的值，它将在解析时转换为 {}pointer_null{}。","It takes two arguments&nbsp;{}(key, value){} where {}key{} is the struct key name ({}{}String{}{}) or array index ({}{}Real{}{}), and {}value{} is what's stored in that key/index.":"它需要两个参数 {}(key, value){}，其中 {}key{} 是结构体键名称 ({}{}String{}{}) 或数组索引 ({}{}Real{}{})，{} 值 {} 是存储在该键 / 索引中的内容。","Note how the filter function runs on the struct ({}myObj{}) and array ({}myArray{}) in the JSON and then also on each item inside the struct and array. It also runs on the root structure with the key set to an empty string (here, seen on the last line).":"请注意过滤器函数如何在 JSON 中的结构体 ({}myObj{}) 和数组 ({}myArray{}) 上运行，以及如何在结构体和数组内的每个项目上运行。它还在根结构上运行，并将键设置为空字符串 (此处，如最后一行所示)。","See&nbsp;{}{}json_stringify{}{}&nbsp;for more information on how GameMaker interacts with the JSON format.":"请参阅 {}{}json_stringify{}{}，了解有关 GameMaker 如何与 JSON 格式交互的更多信息。","The JSON string to parse":"要解析的 JSON 字符串","The above code creates a new string containing a valid JSON object, and then calls {}json_parse(){} to convert that string into a GML struct. It then prints the result to the debug log.":"上面的代码创建了一个包含有效 JSON 对象的新字符串，然后调用 {}json_parse(){} 将该字符串转换为 GML 结构。然后将结果打印到调试日志。","The above code creates a new string containing valid JSON, and then calls&nbsp;{}{}json_parse{}{} to convert that string into a GML struct. It then prints the result to the debug log.":"上面的代码创建一个包含有效 JSON 的新字符串，然后调用 {}{}json_parse{}{} 将该字符串转换为 GML 结构。然后它将结果打印到调试日志中。","The above code takes a JSON string containing an array inside a struct. Then {}json_parse(){} is run with a filter function that multiplies each value with 1000, only when it's a {}{}Real{}{}. Otherwise it simply returns the value itself.":"上面的代码采用一个 JSON 字符串，其中包含一个结构体中的数组。然后，使用过滤器函数运行 {}json_parse(){}，该函数将每个值乘以 1000( 仅当每个值是 {}{}Real{}{} 时)。否则它只是返回值本身。","The above code takes the same JSON string from the previous example, and converts it into a GML struct, however this time it uses a filter function.":"上面的代码采用与上一个示例相同的 JSON 字符串，并将其转换为 GML 结构，但是这次它使用了过滤器函数。","The above code will parse the given&nbsp;JSON string, generating the following console output:":"上面的代码将解析给定的 JSON 字符串，生成以下控制台输出:","The filter function can return a new value, which replaces the key's value in the final converted format returned by&nbsp;{}{}json_parse{}{}.":"过滤器函数可以返回一个新值，该值会替换 {}{}json_parse{}{} 返回的最终转换格式中的键值。","The filter function prints the key and value of each item to the Output Log:":"过滤器函数将每个项目的键和值打印到输出日志中：","The function optionally takes a&nbsp;{}{}Function{}{}, which runs once for each value in the structure, including all nested structs/arrays and all the values inside them.":"该函数可以选择采用 {}{}Function{}{}，该函数对结构中的每个值运行一次，包括所有嵌套结构 / 数组及其内部的所有值。","The resulting structure looks like this:":"结果结构如下所示：","This function can be used to parse a JSON string (either previously created using {}json_stringify{} or from any valid source), and convert it into a collection of arrays or structs, where an array is the equivalent of a JSON array and a struct is the equivalent of a JSON object. You supply the string to parse, and the function will return the top level array or struct which can then be used in your code. If you are not sure of the contents of the JSON, you can use the different {}Variable Functions{} (like {}{}typeof(){}{} and&nbsp;{}{}variable_struct_get_names(){}{}&nbsp;in case of a struct) to check the returned contents. Note that trying to parse an&nbsp;invalid value&nbsp;(i.e.: not a string) will throw an exception error.":"此函数可用于解析 JSON 字符串 (之前使用 {}json_stringify{} 创建或来自任何有效来源)，并将其转换为数组或结构的集合，其中数组等同于 JSON 数组和 结构 相当于一个 JSON 对象。 您提供要解析的字符串，该函数将返回顶级数组或结构，然后可以在您的代码中使用它们。 如果您不确定 JSON 的内容，您可以使用不同的 {} 变量函数 {}( 例如 {}{}typeof(){}{} 和 {}{}variable_struct_get_names(){}{} 如果是一个结构) 检查返回的内容。 请注意，尝试解析无效值 (即：不是字符串) 将引发异常错误。","This function can be used to parse a JSON string (either previously created using&nbsp;{}{}json_stringify{}{}&nbsp;or from any valid source), and convert it into a collection of arrays or structs, where an array is the equivalent of a JSON array and a struct is the equivalent of a JSON object.":"此函数可用于解析 JSON 字符串 (之前使用 {}{}json_stringify{}{} 创建或来自任何有效源)，并将其转换为数组或结构的集合，其中数组相当于 JSON 数组和结构相当于 JSON 对象。","This function only allows you to load JSON files with a maximum nesting limit of 128.":"此函数仅允许您加载最大嵌套限制为 128 的 JSON 文件。","Trying to parse an&nbsp;invalid value&nbsp;(i.e.: not a string, or invalid JSON) will throw an exception error.":"尝试解析无效值 (即：不是字符串或无效 JSON) 将引发异常错误。","When using this function there are some important things to note:":"在使用这个函数时，有一些重要的事情需要注意:","You supply the string to parse, and the function will return the top level array or struct which can then be used in your code. If you are not sure of the contents of the JSON, you can use the different {}Variable Functions{} (like {}{}typeof(){}{} and&nbsp;{}{}variable_struct_get_names(){}{}&nbsp;in case of a struct) to check the returned contents.":"您提供要解析的字符串，该函数将返回顶级数组或结构，然后可以在代码中使用它们。如果您不确定 JSON 的内容，可以使用不同的 {} 变量函数 {}( 例如 {}{}typeof(){}{} 和 {}{}variable_struct_get_names(){}{})，以防万一结构体) 来检查返回的内容。",'{}NOTE{}&nbsp;You will notice that the JSON string contains&nbsp;a backslash ({}\\{}) before every double quote ({}"{}) inside it:{} {} {}json = "{&nbsp;{}\\"&nbsp;{}myObj{}{} {} This is to ensure that the double quote is read as an actual character within the string, instead of being read as part of the code and closing the string prematurely. This way we are using a backslash to "escape" the double quote.{} {} If you are loading JSON from an external file however, there is no need to escape characters in that file and doing so may result in errors during parsing. ':'{}注意{} 你会注意到 JSON 字符串中每个双引号 ({}"{}) 之前都包含一个反斜杠 ({2}\\{3}): {}{}{}json = "{{}\\" {}myObj{}{}{} 这是为了确保双引号作为字符串中的一个实际字符被读取，而不是作为代码的一部分被读取并过早地关闭字符串。在这种情况下，我们使用反斜杠来“转义”双引号。{}{} 但是，如果从外部文件加载 JSON，则不需要转义该文件中的字符，这样做可能会在解析过程中导致错误。','{}NOTE{}&nbsp;You will notice that the JSON string contains&nbsp;a backslash ({}\\{}) before every double quote ({}"{}) inside it:{} {} {}json = "{&nbsp;{}\\"&nbsp;{}myObj{}{} {} This is to ensure that the double quote is read as an actual character within the string, instead of being read as part of the code and closing the string prematurely. This way we are using a backslash to "escape" the double quote.{} {} If you are loading JSON from an external file however, there is no need to escape characters in that file. ':'{} 注意{} 您会注意到 JSON 字符串在其中的每个双引号 ({}"{}) 之前都包含一个反斜杠 ({}\\{})：{}{}{}json = "{{}\\"{}myObj{}{}{} 这是为了确保双引号被读取为字符串中的实际字符，而不是被读取为代码的一部分并过早地关闭字符串。这样我们就可以使用反斜杠来 " 转义 " 双引号。{}{} 但是，如果您从外部文件加载 JSON，则无需转义该文件中的字符。',"{}null{} values are parsed as {}undefined{}.":"{}null{} 值被解析为 {} undefined {}。","{}{}NOTE{}{}&nbsp;When overriding a key's value in the filter function (using {}return{}), make sure you check its type first, as the filter function runs for the root structure and any nested structures as well, meaning accidentally overriding them will result in a broken final structure. See&nbsp;{}Example 3{} at the bottom.":"{}{} 注意{}{} 在过滤器函数中覆盖键的值 (使用 {}return{}) 时，请确保首先检查其类型，因为过滤器函数也会针对根结构和任何嵌套结构运行，这意味着意外覆盖它们将导致最终结构损坏。请参阅底部的 {} 示例 3{}。","{}{}OPTIONAL{}{}&nbsp;Filter function that processes each item. Syntax:&nbsp;{}function(key, value) -&gt; new_value{}":"{}{} 可选{}{} 处理每个项目的过滤器函数。语法：{} function(key, value) -&gt; new_value {}","{}{}OPTIONAL{}{}&nbsp;Set this to {}true{} to disable converting strings into runtime references. Default value: {}false{}":"{}{} 可选{}{} 将此设置为 {}true{} 以禁止将字符串转换为运行时引用。默认值：{}false{}"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.17.6.0_4"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>json_parse</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference page for json_parse"><meta name="rh-index-keywords" content="json_parse"><meta name="search-keywords" content="json_parse"><meta name="is_pure" content="true"><meta name="brsnext" value="GameMaker_Language/GML_Reference/File_Handling/Encoding_And_Hashing/base64_encode.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/File_Handling/Encoding_And_Hashing/json_stringify.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="json_parse"><span>json_parse</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">json_parse</span></h1><p>This function parses a JSON string and converts it into a collection of nested arrays and structs.&nbsp;An array is the equivalent of a JSON array and a struct is the equivalent of a JSON object.</p><p>The JSON should be either previously created using&nbsp;<span class="inline3_func"><a href="json_stringify.htm">json_stringify</a></span>&nbsp;or should come from any other valid source.</p><p>You supply the string to parse, and the function will return the top-level array or struct which can then be used in your code. If you are not sure of the contents of the JSON, you can use the different&nbsp;<a href="../../Variable_Functions/Variable_Functions.htm">Variable Functions</a>&nbsp;(like&nbsp;<span class="inline3_func"><a href="../../Variable_Functions/typeof.htm">typeof</a></span> and&nbsp;<span class="inline3_func"><a href="../../Variable_Functions/variable_struct_get_names.htm">struct_get_names</a></span> in case of a struct) to check the returned contents.</p><h3>Usage Notes</h3><ul class="colour"><li>Trying to parse an&nbsp;invalid value&nbsp;(i.e.: not a string, or invalid JSON) will throw an exception error.</li><li>This function only allows you to load JSON files with a maximum nesting limit of <span data-keyref="Const_JSON_Max_Nesting_Limit">128</span>.</li><li>Data conversions:<ul><li><span class="inline2">null</span> values are parsed as <span class="inline2">undefined</span>.</li><li>Any runtime values serialised by&nbsp;<span class="inline3_func"><a href="json_stringify.htm">json_stringify</a></span>&nbsp;will be converted back to runtime values (e.g. <a href="../../../GML_Overview/Data_Types.htm">handles</a> and values like <span class="inline2">int64</span>, <span class="inline2">NaN</span> and <span class="inline2">infinity</span>), however this conversion can be disabled by passing <span class="inline2">true</span> into the optional&nbsp;<span><span class="inline2">inhibit_string_convert</span> argument, meaning these will remain as strings.</span></li><li>See&nbsp;<a href="../../../../Additional_Information/Guide_To_Using_JSON.htm#data_conversions">Data Conversions</a>&nbsp;for a full overview.</li></ul></li><li>See&nbsp;<a href="../../../../Additional_Information/Guide_To_Using_JSON.htm">Guide To Using JSON</a>&nbsp;for more information on how&nbsp;<span data-keyref="GameMaker Name">GameMaker</span>&nbsp;interacts with the JSON format.</li></ul><div data-conref="../../../../assets/snippets/Note_See_Guide_To_Using_JSON.hts"><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;See&nbsp;<a href="../../../../Additional_Information/Guide_To_Using_JSON.htm">Guide To Using JSON</a>&nbsp;for detailed information on how to work with JSON in&nbsp;<span data-keyref="GameMaker Name">GameMaker</span>.</p></div><div data-conref="../../../../assets/snippets/JSON_Filter_Function_Description.hts"><h3>Filter Function&nbsp;<span data-conref="../../../../assets/snippets/Tag_optional.hts"><span class="optional">OPTIONAL</span></span></h3><p>The function optionally takes a&nbsp;<span data-keyref="Type_Function"><a target="_blank" href="../../../GML_Overview/Script_Functions.htm">Function</a></span>, which runs once for each value in the structure, including all nested structs/arrays and all the values inside them.</p><p>It takes two arguments&nbsp;<span class="inline2">(key, value)</span> where <span class="inline2">key</span> is the struct key name (<span data-keyref="Type_String"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">String</a></span>) or array index (<span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span>), and <span class="inline2">value</span> is what's stored in that key/index.</p><p>The filter function must always return a value. It can return a new value, which replaces the key's value in the final converted format returned by&nbsp;<span class="inline3_func"><span data-field="title" data-format="lower-alpha">json_parse</span></span>. If no new value should be returned for a particular key, the function must return the original <span class="inline2">value</span>.</p><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;When overriding a key's value in the filter function (using <a href="../../../GML_Overview/Language_Features/return.htm">return</a>), make sure you check its type first, as the filter function runs for the root structure and any nested structures as well, meaning accidentally overriding them will result in a broken final structure. See&nbsp;<strong>Example 3</strong> at the bottom.</p></div><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">json_parse</span>(json, [filter_func], [inhibit_string_convert])</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>json</td><td><span data-keyref="Type_String"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">String</a></span></td><td>The JSON string to parse</td></tr><tr><td>filter_func</td><td><span data-keyref="Type_Function"><a target="_blank" href="../../../GML_Overview/Script_Functions.htm">Function</a></span></td><td><span data-conref="../../../../assets/snippets/Tag_optional.hts"><span class="optional">OPTIONAL</span></span>&nbsp;Filter function that processes each item. Don't pass a value or set this to <span class="inline2">undefined</span> if you only want to set <span class="inline2">inhibit_string_convert</span>. Syntax:&nbsp;<span class="inline2">function(key, value) -&gt; new_value</span></td></tr><tr><td>inhibit_string_convert</td><td><span data-keyref="Type_Bool"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Boolean</a></span></td><td><span data-conref="../../../../assets/snippets/Tag_optional.hts"><span class="optional">OPTIONAL</span></span>&nbsp;Set this to <span class="inline2">true</span> to disable converting strings into runtime references. Default value: <span class="inline2">false</span></td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Struct"><a target="_blank" href="../../../GML_Overview/Structs.htm">Struct</a></span>&nbsp;or&nbsp;<span data-keyref="Type_Array"><a target="_blank" href="../../../GML_Overview/Arrays.htm">Array</a></span></p><p>&nbsp;</p><h4>Example 1:</h4><p class="code">var json = "{\"myObj\": { \"apples\":10, \"oranges\":12, \"potatoes\":100000, \"avocados\":0 }, \"myArray\":[0, 1, 2, 2, 4, 0, 1, 5, 1]}";<br><br>var data = json_parse(json);<br>show_debug_message(data);</p><p>The above code creates a new string containing valid JSON, and then calls&nbsp;<span class="inline3_func"><a href="json_parse.htm">json_parse</a></span> to convert that string into a GML struct. It then prints the result to the debug log.</p><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;You will notice that the JSON string contains&nbsp;a backslash (<span class="inline2">\</span>) before every double quote (<span class="inline2">"</span>) inside it:<br><br><span class="inline2">json = "{&nbsp;<strong>\"&nbsp;</strong>myObj</span><br><br>This is to ensure that the double quote is read as an actual character within the string, instead of being read as part of the code and closing the string prematurely. This way we are using a backslash to "escape" the double quote.<br><br>If you are loading JSON from an external file however, there is no need to escape characters in that file.</p><hr><p>After parsing the JSON string above, if you know its structure, you can use various&nbsp;<a href="../../Variable_Functions/Variable_Functions.htm">Variable Functions</a> to check and read its contents:</p><p class="code">var data = json_parse(json);<br><br>// Check if the struct has myObj variable<br>if (variable_struct_exists(data, "myObj"))<br>{<br>&nbsp; &nbsp; // Check if it's a struct<br>&nbsp; &nbsp; if (is_struct(data.myObj))<br>&nbsp;&nbsp; &nbsp;{<br>&nbsp; &nbsp; &nbsp; &nbsp; // Print all struct members to the log<br>&nbsp; &nbsp; &nbsp; &nbsp; var _names = variable_struct_get_names(data.myObj);<br>&nbsp; &nbsp; &nbsp; &nbsp; var _str = "";<br>&nbsp; &nbsp; &nbsp; &nbsp; for (var i = 0; i &lt; array_length(_names); i++;)<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;_str = _names[i] + ": " +&nbsp;string(variable_struct_get(data.myObj, _names[i]));<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; show_debug_message(_str);<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;}<br>&nbsp;&nbsp; &nbsp;}<br>}<br><br>// Check if the struct has myArray variable<br>if (variable_struct_exists(data, "myArray"))<br>{<br>&nbsp; &nbsp; // Check if it's an array<br>&nbsp; &nbsp; if (is_array(data.myArray))<br>&nbsp;&nbsp; &nbsp;{<br>&nbsp; &nbsp; &nbsp; &nbsp; show_debug_message(data.myArray);<br>&nbsp;&nbsp; &nbsp;}<br>}</p><p>The above code will parse the given&nbsp;JSON string, generating the following console output:</p><p class="code">oranges: 12<br>potatoes: 100000<br>avocados: 0<br>apples: 10<br>[ 0,1,2,2,4,0,1,5,1 ]</p><p>&nbsp;</p><h4>Example 2: Filter Function</h4><p class="code">var json = "{\"myObj\": { \"apples\":10, \"oranges\":12, \"potatoes\":100000, \"avocados\":0 }, \"myArray\":[0, 1, 2, 2, 4, 0, 1, 5, 1]}";<br><br>var data = json_parse(json, function (key, value)<br>{<br>&nbsp;&nbsp; &nbsp;show_debug_message($"Key: {key}, Value: {value}");<br>&nbsp; &nbsp; return value;<br>});</p><p>The above code takes the same JSON string from the previous example, and converts it into a GML struct, however this time it uses a filter function.</p><p>The filter function prints the key and value of each item to the Output Log:</p><p class="code_plain">Key: apples, Value: 10<br>Key: oranges, Value: 12<br>Key: potatoes, Value: 100000<br>Key: avocados, Value: 0<br>Key: myObj, Value: { apples : 10, oranges : 12, potatoes : 100000, avocados : 0 }<br>Key: 8, Value: 1<br>Key: 7, Value: 5<br>Key: 6, Value: 1<br>Key: 5, Value: 0<br>Key: 4, Value: 4<br>Key: 3, Value: 2<br>Key: 2, Value: 2<br>Key: 1, Value: 1<br>Key: 0, Value: 0<br>Key: myArray, Value: [ 0,1,2,2,4,0,1,5,1 ]<br>Key: , Value: { myObj : { apples : 10, oranges : 12, potatoes : 100000, avocados : 0 }, myArray : [ 0,1,2,2,4,0,1,5,1 ] }</p><p>Note how the filter function runs on the struct (<span class="inline2">myObj</span>) and array (<span class="inline2">myArray</span>) in the JSON and then also on each item inside the struct and array. It also runs on the root structure with the key set to an empty string (here, seen on the last line).</p><p>&nbsp;</p><h4>Example 3: Overriding Values</h4><p class="code">var json = "{\"prices\": [2, 5, 1, 2, 4, 5]}";<br><br>var data = json_parse(json, function (key, value)<br>{<br>&nbsp; &nbsp;&nbsp;return is_real(value) ? value * 1000 : value;<br>});<br><br>show_debug_message(data);</p><p>The above code takes a JSON string containing an array inside a struct. Then&nbsp;<span class="inline3_func"><span data-field="title" data-format="default">json_parse</span></span> is run with a filter function that multiplies each value with 1000, only when it's a <span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span>. Otherwise it simply returns the value itself.</p><p>The resulting structure looks like this:</p><p class="code_plain">{ prices : [ 2000,5000,1000,2000,4000,5000 ] }</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Encoding_And_Hashing.htm">File Encoding</a></div><div style="float:right">Next: <a href="base64_encode.htm">base64_encode</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>