<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,o){let n;n=o?e.attr(o):e.html();let i=t[removeHtml(n)];if(null!=i&&i.length){t=retHtml(n);let a=0;t&&t.forEach(function(e,t){var o=i.replace("{"+a+"}",e);i=o===i?i.replace("{}",e):o,a++}),o?e.attr(o,i):e.html(i)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={'Another feature of buffered audio is that you can use a buffer to create a queue of audio which can then be streamed to the device running your project. An audio queue takes a regular buffer which you have previously filled with audio data, and enables you to "point" to parts of it and tell {}GameMaker{} to stream the audio in a given order from that buffer. The available functions for audio queues are:':'缓冲音频的另一个函数是，您可以使用缓冲区创建音频队列，然后将其传输到运行项目的设备。音频队列采用您之前已填充音频数据的常规缓冲区，并使您能够"指向"它的一部分，并告诉{}GameMaker{}以给定的顺序从该缓冲区流式传输音频。音频队列的可用函数包括：',"Audio Buffers":"音频缓冲区","Audio buffers will also permit you to record sound from any of the available sources (like microphones or the OS), which can then be queued and streamed using the above functions (for example). Recording audio will trigger an {}Audio Recording Asynchronous Event{} which will contain specific information about what is being recorded.{} {} For recording audio, the following functions are available: ":"音频缓冲区还允许您录制来自任何可用源(如麦克风或操作系统)的声音，然后可以使用上述函数(例如)排队和流式传输。录制音频将触发{}音频录制异步事件{}，该事件将包含关于正在录制的内容的特定信息。{}{}录音函数如下：","Note that once you have created a sound from an audio buffer, you are {}not{} creating a new sound in memory, but rather pointing to the position within the buffer where the sound is stored. You should not change this buffer after a sound has been associated with it otherwise you will get unexpected results, and you cannot delete the buffer while a sound is associated with it. Instead, free the sound (or sounds) first then delete the buffer.":"请注意，从音频缓冲区创建声音后，您{}不会{}在内存中创建新声音，而是指向缓冲区内存储声音的位置。在声音与该缓冲区关联后，不应更改该缓冲区，否则会得到意外结果，并且在声音与该缓冲区关联时无法删除该缓冲区。相反，首先释放声音(或多个声音)，然后删除缓冲区。","Note that once you have created a sound from an audio buffer, you are {}not{} creating a new sound in memory, but rather pointing to the position within the buffer where the sound is stored. You should not change this buffer after a sound has been associated with it otherwise you will get unexpected results, and you cannot delete the buffer while a sound is associated with it. Instead, free the sound (or sounds) first then delete the buffer. Once you have created your new audio resource from a buffer, you can use it's index value in any of the regular audio functions to play it, change it's gain or pitch, pause it, etc... Note that the buffer used to load the audio {}can only support PCM sounds{}, so formats like OGG will not be supported.":"请注意，一旦您从音频缓冲区创建了一个声音，您就不是{}{}在内存中创建一个新的声音，而是指向缓冲区中存储声音的位置。在声音与此缓冲区关联后，不应更改此缓冲区，否则会出现意外结果，并且在声音与此缓冲区关联时，不能删除此缓冲区。相反，首先释放声音(或声音)，然后删除缓冲区。一旦你从缓冲区创建了新的音频资源，你可以在任何常规音频函数中使用它的索引值来播放它，改变它的增益或音调，暂停它，等等。请注意，用于加载音频的缓冲区{}只能支持PCM声音{}，因此像OGG这样的格式将不受支持。","Note that once you have created a sound from an audio buffer, you are {}not{} creating a new sound in memory, but rather pointing to the position within the buffer where the sound is stored. You should not change this buffer after a sound has been associated with it otherwise you will get unexpected results, and you cannot delete the buffer while a sound is associated with it. Instead, free the sound (or sounds) first then delete the buffer. Once you have created your new audio resource from a buffer, you can use its index value in any of the regular audio functions to play it, change its gain or pitch, pause it, etc. Note that the buffer used to load the audio {}can only support PCM sounds{}, so formats like OGG will not be supported.":"请注意，一旦您从音频缓冲区创建了一个声音，您就不是{}{}在内存中创建一个新的声音，而是指向缓冲区中存储声音的位置。在声音与此缓冲区关联后，不应更改此缓冲区，否则会出现意外结果，并且在声音与此缓冲区关联时，不能删除此缓冲区。相反，首先释放声音(或声音)，然后删除缓冲区。一旦你从缓冲区创建了新的音频资源，你可以在任何常规音频函数中使用它的索引值来播放它，改变它的增益或音调，暂停它，等等。请注意，用于加载音频的缓冲区{}只能支持PCM声音{}，因此像OGG这样的格式将不受支持。","Once a queue has been created, you can then use the returned queue index just as you would the sound index for any normal sound to play it, pause it, restart it, or change it's gain and pitch. The only thing you cannot do is get the track length or set the track position, but other than that, an audio queue can be used just like any other sound. You should also note that some of the audio queue functions will also trigger an {}Audio Playback Asynchronous Event{}.":"创建队列后，您可以像使用任何正常声音的声音索引一样使用返回的队列索引来播放、暂停、重新启动或更改其增益和音调。唯一做不到的是获取音轨长度或设置音轨位置，但除此之外，音频队列可以像任何其他声音一样使用。您还应该注意，一些音频队列函数也会触发{}音频回放异步事件{}。","Once you have created your new audio resource from a buffer, you can use its index value in any of the regular audio functions to play it, change its gain or pitch, pause it, etc. Note that the buffer used to load the audio {}can only support PCM sounds{}, so formats like OGG will not be supported.":"从缓冲区创建新的音频资源后，您可以在任何常规音频函数中使用其索引值来播放它、更改其增益或音调、暂停它等。请注意，用于加载音频的缓冲区{ }只能支持 PCM 声音{}，因此不支持 OGG 等格式。","You can use {}audio buffers{} to load, save and manipulate audio files within your games. These buffers are created beforehand using the appropriate {}buffer functions{}&nbsp;and then you can use the following functions to create a sound to use in your project:":"您可以使用{}音频缓冲区{}加载、保存和操作游戏中的音频文件。这些缓冲区是事先使用适当的{}缓冲区函数{}创建的，然后可以使用以下函数创建项目中使用的声音：","{}{}NOTE{} {}Most platforms {}except HTML5{} support recording audio in some form, but that does not mean that all devices will permit it, even if the platform does, so you should always check that the {}{}{}audio_get_recorder_count(){}{}{} function returns a value greater than 0 to verify that recording devices are available before using the rest of the recording functions.":"{}{}注意{}{}除 HTML5{}以外的大多数平台{}都支持以某种形式录制音频，但这并不意味着所有设备都会允许录制，即使平台允许，因此您应始终检查{}{}{}audio_get_recorder_count(){}{}{}函数返回大于0的值，以在使用其余录制函数之前验证录音设备是否可用。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../../..",gTopicId="8.2.2.3.5.5"</script><script type="text/javascript" src="../../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Audio Buffers</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../../assets/css/default.css" type="text/css"><script src="../../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page outlining the different functions and variables associated with Audio Buffers"><meta name="rh-index-keywords" content=""><meta name="search-keywords" content="Audio Buffers"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/audio_create_buffer_sound.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Groups/audio_group_get_gain.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Audio Buffers"><span>Audio Buffers</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>Audio Buffers</h1><p>You can use <b>audio buffers</b> to load, save and manipulate audio files within your games. These buffers are created beforehand using the appropriate <a href="../../../Buffers/Buffers.htm">buffer functions</a>&nbsp;and then you can use the following functions to create a sound to use in your project:</p><ul class="colour"><li><a href="audio_create_buffer_sound.htm">audio_create_buffer_sound</a></li><li><a href="audio_free_buffer_sound.htm">audio_free_buffer_sound</a></li></ul><p>&nbsp;</p><p>Note that once you have created a sound from an audio buffer, you are <i>not</i> creating a new sound in memory, but rather pointing to the position within the buffer where the sound is stored. You should not change this buffer after a sound has been associated with it otherwise you will get unexpected results, and you cannot delete the buffer while a sound is associated with it. Instead, free the sound (or sounds) first then delete the buffer.</p><p>Once you have created your new audio resource from a buffer, you can use its index value in any of the regular audio functions to play it, change its gain or pitch, pause it, etc. Note that the buffer used to load the audio <b>can only support PCM sounds</b>, so formats like OGG will not be supported.</p><h2>Audio Buffer Queues</h2><p>Another feature of buffered audio is that you can use a buffer to create a queue of audio which can then be streamed to the device running your project. An audio queue takes a regular buffer which you have previously filled with audio data, and enables you to "point" to parts of it and tell <span data-keyref="GameMaker Name">GameMaker</span> to stream the audio in a given order from that buffer. The available functions for audio queues are:</p><ul class="colour"><li><a href="audio_create_play_queue.htm">audio_create_play_queue</a></li><li><a href="audio_free_play_queue.htm">audio_free_play_queue</a></li><li><a href="audio_queue_sound.htm">audio_queue_sound</a></li></ul><p>Once a queue has been created, you can then use the returned queue index just as you would the sound index for any normal sound to play it, pause it, restart it, or change it's gain and pitch. The only thing you cannot do is get the track length or set the track position, but other than that, an audio queue can be used just like any other sound. You should also note that some of the audio queue functions will also trigger an <a href="../../../../../The_Asset_Editors/Object_Properties/Async_Events/Audio_Playback.htm">Audio Playback Asynchronous Event</a>.</p><h2>Recording</h2><p>Audio buffers will also permit you to record sound from any of the available sources (like microphones or the OS), which can then be queued and streamed using the above functions (for example). Recording audio will trigger an <a href="../../../../../The_Asset_Editors/Object_Properties/Async_Events/Audio_Recording.htm">Audio Recording Asynchronous Event</a> which will contain specific information about what is being recorded.<br><br>For recording audio, the following functions are available:</p><ul class="colour"><li><a href="audio_start_recording.htm">audio_start_recording</a></li><li><a href="audio_stop_recording.htm">audio_stop_recording</a></li><li><a href="audio_get_recorder_count.htm">audio_get_recorder_count</a></li><li><a href="audio_get_recorder_info.htm">audio_get_recorder_info</a></li></ul><p>&nbsp;</p><p class="note"><b><span class="note">NOTE</span></b> Most platforms <b>except HTML5</b> support recording audio in some form, but that does not mean that all devices will permit it, even if the platform does, so you should always check that the <span style="font-size:1px"><a href="audio_get_recorder_count.htm"><span class="inline">audio_get_recorder_count()</span></a></span> function returns a value greater than 0 to verify that recording devices are available before using the rest of the recording functions.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="../Audio.htm">Audio</a></div><div style="float:right">Next:&nbsp;<a href="../Audio_Synchronisation/Audio_Synchronisation.htm">Audio Synchronisation</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>