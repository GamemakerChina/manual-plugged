<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,n){let o;o=n?e.attr(n):e.html();let i=t[removeHtml(o)];if(null!=i&&i.length){t=retHtml(o);let a=0;t&&t.forEach(function(e,t){var n=i.replace("{"+a+"}",e);i=n===i?i.replace("{}",e):n,a++}),n?e.attr(n,i):e.html(i)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={'"{}buffer_id{}" - the buffer that is no longer being played from':'"{}buffer_id{}"不再播放的缓冲区','"{}queue_id{}" - the queue that has finished playing data':'"{}queue_id{}"已完成播放数据的队列','"{}queue_shutdown{}" - this is set to 0 during normal playback and 1 when the event is received because you have freed the queue with this function. When this is set to 1, you don\'t want to queue up any further data.':'"{}queue_shutdown{}"在正常播放期间设置为 0，当收到事件时设置为 1，因为您已使用此函数释放队列。将其设置为 1 时，您不想将任何进一步数据排队。','The above code would go in the asynchronous {}Audio Playback{} event and checks to see if the audio that has finished playing is from the "audio_queue" and if it is it frees the queue and the buffer associated with it.':'上述代码将在异步{}音频回放{}事件中进行，并检查以查看已完成播放的音频是否来自"audio_queue"，如果是，则释放队列和与其关联的缓冲区。',"The index of the queue to free.":"要释放的队列的索引。","This function is used to free up the memory associated with the given audio queue. The queue index is the value returned when you created the queue using the function {}{}audio_create_play_queue(){}{}, and this function should be called when the queue is no longer required to prevent memory leaks. Freeing the queue will stop any sound that is be playing, and you cannot delete the buffer that a sound is being streamed from until the queue it is assigned to has been freed.":"此函数用于释放与给定音频队列关联的内存。队列索引是使用函数{}{}audio_create_play_queue(){}{}创建队列时返回的值，当不再需要队列时应调用此函数以防止内存泄漏。释放队列将停止正在播放的任何声音，并且在释放声音所分配到的队列之前，您无法删除正在传输声音的缓冲区。","This function is used to free up the memory associated with the given audio queue. The queue index is the value returned when you created the queue using the function {}{}audio_create_play_queue(){}{}, and this function should be called when the queue is no longer required to prevent memory leaks. Freeing the queue will stop any sound that is be playing, and you cannot delete the buffer that a sound is being streamed from until the queue it is assigned to has been freed. This function will trigger an {}Audio Playback Asynchronous Event{}, and in this event a special {}DS map{}&nbsp;will be created in the variable {}{}async_load{}{} with the following key/value pairs:":"此函数用于释放与给定音频队列相关的内存。队列索引是使用函数{}{}audio_create_play_queue(){}{}创建队列时返回的值，当不再需要队列以防止内存泄漏时，应调用此函数。释放队列将停止任何正在播放的声音，并且您不能删除正在流播放的声音的缓冲区，直到分配给它的队列被释放为止。此函数将触发{}音频回放异步事件{}，在这种情况下，将在变量{}async_load{}中创建具有以下键/值对的特殊{}{}DS map{}{}：","This function will trigger an {}Audio Playback Asynchronous Event{}, and in this event a special {}DS map{}&nbsp;will be created in the variable {}{}async_load{}{} with the following key/value pairs:":"此函数将触发{}音频播放异步事件{}，在此事件中，将使用以下键/值对在变量{}{}async_load{}{}中创建一个特殊的{2}DS 映射{3}："},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../../..",gTopicId="8.2.2.3.5.5.0_4"</script><script type="text/javascript" src="../../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>audio_free_play_queue</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../../assets/css/default.css" type="text/css"><script src="../../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page explaining the function audio_free_play_queue"><meta name="rh-index-keywords" content="audio_free_play_queue"><meta name="search-keywords" content="audio_free_play_queue"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/audio_queue_sound.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/audio_create_play_queue.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="audio_free_play_queue"><span>audio_free_play_queue</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>audio_free_play_queue</h1><p>This function is used to free up the memory associated with the given audio queue. The queue index is the value returned when you created the queue using the function <a href="audio_create_play_queue.htm"><span class="inline">audio_create_play_queue()</span></a>, and this function should be called when the queue is no longer required to prevent memory leaks. Freeing the queue will stop any sound that is be playing, and you cannot delete the buffer that a sound is being streamed from until the queue it is assigned to has been freed.</p><p>This function will trigger an <a href="../../../../../The_Asset_Editors/Object_Properties/Async_Events/Audio_Playback.htm">Audio Playback Asynchronous Event</a>, and in this event a special <a href="../../../Data_Structures/DS_Maps/DS_Maps.htm">DS map</a>&nbsp;will be created in the variable <a href="../../../../GML_Overview/Variables/Builtin_Global_Variables/async_load.htm"><span class="inline">async_load</span></a> with the following key/value pairs:</p><ul class="colour"><li>"<strong>queue_id</strong>" - the queue that has finished playing data</li><li>"<strong>buffer_id</strong>" - the buffer that is no longer being played from</li><li>"<strong>queue_shutdown</strong>" - this is set to 0 during normal playback and 1 when the event is received because you have freed the queue with this function. When this is set to 1, you don't want to queue up any further data.</li></ul><p>&nbsp;</p><h4>Syntax:</h4><p class="code">audio_free_play_queue(queueIndex);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>queueIndex</td><td><span data-keyref="Type_ID_Audio_Queue"><a target="_blank" href="audio_create_play_queue.htm">Audio Queue ID</a></span></td><td>The index of the queue to free.</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Void">N/A</span></p><p>&nbsp;</p><h4>Example:</h4><p class="code">var q_id = async_load[? "queue_id"];<br>if (q_id == audio_queue)<br>{<br>&nbsp; &nbsp; audio_free_play_queue(audio_queue);<br>&nbsp; &nbsp; buffer_delete(audio_buffer);<br>}</p><p>The above code would go in the asynchronous <a href="../../../../../The_Asset_Editors/Object_Properties/Async_Events/Audio_Playback.htm">Audio Playback</a> event and checks to see if the audio that has finished playing is from the "audio_queue" and if it is it frees the queue and the buffer associated with it.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../Audio.htm">Audio Buffers</a></div><div style="float:right">Next:&nbsp;<a href="audio_queue_sound.htm">audio_queue_sound</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>