<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/main.css"><script>let str;removeHtml=function(t){return t=(t=(t=(t=t.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(t){return t.match(/(<([^>]+)>)/gi)},setTranslator=function(t,e,o){let a;a=o?t.attr(o):t.html();let r=e[removeHtml(a)];if(null!=r&&r.length){e=retHtml(a);let n=0;e&&e.forEach(function(t,e){var o=r.replace("{"+n+"}",t);r=o===r?r.replace("{}",t):o,n++}),o?t.attr(o,r):t.html(r)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var t=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(t):($(".topic-header").append(t),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(t){return t.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={'"{}channels{}" - the constant {}audio_mono{} (further constants for stereo and 3D may be supported in the future)':'"{}channels{}"常量{}audio_mono{}(将来可能支持立体声和3D的更多常量)','"{}data_format{}" - the format data will be returned in (this is currently always {}buffer_s16{} but other formats may be supported in the future)':'"{}data_format{}"格式数据将返回(当前始终为{}buffer_s16{}，但将来可能支持其他格式)','"{}index{}" - the index to be used to record':'"{}index}"-用于记录的索引','"{}name{}" - a name to describe the device':'"{}name{}"用于描述设备的名称','"{}sample_rate{}" - the sample rate (in Hz) of the data returned (currently clamped to 16000hz but this may change in future)':'"{}sample_rate{}"返回数据的采样速率(单位：Hz)(当前被箝位至16000Hz，但以后可能会改变)',"Note that while the function creates a DS map for you, it does {}not{} remove it again later and so you should be destroying the map yourself when it is no longer needed to prevent any memory leaks.":"请注意，虽然该函数为您创建了一个DS map，但它不会在以后{}{}再次删除它，因此当不再需要它时，您应该自己销毁该映射，以防止任何内存泄漏。","The above code would be called in the asynchronous {}Audio Recording{} event and assigns some recorded data to a buffer, which is then added to an audio queue. This is then played.":"上述代码将在异步{}音频记录{}事件中调用，并将一些记录数据分配给缓冲器，然后将其添加到音频队列中。然后播放。","The index of the recorder source to get the information from.":"要从中获取信息的记录器源的索引。","This function will return a {}DS Map{}&nbsp;with information about the given recorder source index. You can find out how many recorder sources are available using the function {}{}audio_get_recorder_count(){}{}, and the map returned will contain the following key/value pairs:":"此函数将返回{}DS map{}，其中包含有关给定记录器源索引的信息。您可以使用函数{}{}audio_get_recorder_count(){}{}来查找有多少录音机源可用，返回的映射将包含以下键/值对：","{}{}NOTE{} {}Most platforms support recording audio in some form, but that does not mean that all devices will permit it, even if the platform does, so you should always check that the {}{}{}audio_get_recorder_count(){}{}{} function returns a value greater than 0 to verify that recording devices are available before using the rest of the recording functions.":"{}{}注意{}{}大多数平台支持以某种形式录制音频，但这并不意味着所有设备都会允许录制，即使平台允许，因此您应始终检查{}{}{}audio_get_recorder_count(){}{}{}函数返回大于0的值，以验证在使用其余录制函数之前录音设备是否可用。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(t){json_global=t}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../../..",gTopicId="8.2.2.3.5.5.0_9"</script><script type="text/javascript" src="../../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>audio_get_recorder_info</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../../assets/css/default.css" type="text/css"><script src="../../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page explaining the function audio_get_recorder_info"><meta name="rh-index-keywords" content="audio_get_recorder_info"><meta name="search-keywords" content="audio_get_recorder_info"><meta name="is_pure" content="true"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Synchronisation/Audio_Synchronisation.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Asset_Management/Audio/Audio_Buffers/audio_get_recorder_count.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="audio_get_recorder_info"><span>audio_get_recorder_info</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>audio_get_recorder_info</h1><p>This function will return a <a href="../../../Data_Structures/DS_Maps/DS_Maps.htm">DS Map</a>&nbsp;with information about the given recorder source index. You can find out how many recorder sources are available using the function <a href="audio_get_recorder_count.htm"><span class="inline">audio_get_recorder_count()</span></a>, and the map returned will contain the following key/value pairs:</p><ul class="colour"><li>"<strong>name</strong>" - a name to describe the device</li><li>"<strong>index</strong>" - the index to be used to record</li><li>"<strong>data_format</strong>" - the format data will be returned in (this is currently always <span class="inline">buffer_s16</span> but other formats may be supported in the future)</li><li>"<strong>sample_rate</strong>" - the sample rate (in Hz) of the data returned (currently clamped to 16000hz but this may change in future)</li><li>"<strong>channels</strong>" - the constant <span class="inline">audio_mono</span> (further constants for stereo and 3D may be supported in the future)</li></ul><p>Note that while the function creates a DS map for you, it does <i>not</i> remove it again later and so you should be destroying the map yourself when it is no longer needed to prevent any memory leaks.</p><p class="note"><b><span class="note">NOTE</span></b> Most platforms support recording audio in some form, but that does not mean that all devices will permit it, even if the platform does, so you should always check that the <span style="font-size:1px"><a href="audio_get_recorder_count.htm"><span class="inline">audio_get_recorder_count()</span></a></span> function returns a value greater than 0 to verify that recording devices are available before using the rest of the recording functions.</p><p>&nbsp;</p><h4>Syntax:</h4><p class="code">audio_get_recorder_info(recorder_index);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>recorder_index</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The index of the recorder source to get the information from.</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_ID_DS_Map"><a target="_blank" href="../../../Data_Structures/DS_Maps/ds_map_create.htm">DS Map</a></span></p><p>&nbsp;</p><h4>Example:</h4><p class="code">len = async_load[? "data_len"];<br>audio_buff = buffer_create(len, buffer_fast, 1);<br>buffer_copy(async_load[? "buffer_id"], 0, len, buff, 0);<br>audio_queue_sound(audio_queue, audio_buff, 0, len);<br>audio_play_sound(audio_queue, 10, 0);</p><p>The above code would be called in the asynchronous <a href="../../../../../The_Asset_Editors/Object_Properties/Async_Events/Audio_Recording.htm">Audio Recording</a> event and assigns some recorded data to a buffer, which is then added to an audio queue. This is then played.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../Audio.htm">Audio Buffers</a></div><div style="float:right">Next:&nbsp;<a href="audio_create_buffer_sound.htm">audio_create_buffer_sound</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>