<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/main.css"><script>let str;removeHtml=function(t){return t=(t=(t=(t=t.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(t){return t.match(/(<([^>]+)>)/gi)},setTranslator=function(t,e,a){let n;n=a?t.attr(a):t.html();let i=e[removeHtml(n)];if(null!=i&&i.length){e=retHtml(n);let o=0;e&&e.forEach(function(t,e){var a=i.replace("{"+o+"}",t);i=a===i?i.replace("{}",t):a,o++}),a?t.attr(a,i):t.html(i)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var t=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(t):($(".topic-header").append(t),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(t){return t.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={'A special constant that is for "and"-ing with the tile data blob to extract the tile index.':'用于"和"的专用常量，与块数据块一起提取块索引。','An easy way to get the initial index mask value is to take the number of tiles in the tile set and subtract 1, so a 16x16 tile set has 256 tiles and a mask value of 255 (or $ff in hexadecimal), and if the tile set has a number of tiles that are not a power of two, then round up to the nearest power of two to get the mask, for example a tile set that is 20x20 has 400 tiles, which you would round up to 512, and so get a mask index value of 511 ($1ff in hexadecimal). Apart from the index mask, normally you would want to preserve the flip, rotate and mirror values that are assigned to a tile too, so to help with that there are a few {}constants{} that can be used. These can be "or"-ed together with the index mask value to preserve those bits of data. The following constants can be used (see the example code below for usage):':'获得初始索引掩码值的简单方法是取图块集中的图块数并减去1，因此，16x16的图块集有256个图块，掩码值为255(或$ ff，十六进制)，如果图块集的图块数不是2的幂，则向上四舍五入到最接近的2次方以获得掩码，例如，20x20的图块集有400个图块，这四舍五入到512，因此得到掩码索引值511(十六进制为$ 1ff)。除了索引掩码之外，通常您还希望保留分配给图块的翻转、旋转和镜像值，以便帮助使用一些{}常数{}。这些可以与索引掩码值一起"或"化，以保留这些数据位。可以使用以下常量(有关用法，请参见下面的示例代码)：',"The above code gets the tile map ID from the given layer and then sets the tile map bit mask to 8bits, preserving the flip, mirror, and rotate values for each tile in the map.":"上述代码从给定层获取图块映射ID，然后将图块映射位掩码设置为8位，保留映射中每个图块的翻转、镜像和旋转值。","The mask value":"掩码值","The unique ID value of the tile map element to set the mask of":"要设置掩码的图块贴图元素的唯一ID值",'This function can be used to set the {}tile bit mask{} for a single tile map. You give the tile map element ID (which you get when you create a tile map element using {}{}layer_tilemap_create(){}{} or when you use the function {}{}layer_tilemap_get_id(){}{}), and then the mask value. The idea is that if you have, for example, a pretty small tile set of 16 x 16 tiles then you have a total of 256 different tiles in your tile set, which only uses up 8 bits of your index in the tile data "blob" (from an available 19 bits of data). These bits can be "masked" and then the rest of the tile data can be used to store additional values.':'此函数可用于设置单个图块贴图的{}块位掩码{}。为贴图元素 ID(当使用{}{}layer_tilemap_create(){}{}或使用函数{}{}layer_tilemap_get_id(){}{}创建图块贴图元素时获得的 ID)，然后给出掩码值。其思想是，例如，如果您有一个相当小的16 x 16块的图块集，那么您的图块集中总共有256个不同的图块，这在图块数据"blob"(从可用的19位数据)中仅使用8位索引。这些位可以被"屏蔽"，然后其余的图块数据可用于存储附加值。',"Tile Mask Constant":"图块遮罩常数",'Tile map bit masking is an advanced feature and allows you to use bits of the tile data "blob" for your own use. For example, the user could reserve a bit to mean "solid" in the tile-data structure and then this can be checked for fast collisions. Basically, the bit mask is "and"-ed against the tile data when the tile map is {}drawn{} (so it doesn\'t affect any of the other functionality), meaning that bits which aren\'t in the mask are ignored, but can still be read and written to by the user for their own purposes. Note that there are two different masks – a global one and one per tile map - and these are "and"-ed together internally by {}GameMaker{} before being used for drawing.':'图块贴图位掩码是一项高级函数，允许您使用图块数据的位"blob"供您自己使用。例如，用户可以在图块数据结构中保留一个表示"实心"的位，然后可以检查快速冲突。基本上，当绘制图块映射{}时，位掩码相对于图块数据"和"ed{}(因此不影响任何其他函数)，意味着不在掩码中的位被忽略，但用户仍可以出于自己的目的读取和写入。请注意，有两种不同的蒙版 – 全局蒙版和每块贴图一个，它们在用于绘制之前由{}GameMaker{}内部组合在一起。',"Used to set/get the flip bit of a tile data blob.":"用于设置/获取图块数据块的翻转位。","Used to set/get the mirror bit of a tile data blob.":"用于设置/获取图块数据块的镜像位。","Used to set/get the rotate bit of a tile data blob.":"用于设置/获取图块数据块的旋转位。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(t){json_global=t}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../../..",gTopicId="8.2.2.3.14.2.0_11"</script><script type="text/javascript" src="../../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>tilemap_set_mask</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../../assets/css/default.css" type="text/css"><script src="../../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page outlining the function tilemap_set_mask"><meta name="rh-index-keywords" content="tilemap_set_mask,tile_rotate,tile_mirror,tile_flip,tile_index_mask"><meta name="search-keywords" content="tilemap_set_mask,tile_rotate,tile_mirror,tile_flip,tile_index_mask"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Asset_Management/Rooms/Tile_Map_Layers/tilemap_set_global_mask.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Asset_Management/Rooms/Tile_Map_Layers/tilemap_set_at_pixel.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="tilemap_set_mask"><span>tilemap_set_mask</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">tilemap_set_mask</span></h1><p>This function sets the&nbsp;<a data-rhwidget="HyperlinkPopover" href="Tile_Map_Layers.htm#tile_map_bit_mask">Tile Map Bit Mask</a>&nbsp;for a single tile map.</p><p>You give the tile map element ID (which you get when you create a tile map element using&nbsp;<span class="inline3_func"><a href="layer_tilemap_create.htm">layer_tilemap_create</a></span> or when you use the function <span class="inline3_func"><a href="layer_tilemap_get_id.htm">layer_tilemap_get_id</a></span>), and then the mask value. If you have, for example, a pretty small tile set of 16 x 16 tiles then you have a total of 256 different tiles in your tile set. You only need 8 bits of the&nbsp;<a data-rhwidget="HyperlinkPopover" href="Tile_Map_Layers.htm#h3"></a> to index these tiles (from an available&nbsp;<span data-keyref="Const_Tile_Data_Max_Index_Bits">19</span> bits of data). These bits can be "masked" and then the rest of the tile data can be used to store additional values. See&nbsp;<a href="Tile_Map_Layers.htm#calculating_the_mask_bits">Calculating the Mask Bits</a>.</p><p>Tile map bit masking is an advanced feature and allows you to use bits of the tile data "blob" for your own use. For example, you could reserve a bit to mean "solid" in the tile data&nbsp;that can then be checked for fast collisions. Basically, the bit mask is "and"-ed against the tile data when the tile map is <i>drawn</i> (so it doesn't affect any of the other functionality), meaning that bits which aren't in the mask are ignored, but can still be read and written to by the user for their own purposes.</p><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">tilemap_set_mask</span>(tilemap_element_id, mask);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>tilemap_element_id</td><td><span data-keyref="Type_ID_Element_Tilemap"><a target="_blank" href="layer_tilemap_get_id.htm">Tile Map Element ID</a></span></td><td>The unique ID value of the tile map element to set the mask of</td></tr><tr><td>mask</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The mask value</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Void">N/A</span></p><p>&nbsp;</p><h4>Example 1: Using 8 bits for the tile index</h4><p class="code">var _lay_id = layer_get_id("Tiles_sky");<br>var _map_id = layer_tilemap_get_id(_lay_id);<br>var _mask = tile_mirror | tile_flip | tile_rotate | 255;<br>tilemap_set_mask(_map_id, _mask);</p><p>The above code gets the tile map ID from the given layer and then sets the tile map bit mask to 8bits (a value of <span class="inline2">255</span> or&nbsp;<span class="inline2">0b11111111</span>), preserving the flip, mirror, and rotate values for each tile in the map.</p><p>&nbsp;</p><h4>Example 2: Resetting to the default mask</h4><p class="code">var _lay_id = layer_get_id("Tiles_sky");<br>var _map_id = layer_tilemap_get_id(_lay_id);<br>var _mask = tile_mirror | tile_flip | tile_rotate | tile_index_mask;<br>tilemap_set_mask(_map_id, _mask);</p><p>The above code sets the tile bit mask to the value needed for&nbsp;<span data-keyref="GameMaker Name">GameMaker</span>&nbsp;to draw tiles correctly by combining all tile mask constants using bitwise OR. The full&nbsp;<span data-keyref="Const_Tile_Data_Max_Index_Bits">19</span>&nbsp;bits are used for the tile index and the mirror, flip and rotate bits are preserved.</p><p>&nbsp;</p><h4>Example 3: Writing and reading back custom data</h4><p class="code_heading">Create Event</p><p class="code">randomise();<br><br>var _lay_id = layer_get_id("Tiles_1");<br>var _map_id = layer_tilemap_get_id(_lay_id);<br>var _mask = tile_mirror | tile_flip | tile_rotate | 255;<br>tilemap_set_mask(_map_id, _mask);<br>for(var _x = 0;_x &lt; tilemap_get_width(_map_id);_x++)<br>{<br>&nbsp; &nbsp; for(var _y = 0;_y &lt; tilemap_get_height(_map_id);_y++)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; var _tdata = tilemap_get(_map_id, _x, _y);<br>&nbsp; &nbsp; &nbsp; &nbsp; var _random_value = irandom(255);<br>&nbsp; &nbsp; &nbsp; &nbsp; var _random_value_shifted = _random_value &lt;&lt; 8;<br>&nbsp; &nbsp; &nbsp; &nbsp; _tdata |= _random_value_shifted;<br>&nbsp; &nbsp; &nbsp; &nbsp; tilemap_set(_map_id, _tdata, _x, _y);<br>&nbsp; &nbsp; }<br>}</p><p class="code_heading">Step Event</p><p class="code">var _tdata = tilemap_get_at_pixel(map_id, mouse_x, mouse_y);<br>random_value_under_cursor = (_tdata &gt;&gt; 8) &amp; 255;</p><p class="code_heading">Draw GUI Event</p><p class="code">draw_text(5, 5, $"Value: {random_value_under_cursor}");</p><p>The above code shows how to store some custom data in the cells of a tile map and read them back.</p><p>In the Create event the bit mask is set to be the 8 lowest bits plus the mirror, flip and rotate bits. A random integer value from 0 to 255 is then written to bit 8 to 15 of each tile. This is done as follows: the bits of <span class="inline2">_random_value</span> are first shifted <em>left</em> by 8 bits, for example a value of&nbsp;<span class="inline2">0b0000000011001111</span>&nbsp;(<span class="inline2">207</span>) becomes <span class="inline2">0b1111111100000000</span>&nbsp;(<span class="inline2">52992</span>). This result is stored in <span class="inline2">_random_value_shifted</span>. This value is then bitwise "or"-ed <span class="inline2">|</span>&nbsp;with the tile data, which will result in a 1 bit whenever a bit is set in either the tile data or in the random value. The tile data is then written back to the same tile map call using <span class="inline3_func"><a href="tilemap_set.htm">tilemap_set</a></span>.</p><p>In the Step event the tile data under the mouse is looked up using&nbsp;<span class="inline3_func"><a href="tilemap_get_at_pixel.htm">tilemap_get_at_pixel</a></span>. To get the random value back out, the bits are first shifted <em>right</em>&nbsp;by 8 bits, which moves the 8 bits of the random value back to bit positions 0 to 7 (the index bits are also shifted right and so are lost at this point). This new value is then bitwise "and"-ed <span class="inline2">&amp;</span>&nbsp;with 255 to only keep the lower 8 bits that hold the random value (any of the mirror, flip or rotate bits may be set which, without "and"-ing would give a much higher value). The result is assigned to <span class="inline2">random_value_under_cursor</span>.</p><p>The random value stored in the tile under the mouse position is displayed in the Draw GUI event.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="Tile_Map_Layers.htm">Tile Map Elements</a></div><div style="float:right">Next:&nbsp;<a href="tilemap_set_global_mask.htm">tilemap_set_global_mask</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>