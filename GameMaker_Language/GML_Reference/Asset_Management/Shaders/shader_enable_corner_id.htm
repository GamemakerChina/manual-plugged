<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,o){let a;a=o?e.attr(o):e.html();let l=t[removeHtml(a)];if(null!=l&&l.length){t=retHtml(a);let n=0;t&&t.forEach(function(e,t){var o=l.replace("{"+n+"}",e);l=o===l?l.replace("{}",e):o,n++}),o?e.attr(o,l):e.html(l)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Enable ({}true{}) or disable ({}false{}) this function.":"启用({}true{})或禁用({}false{})此函数。",'It sets a global state for all&nbsp;shaders being used where, when enabled, the shader "steals" 2 bits from the input colour values; one from the lowest bit of the red colour value, and one from the lowest bit of the blue colour value. These values can then be recovered in the shader to work out which vertex you are&nbsp;dealing with (i.e.&nbsp;which corner).':'它为所有正在使用的着色器设置一个全局状态，当启用时，着色器从输入颜色值中"窃取"2位;一个来自红色值的最低位，一个来自蓝色值的最低位。然后可以在着色器中恢复这些值，以确定您正在处理的顶点(即哪个角落)。',"The above code will enable the use of colour bits for the corner ID for all shaders.":"上面的代码将启用所有着色器的角点ID的颜色位。","The above code will enable the use of colour bits for the corner id for all shaders.":"上面的代码将启用所有着色器的角点ID的颜色位。","The following table lists the possible values and their corresponding corner position:&nbsp;":"下表列出了可能的值及其对应的角点位置：","The lowest bit of the {}blue{} component stores the {}most significant bit{}, the lowest bit of the {}red{}&nbsp;component stores the {}least significant bit{}. You can calculate the corner ID in a vertex shader by doing this:":"{}蓝色{}分量的最低位存储{}最高有效位{}，{}红色{}分量的最低位存储{}最低有效位{}。您可以通过执行以下操作来计算顶点着色器中的角ID：","This function enables the use of corner IDs in shaders.":"此函数允许在着色器中使用角ID。",'With this function you can set a global state for all shaders being used where, when enabled, the shader "steals" 2 bits from the input colour values. The first is from the lower bit of the red colour value, and the second is from the lower bit of the blue colour value. These values can get then be recovered in the shader to work out which vertex you are&nbsp;dealing with (ie: which corner).':'使用此功能，您可以为所有正在使用的着色器设置全局状态，当启用该着色器时，着色器将从输入颜色值"窃取"2位。第一个来自红色值的低位，第二个来自蓝色值的低位。然后可以在着色器中恢复这些值，以确定您正在处理的是哪个顶点(即：哪个角)。','With this function you can set a global state for all shaders being used where, when enabled, the shader "steals" 2 bits from the input colour values. The first is from the lower bit of the red colour value, and the second is from the lower bit of the blue colour value. These values can then be recovered in the shader to work out which vertex you are&nbsp;dealing with (ie: which corner).':'使用此功能，您可以为所有正在使用的着色器设置全局状态，当启用该着色器时，着色器将从输入颜色值"窃取"2位。第一个来自红色值的低位，第二个来自蓝色值的低位。然后可以在着色器中恢复这些值，以确定您正在处理的是哪个顶点(即：哪个角)。',"{}{}NOTE{}{}&nbsp;The corner IDs are numbered consecutively going clockwise, starting at 0 for the top-left corner.":"{}{}注意{}{} 角 ID 按顺时针方向连续编号，左上角从 0 开始编号。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.3.8.0_16"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>shader_enable_corner_id</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page outlining the function shader_enable_corner_id"><meta name="rh-index-keywords" content="shader_enable_corner_id"><meta name="search-keywords" content="shader_enable_corner_id"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Asset_Management/Shaders/Shader_Constants.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_current.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="shader_enable_corner_id"><span>shader_enable_corner_id</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">shader_enable_corner_id</span></h1><p>This function enables the use of corner IDs in shaders.</p><p>It sets a global state for all&nbsp;shaders being used where, when enabled, the shader "steals" 2 bits from the input colour values; one from the lowest bit of the red colour value, and one from the lowest bit of the blue colour value. These values can then be recovered in the shader to work out which vertex you are&nbsp;dealing with (i.e.&nbsp;which corner).</p><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;This will not work when using <a href="../../Drawing/Primitives/Primitives_And_Vertex_Formats.htm">vertex buffers and primitives</a> as the colour data for each vertex is handled by the user.</p><p>The lowest bit of the <em>blue</em> component stores the <em>most significant bit</em>, the lowest bit of the <em>red</em>&nbsp;component stores the <em>least significant bit</em>. You can calculate the corner ID in a vertex shader by doing this:</p><pre data-stringify-type="pre">vec2 rem = mod(in_Colour.rb * 255., 2.);
int corner_id = int(dot(vec2(1., 2.), rem));</pre><p>The following table lists the possible values and their corresponding corner position:&nbsp;</p><table id="shader_corner_id" style="caption-side:top"><caption id="">Shader Corner ID</caption><colgroup><col style="width:25%"><col style="width:25%"><col style="width:25%"><col style="width:25%"></colgroup><tbody><tr><th>Red Lowest Bit</th><th>Blue Lowest Bit</th><th>Corner ID</th><th>Position</th></tr><tr><td>0</td><td>0</td><td>0</td><td>Top-left</td></tr><tr><td>1</td><td>0</td><td>1</td><td>Top-right</td></tr><tr><td>0</td><td>1</td><td>2</td><td>Bottom-right</td></tr><tr><td>1</td><td>1</td><td>3</td><td>Bottom-left</td></tr></tbody></table><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;The corner IDs are numbered consecutively going clockwise, starting at 0 for the top-left corner.</p><p>&nbsp;</p><h4>Syntax:</h4><p class="code"><span data-field="title" data-format="default">shader_enable_corner_id</span>(enable);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>enable</td><td><span data-keyref="Type_Bool"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Boolean</a></span></td><td>Enable (<span class="inline">true</span>) or disable (<span class="inline">false</span>) this function.</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Void">N/A</span></p><p>&nbsp;</p><h4>Example:</h4><p class="code"><span data-field="title" data-format="default">shader_enable_corner_id</span>(true);</p><p>The above code will enable the use of colour bits for the corner ID for all shaders.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="Shaders.htm">Shaders</a></div><div style="float:right">Next:&nbsp;<a href="shader_get_name.htm">shader_get_name</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>