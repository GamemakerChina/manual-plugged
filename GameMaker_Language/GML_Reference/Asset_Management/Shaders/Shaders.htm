<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let o;o=a?e.attr(a):e.html();let s=t[removeHtml(o)];if(null!=s&&s.length){t=retHtml(o);let n=0;t&&t.forEach(function(e,t){var a=s.replace("{"+n+"}",e);s=a===s?s.replace("{}",e):a,n++}),a?e.attr(a,s):e.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"All target platforms":"所有目标平台","As an extra check you can also call the function {}{}shaders_are_supported(){}{}&nbsp;to see if the hardware even supports shaders. In general you'd do these checks on game start and store the results as a {}global variable{} to then check later.":"作为额外检查，您还可以调用函数{}{}shaders_are_supported(){}{}来查看硬件是否甚至支持着色器。通常，您会在游戏开始时执行这些检查，并将结果存储为{}全局变量{}，然后进行检查。","As you can see, they are used in a similar manner to blend modes and surfaces, where you first select (set) the shader, draw what you want using it, then reset the draw target again afterwards. If you wish to render the full screen through a shader, and not just a single sprite or background, you will need to set up a surface to catch the current view, and then pass that through to the shader (see {}Surfaces{}&nbsp;for more information).":"正如您所看到的，它们以类似的方式用于混合模式和表面，其中您首先选择(设置)着色器，使用它绘制您想要的，然后之后再次重置绘制目标。如果您希望通过着色器而不是单个精灵或背景来渲染整个屏幕，则需要设置一个表面来捕捉当前视图，然后将其传递到着色器(有关详细信息，请参阅{}Surfaces{})。","Finally, {}GameMaker{} permits you to define your own {}Vertex Formats{} from which you can create your own custom primitives. This can greatly speed up shader operations or can be used to extend their capabilities and create surprising effects. You can find information on this in the following sections:":"最后，{}GameMaker{}允许您定义自己的{}顶点格式{}，从中可以创建自己的自定义基元。这可以大大加快着色器操作，或用于扩展其函数并创建出人意料的效果。您可以在以下章节中找到这方面的信息：","For a complete overview of the available GLSL ES functions and variables that you can use to program the shaders themselves, please refer to the {}OpenGL ES Shading Language (GLSL ES) Reference Pages{}. The following link is also useful as it contains some quick reference cards for the OpenGL ES API (note that only the last two cards shown are applicable to {}GameMaker{}): {}OpenGL ES Reference Cards{}.":"有关可用于对着色器本身编程的可用GLSL ES函数和变量的完整概述，请参阅{}OpenGL ES着色语言(GLSL ES)参考页{}。 以下链接也很有用，因为它包含一些用于OpenGL ES API的快速参考卡(请注意，仅显示的最后两张卡适用于{}GameMaker{})：{}OpenGL ES参考卡{}。","For a complete overview of the language specification of GLSL&nbsp;ES that&nbsp;{}GameMaker{}&nbsp;currently uses, including the&nbsp;functions and variables that you can use to program the shaders themselves, please refer to the {}GLSL&nbsp;ES&nbsp;Specification&nbsp;1.00{}. If you're looking for a quick overview of these functions and variables, the following link is useful as well as it contains some quick reference cards for the OpenGL&nbsp;ES&nbsp;API on the last two cards: {}OpenGL&nbsp;ES&nbsp;Reference&nbsp;Cards{}.":"有关 {}GameMaker{} 当前使用的 GLSL ES 语言规范的完整概述，包括可用于对着色器本身进行编程的函数和变量，请参阅 {}GLSL ES Specification 1.00{}.。如果您正在寻找这些函数和变量的快速概述，以下链接非常有用，因为它包含最后两张卡上的 OpenGL ES API 的一些快速参考卡：{}OpenGL ES 参考卡 {}。","Guide To Using Shaders":"着色器使用指南","If the shader you are using has input values, these are set using the {}uniform{} functions. You would first get the uniform {}handle{} (which is essentially an ID value for the uniform to be set) using the function {}{}shader_get_uniform(){}{}&nbsp;in the {}Create Event{} of the instance using the shader, and then store these handles in variables, something like this:":"如果使用的着色器具有输入值，则使用{}统一{}函数设置这些值。首先使用着色器在实例的{}创建事件{}中使用函数{}{}shader_get_uniform(){}{}获取统一{}句柄{}(本质上是要设置 uniform 的ID值)，然后将这些句柄存储在变量中，如下所示：","If you are new to shaders or want a more complete guide to creating and use them using {}GameMaker{}, then please see the following page of the manual:":"如果您是着色器的新手，或者想要使用{}GameMaker{}创建和使用着色器的更完整指南，请参阅手册的以下页面：","It is important to note that {}GameMaker{} also supports some conditional compile {}Macros{} which can be used within GLSL ES shaders so they can perform alternative code on specific supported platforms. The macros and the platforms they will be generated on are shown in the table below:":"需要注意的是，{}GameMaker{}还支持一些条件编译{}宏{}，这些宏可以在GLSL ES着色器中使用，因此它们可以在特定的支持平台上执行替代代码。下表显示了宏及其生成的平台：","Mac and Ubuntu (Linux)":"Mac和Ubuntu(Linux)","Once you have the uniform handles, they can then be set in the shader code for the {}Draw Event{} like this:":"有了统一的句柄后，可以在{}绘制事件{}的着色器代码中设置它们，如下所示：","One final thing to note is that although shaders are accepted across all platforms, they are still device specific and if the hardware or software of the device cannot use shaders then you will get an error. Therefore you are recommended to check that the shader has been compiled before setting uniforms or using the shader itself, like this:":"最后要注意的一点是，尽管着色器在所有平台上都被接受，但它们仍然是特定于设备的，如果设备的硬件或软件不能使用着色器，则会出现错误。因此，建议您在设置统一或使用着色器本身之前检查着色器是否已编译，如下所示：","Primitives&nbsp;And Vertex Formats":"基本元和顶点格式","Shader Uniforms":"着色器 Uniforms 常量","Shaders are an incredibly powerful tool for manipulating what and how things are {}rendered{} to the screen by the graphics card. Since these tiny programs are actually run on the graphics card itself, this means that they are extremely fast to process, freeing up valuable CPU cycles for more game logic.":"着色器是一个非常强大的工具，用于操纵图形卡向屏幕呈现{}内容和方式{}。由于这些小程序实际上运行在显卡上，这意味着它们处理速度极快，为更多的游戏逻辑释放了宝贵的CPU周期。","The following functions are available for drawing and setting shaders:":"以下函数可用于绘制与设置着色器：","To create a shader you will need to have written both a {}Vertex Shader{} and a {}Fragment Shader{} (also know as a {}Pixel Shader{}) using the {}Shader Editor{}, and even if (for example) you only wish to change the vertex positions for an instance being drawn, or if you only want to change the colour values for the pixels, you will still need {}both{} programs for a complete shader to work.":"要创建着色器，需要使用{}着色器编辑器{}编写{}顶点着色器{}和{}碎片着色器{}(也称为{}像素着色器{})，并且即使(例如)仅希望更改正在绘制的实例的顶点位置，或者如果只想更改像素的颜色值，仍需要{}两个{}程序才能使完整着色器工作。","Using a shader in your projects is very simple, and only requires a couple of lines of code to get the most basic of use from it:":"在项目中使用着色器非常简单，只需几行代码即可从中获得最基本的用途：","We also have a special function which defines a global state for all shaders:":"我们还有一个特殊的函数，它定义了所有着色器的全局状态：","When working with texture samplers in shaders you will need information about the texture being used, in which case you can use the following functions:":"在着色器中使用纹理采样器时，您将需要有关正在使用的纹理的信息，在这种情况下，您可以使用以下函数：","When working with texture samplers in shaders you will need information about the texture being used, in which case you can use the following functions:&nbsp;":"在着色器中使用纹理采样器时，您将需要有关正在使用的纹理的信息，在这种情况下，您可以使用以下函数：","When you compile your {}GameMaker{} project on any one of the listed platforms using a GLSL ES format shader, {}one{} of the above macros will be generated which can then be used checked in the shader code like this:":"当您使用GLSL ES格式着色器在任何一个列出的平台上编译{}GameMaker{}项目时，将生成{}上述宏之一{}，然后可以在着色器代码中使用这些宏，如下所示：","While this manual will {}not{} cover any of the Open GL shader functions and variables, it does contain a list of the ones that are unique to {}GameMaker{}. These constants are not part of the Open GL specification for shaders and are supplied to simplify the integration of shaders within your projects.":"虽然本手册{}不{}涵盖任何 Open GL 着色器函数和变量，但它确实包含{}GameMaker{}独有的函数和变量列表。 这些常量不是用于着色器的Open GL规范的一部分，而是为了简化项目中着色器的集成。","While this manual will {}not{} cover any of the OpenGL shader functions and variables, it does contain a list of the ones that are unique to {}GameMaker{}. These constants are not part of the OpenGL specification for shaders and are supplied to simplify the integration of shaders within your projects.":"虽然本手册{}不会{}介绍任何 OpenGL 着色器函数和变量，但它确实包含了 {}GameMaker{} 所独有的函数和变量的列表。这些常量不是着色器的 OpenGL 规范的一部分，提供这些常量是为了简化项目中着色器的集成。","Windows, XboxOne":"Windows, XboxOne","{}NOTE{}&nbsp;Shaders do {}not{} permit you to change the value of any variables that you pass into them, and so these will be called {}shader constants{} in all the documentation that refers to them.":"{}注意{}着色器不允许{}更改传入变量的任何变量的值，因此在引用这些变量的所有文档中，这些变量称为{}着色器常量{}。","{}NOTE{}: Shaders, like anything related to drawing, can {}only be used in the draw event{}. It is also worth noting that if you are trying to use a colour value in a shader and the object has no texture, the results will turn out black.":"{}注意{}：着色器，像任何与绘制相关的东西一样，只能在绘制事件{}中使用。同样值得注意的是，如果尝试在着色器中使用颜色值，并且对象没有纹理，则结果将变为黑色。","{}Shaders{}":"{}着色器{}","{}{}NOTE{}{}&nbsp;Shaders do {}not{} permit you to change the value of any variables that you pass into them, and so these will be called {}shader constants{} in all the documentation that refers to them.":"{}{}注意{}{} 着色器{}不允许{}您更改传递给它们的任何变量的值，因此在所有引用它们的文档中，这些变量将称为{}着色器常量{}。","{}{}NOTE{}{}&nbsp;Shaders, like anything related to drawing, can {}only be used in the draw event{}. It is also worth noting that if you are trying to use a colour value in a shader and the object has no texture, the results will turn out black.":"{}{}注意{}{} 着色器，就像任何与绘制相关的东西一样，{}只能在绘制事件中使用{}。同样值得注意的是，如果您尝试在着色器中使用颜色值，并且对象没有纹理，结果将变为黑色。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.3.8"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Shaders</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page outlining the different functions and variables associated with Shaders"><meta name="rh-index-keywords" content=""><meta name="search-keywords" content="Shaders,_YY_GLSLES_,_YY_GLSL_,_YY_HLSL11_,_YY_PSSL_"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Asset_Management/Shaders/shader_get_name.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Asset_Management/Scripts/script_execute_ext.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Shaders"><span>Shaders</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Shaders</span></h1><p>Shaders are an incredibly powerful tool for manipulating what and how things are <a class="tooltip" title="When something is rendered in GameMaker Studio 2, it generally means that it has simply been 'drawn to the display buffer' or 'drawn to a surface'.  Rendering can also refer to the process of turning some kind of vector source (like a font) into a bitmap image,.">rendered</a> to the screen by the graphics card. Since these tiny programs are actually run on the graphics card itself, this means that they are extremely fast to process, freeing up valuable CPU cycles for more game logic.</p><p>To create a shader you will need to have written both a <b>Vertex Shader</b> and a <b>Fragment Shader</b> (also know as a <b>Pixel Shader</b>) using the <a href="../../../../The_Asset_Editors/Shaders.htm">Shader Editor</a>, and even if (for example) you only wish to change the vertex positions for an instance being drawn, or if you only want to change the colour values for the pixels, you will still need <b>both</b> programs for a complete shader to work.</p><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;Shaders do <b>not</b> permit you to change the value of any variables that you pass into them, and so these will be called <b>shader constants</b> in all the documentation that refers to them.</p><p>For a complete overview of the language specification of GLSL&nbsp;ES that&nbsp;<span data-keyref="GameMaker Name">GameMaker</span>&nbsp;currently uses, including the&nbsp;functions and variables that you can use to program the shaders themselves, please refer to the <a href="https://registry.khronos.org/OpenGL/specs/es/2.0/GLSL_ES_Specification_1.00.pdf">GLSL&nbsp;ES&nbsp;Specification&nbsp;1.00</a>. If you're looking for a quick overview of these functions and variables, the following link is useful as well as it contains some quick reference cards for the OpenGL&nbsp;ES&nbsp;API on the last two cards: <a href="https://www.khronos.org/opengles/sdk/docs/reference_cards/OpenGL-ES-2_0-Reference-card.pdf">OpenGL&nbsp;ES&nbsp;Reference&nbsp;Cards</a>.</p><p>Using a shader in your projects is very simple, and only requires a couple of lines of code to get the most basic of use from it:</p><p class="code">shader_set(myShader);<br>draw_self();<br>shader_reset();</p><p>As you can see, they are used in a similar manner to blend modes and surfaces, where you first select (set) the shader, draw what you want using it, then reset the draw target again afterwards. If you wish to render the full screen through a shader, and not just a single sprite or background, you will need to set up a surface to catch the current view, and then pass that through to the shader (see <a href="../../Drawing/Surfaces/Surfaces.htm">Surfaces</a>&nbsp;for more information).</p><p class="note"><span data-conref="../../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;Shaders, like anything related to drawing, can <b>only be used in the draw event</b>. It is also worth noting that if you are trying to use a colour value in a shader and the object has no texture, the results will turn out black.</p><p>If the shader you are using has input values, these are set using the <i>uniform</i> functions. You would first get the uniform <i>handle</i> (which is essentially an ID value for the uniform to be set) using the function <a href="shader_get_uniform.htm"><span class="inline">shader_get_uniform()</span></a>&nbsp;in the <b>Create Event</b> of the instance using the shader, and then store these handles in variables, something like this:</p><p class="code">colour_to_find = shader_get_uniform(sShaderDemo5, "f_Colour1");<br>colour_to_set = shader_get_uniform(sShaderDemo5, "f_Colour2");</p><p>Once you have the uniform handles, they can then be set in the shader code for the <b>Draw Event</b> like this:</p><p class="code">shader_set(sShaderDemo5);<br>shader_set_uniform_f(colour_to_find, 1,1,1 );<br>shader_set_uniform_f(colour_to_set, 1,0,0 );<br>draw_sprite(sprite_index,image_index,x+24, y);<br>shader_reset();</p><p>One final thing to note is that although shaders are accepted across all platforms, they are still device specific and if the hardware or software of the device cannot use shaders then you will get an error. Therefore you are recommended to check that the shader has been compiled before setting uniforms or using the shader itself, like this:</p><p class="code">if (shader_is_compiled(myShader))<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;shader_set(myShader);<br>&nbsp;&nbsp;&nbsp;&nbsp;draw_self();<br>&nbsp;&nbsp;&nbsp;&nbsp;shader_reset();<br>}<br>else show_debug_message("Shader failed");</p><p>As an extra check you can also call the function <a href="shaders_are_supported.htm"><span class="inline">shaders_are_supported()</span></a>&nbsp;to see if the hardware even supports shaders. In general you'd do these checks on game start and store the results as a <a href="../../../GML_Overview/Variables/Global_Variables.htm">global variable</a> to then check later.</p><p>It is important to note that <span data-keyref="GameMaker Name">GameMaker</span> also supports some conditional compile <b>Macros</b> which can be used within GLSL ES shaders so they can perform alternative code on specific supported platforms. The macros and the platforms they will be generated on are shown in the table below:</p><p>&nbsp;</p><table><tbody><tr><th>Shader Macro</th><th>Value</th><th>Target Platform</th></tr><tr><td>_YY_GLSLES_</td><td>1</td><td>All target platforms</td></tr><tr><td>_YY_GLSL_</td><td>2</td><td>Mac and Ubuntu (Linux)</td></tr><tr><td>_YY_HLSL11_</td><td>3</td><td>Windows, XboxOne</td></tr><tr><td>_YY_PSSL_</td><td>4</td><td>PS4</td></tr></tbody></table><p>&nbsp;</p><p>When you compile your <span data-keyref="GameMaker Name">GameMaker</span> project on any one of the listed platforms using a GLSL ES format shader, <i>one</i> of the above macros will be generated which can then be used checked in the shader code like this:</p><p class="code">#ifdef _YY_HLSL11_<br>// HLSL shader code here<br>#else<br>// GLSL shader code here<br>#endif</p><p>If you are new to shaders or want a more complete guide to creating and use them using <span data-keyref="GameMaker Name">GameMaker</span>, then please see the following page of the manual:</p><ul class="colour"><li><a href="../../../../Additional_Information/Guide_To_Using_Shaders.htm">Guide To Using Shaders</a></li></ul><p>&nbsp;</p><p>The following functions are available for drawing and setting shaders:</p><ul class="colour"><li><a href="shader_get_name.htm">shader_get_name</a></li><li><a href="shader_get_uniform.htm">shader_get_uniform</a></li><li><a href="shader_get_sampler_index.htm">shader_get_sampler_index</a></li><li><a href="shader_set.htm">shader_set</a></li><li><a href="shader_set_uniform_f.htm">shader_set_uniform_f</a></li><li><a href="shader_set_uniform_f_array.htm">shader_set_uniform_f_array</a></li><li><a href="shader_set_uniform_f_buffer.htm">shader_set_uniform_f_buffer</a></li><li><a href="shader_set_uniform_i.htm">shader_set_uniform_i</a></li><li><a href="shader_set_uniform_i_array.htm">shader_set_uniform_i_array</a></li><li><a href="shader_set_uniform_matrix.htm">shader_set_uniform_matrix</a></li><li><a href="shader_set_uniform_matrix_array.htm">shader_set_uniform_matrix_array</a></li><li><a href="shader_reset.htm">shader_reset</a></li><li><a href="shader_is_compiled.htm">shader_is_compiled</a></li><li><a href="shaders_are_supported.htm">shaders_are_supported</a></li><li><a href="shader_current.htm">shader_current</a></li></ul><p>&nbsp;</p><p>We also have a special function which defines a global state for all shaders:</p><ul><li><a href="shader_enable_corner_id.htm">shader_enable_corner_id</a></li></ul><p>&nbsp;</p><p>When working with texture samplers in shaders you will need information about the texture being used, in which case you can use the following functions:&nbsp;</p><ul class="colour"><li><a href="../Sprites/Sprite_Information/sprite_get_texture.htm">sprite_get_texture</a></li><li><a href="../Sprites/Sprite_Information/sprite_get_uvs.htm">sprite_get_uvs</a></li><li><a href="../Fonts/font_get_texture.htm">font_get_texture</a></li><li><a href="../Fonts/font_get_uvs.htm">font_get_uvs</a></li><li><a href="../../Drawing/Textures/texture_get_width.htm">​texture_get_width</a></li><li><a href="../../Drawing/Textures/texture_get_height.htm">texture_get_height</a></li><li><a href="../../Drawing/Textures/texture_get_texel_width.htm">texture_get_texel_width</a></li><li><a href="../../Drawing/Textures/texture_get_texel_height.htm">texture_get_texel_height</a></li><li><a href="../../Drawing/Textures/texture_set_stage.htm">texture_set_stage</a></li><li><a href="../../Drawing/GPU_Control/gpu_set_texfilter.htm">gpu_set_texfilter</a></li><li><a href="../../Drawing/GPU_Control/gpu_set_texfilter_ext.htm">gpu_set_texfilter_ext</a></li><li><a href="../../Drawing/GPU_Control/gpu_set_texrepeat.htm">gpu_set_texrepeat</a></li><li><a href="../../Drawing/GPU_Control/gpu_set_texrepeat_ext.htm">gpu_set_texrepeat_ext</a></li></ul><p>&nbsp;</p><p>While this manual will <b>not</b> cover any of the OpenGL shader functions and variables, it does contain a list of the ones that are unique to <span data-keyref="GameMaker Name">GameMaker</span>. These constants are not part of the OpenGL specification for shaders and are supplied to simplify the integration of shaders within your projects.</p><ul class="colour"><li><a href="Shader_Constants.htm">Shader Uniforms</a></li></ul><p>&nbsp;</p><p>Finally, <span data-keyref="GameMaker Name">GameMaker</span> permits you to define your own <b>Vertex Formats</b> from which you can create your own custom primitives. This can greatly speed up shader operations or can be used to extend their capabilities and create surprising effects. You can find information on this in the following sections:</p><ul class="colour"><li><a href="../../Drawing/Primitives/Primitives_And_Vertex_Formats.htm">Primitives&nbsp;And Vertex Formats</a></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../Asset_Management.htm">Asset Management</a></div><div style="float:right">Next: <a href="../Sequences/Sequences.htm">Sequences</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>