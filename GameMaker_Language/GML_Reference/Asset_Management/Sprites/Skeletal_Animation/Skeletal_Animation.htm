<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../../assets/import/main.css"><script>let str;removeHtml=function(t){return t=(t=(t=(t=t.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(t){return t.match(/(<([^>]+)>)/gi)},setTranslator=function(t,e,n){let i;i=n?t.attr(n):t.html();let o=e[removeHtml(i)];if(null!=o&&o.length){e=retHtml(i);let a=0;e&&e.forEach(function(t,e){var n=o.replace("{"+a+"}",t);o=n===o?o.replace("{}",t):n,a++}),n?t.attr(n,o):t.html(o)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var t=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(t):($(".topic-header").append(t),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(t){return t.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Skeletal Animation Sprites":"骨骼动画精灵","The Fragment Shader:":"片段着色器：","The Vertex Shader (this is the same as the default passthrough vertex shader)":"顶点着色器(与默认的穿过顶点着色器相同)","The functions found in this section are {}only{} for use with sprites that have been imported from a skeletal animation file (specifically, the JSON files that {}{}Spine{}{} exports) and can be used to get information about an animation asset in your game, as well as for setting certain properties within an animation. These functions can to be used along with the regular sprite functions and variables, permitting you to (for example) mix two skeleton animations using these special functions while setting the image scale using the normal sprite instance variables (for more information on the sprite instance variables see {}here{}).":"本节中的函数{}仅{}用于从骨骼动画文件(特别是{}{}spine{}{}导出的JSON文件)导入的精灵，并且可用于获取有关游戏中动画资源的信息，以及用于设置动画中的某些属性。这些函数可以与常规Sprite函数和变量一起使用，允许您(例如)使用这些特殊函数混合两个骨骼动画，同时使用普通Sprite实例变量设置图像比例(有关Sprite实例变量的详细信息，请参见此{}处的{})。",'This feature allows the dark areas of Spine sprite slots to be tinted differently to the light areas (this is a Spine IDE feature, see the {}Tint black{} section {}here{} more details). Currently, in order to make use of this feature in {}GameMaker{}, you are required to use a custom {}shader{}&nbsp;when drawing a Spine sprite that uses it. This shader contains a global uniform variable called "{}gm_SpineTintBlackColour{}" which the runner fills with the current tint-black colour, retrieved from the Spine data automatically. The shader required is shown below:':'此函数允许 Spine 精灵插槽的深色区域以不同于浅色区域的方式着色 (这是 Spine IDE 的一项函数，有关更多详细信息，请参阅 {}Tint Black{} 部分 {} 此处 {})。目前，为了在 {}GameMaker{} 中使用此功能，您需要在绘制使用它的 Spine 精灵时使用自定义{}着色器{}。该着色器包含一个名为 "{}GM_spinetintblackcolour{}" 的全局统一变量，跑步者用当前的淡黑色填充该变量，该颜色是从脊柱数据中自动检索的。所需的着色器如下所示：',"Tint Black Support":"Tint Black 支持","You can find out more about the functions for these kinds of sprites from the sections below:":"您可以从以下部分找到有关这些类型的精灵的函数的更多信息：","You would use this by first calling the shader, then drawing the sprite, then resetting the shader, something like this:":"您可以通过首先调用着色器，然后绘制精灵，然后重置着色器来使用它，如下所示：","{}Animation{}":"{}动画{}","{}Attachments{}":"{}附件{}","{}Bones{}":"{}骨骼{}","{}Drawing and Miscellaneous{}":"{}绘制和其他{}","{}NOTE{}&nbsp;For further information on importing skeletal animation sprites made with Spine, please see the section {}Importing Non-Bitmap Sprites{}.":"{}注意{}有关导入使用Spine制作的骨骼动画精灵的更多信息，请参见{}导入非位图精灵{}一节。","{}Skins{}":"{}皮肤{}","{}Slots{}":"{}插槽{}","{}{}IMPORTANT{}{}&nbsp;Most of the skeletal sprite functions {}do not{} take a sprite or instance reference, as they assume the skeletal sprite is assigned to the current instance (via the IDE or by setting the&nbsp;{}{}sprite_index{}{}). This means that running such functions under a different context (e.g. a global script, or in a constructor) will result in an error, as the current {}{}self{}{}&nbsp;will not have a skeletal sprite in such cases.":"{}{}重要{}{}大多数骨架精灵函数{}不{}采用精灵或实例引用，因为它们假定骨架精灵已分配给当前实例(通过 IDE 或通过设置{}{}sprite_index{}{})。这意味着在不同的上下文(例如全局脚本或构造函数)下运行此类函数将导致错误，因为在这种情况下当前的{}{}self{}{}将不具有骨架精灵。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(t){json_global=t}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../../..",gTopicId="8.2.2.3.3.4"</script><script type="text/javascript" src="../../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Skeletal Animation</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../../assets/css/default.css" type="text/css"><script src="../../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page outlining the different Skeletal Animation functions"><meta name="rh-index-keywords" content=""><meta name="search-keywords" content="Skeletal Animation,gm_SpineTintBlackColour,tint black,Spine"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Asset_Management/Sprites/Skeletal_Animation/Animation/Animation.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/bbox_top.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Skeletal Animation"><span>Skeletal Animation</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>Skeletal Animation Sprites</h1><p>The functions found in this section are <i>only</i> for use with sprites that have been imported from a skeletal animation file (specifically, the JSON files that <a href="http://es.esotericsoftware.com/"><b>Spine</b></a> exports) and can be used to get information about an animation asset in your game, as well as for setting certain properties within an animation. These functions can to be used along with the regular sprite functions and variables, permitting you to (for example) mix two skeleton animations using these special functions while setting the image scale using the normal sprite instance variables (for more information on the sprite instance variables see <a href="../Sprite_Instance_Variables/Sprite_Instance_Variables.htm">here</a>).</p><p class="note"><span data-conref="../../../../../assets/snippets/Tag_important.hts"><span class="important">IMPORTANT</span></span>&nbsp;Most of the skeletal sprite functions <strong>do not</strong> take a sprite or instance reference, as they assume the skeletal sprite is assigned to the current instance (via the IDE or by setting the&nbsp;<span class="inline2"><a href="../Sprite_Instance_Variables/sprite_index.htm">sprite_index</a></span>). This means that running such functions under a different context (e.g. a global script, or in a constructor) will result in an error, as the current <span class="inline2"><a href="../../../../GML_Overview/Instance_Keywords.htm">self</a></span>&nbsp;will not have a skeletal sprite in such cases.</p><p class="note"><span class="note">NOTE</span>&nbsp;For further information on importing skeletal animation sprites made with Spine, please see the section <a href="../../../../../Settings/Texture_Information/Non-Bitmap_Sprites.htm">Importing Non-Bitmap Sprites</a>.</p><p>You can find out more about the functions for these kinds of sprites from the sections below:</p><ul class="colour"><li><a href="Animation/Animation.htm"><label for="a">Animation</label></a></li><li><a href="Skins/Skins.htm"><label for="b">Skins</label></a></li><li><a href="Attachments/Attachments.htm"><label for="c">Attachments</label></a></li><li><a href="Bones/Bones.htm"><label for="d">Bones</label></a></li><li><a href="Slots/Slots.htm"><label for="f">Slots</label></a></li><li><a href="Drawing_And_Miscellaneous/Drawing_And_Miscellaneous.htm"><label for="e">Drawing and Miscellaneous</label></a></li></ul><p>&nbsp;</p><h2>Tint Black Support</h2><p>This feature allows the dark areas of Spine sprite slots to be tinted differently to the light areas (this is a Spine IDE feature, see the <b>Tint black</b> section <a href="http://esotericsoftware.com/spine-attachments" target="_blank">here</a> more details). Currently, in order to make use of this feature in <span data-keyref="GameMaker Name">GameMaker</span>, you are required to use a custom <a href="../../../../../The_Asset_Editors/Shaders.htm">shader</a>&nbsp;when drawing a Spine sprite that uses it. This shader contains a global uniform variable called "<span class="inline">gm_SpineTintBlackColour</span>" which the runner fills with the current tint-black colour, retrieved from the Spine data automatically. The shader required is shown below:</p><p>The Vertex Shader (this is the same as the default passthrough vertex shader)</p><p class="code">attribute vec3 in_Position; // (x,y,z)<br>attribute vec4 in_Colour; // (r,g,b,a)<br>attribute vec2 in_TextureCoord; // (u,v)<br><br>varying vec2 v_vTexcoord;<br>varying vec4 v_vColour;<br><br>void main()<br>{<br>&nbsp; &nbsp; vec4 object_space_pos = vec4( in_Position.x, in_Position.y, in_Position.z, 1.0);<br>&nbsp; &nbsp; gl_Position = gm_Matrices[MATRIX_WORLD_VIEW_PROJECTION] * object_space_pos;<br>&nbsp; &nbsp; v_vColour = in_Colour;<br>&nbsp; &nbsp; v_vTexcoord = in_TextureCoord;<br>}</p><p>The Fragment Shader:</p><p class="code">varying vec2 v_vTexcoord;<br>varying vec4 v_vColour;<br><br>uniform vec4 gm_SpineTintBlackColour; // This is the uniform containing the tint-black colour<br><br>void main()<br>{<br>&nbsp; &nbsp; vec4 tb = gm_SpineTintBlackColour;<br>&nbsp; &nbsp; vec4 texcol = texture2D( gm_BaseTexture, v_vTexcoord );<br>&nbsp; &nbsp; vec4 outcol;<br>&nbsp; &nbsp; outcol.rgb = v_vColour.rgb * texcol.rgb;<br>&nbsp; &nbsp; outcol.rgb += tb.rgb * ((tb.a * (texcol.a - 1.0)) + (1.0 - texcol.rgb)); // This line performs the tint-&nbsp; &nbsp; black blending logic<br>&nbsp; &nbsp; outcol.a = v_vColour.a * texcol.a;<br>&nbsp; &nbsp; gl_FragColor = outcol;<br>}</p><p>You would use this by first calling the shader, then drawing the sprite, then resetting the shader, something like this:</p><p class="code">shader_set(shd_spine_tint_black);<br>draw_self();<br>shader_reset();</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../Sprites.htm">Sprites</a></div><div style="float:right">Next: <a href="../Sprite_Information/Sprite_Information.htm"><label for="three">Sprite Information</label></a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>