<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(t){return t=(t=(t=(t=t.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(t){return t.match(/(<([^>]+)>)/gi)},setTranslator=function(t,n,e){let o;o=e?t.attr(e):t.html();let i=n[removeHtml(o)];if(null!=i&&i.length){n=retHtml(o);let a=0;n&&n.forEach(function(t,n){var e=i.replace("{"+a+"}",t);i=e===i?i.replace("{}",t):e,a++}),e?t.attr(e,i):t.html(i)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var t=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(t):($(".topic-header").append(t),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(t){return t.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"'points' Array":"'points' 数组",'If the channel is using catmull-rom ("smooth") interpolation this holds how many points have been generated for each segment of the curve (note that these extra points are internal to the function and only used for the runtime calculations). If the channel is using linear interpolation, this value will still exist but can be ignored as it has no bearing on how the curve is interpolated.':"如果通道使用catmull- rom (“平滑”) 插值，则可以保存为曲线的每段生成了多少个点 (请注意，这些额外的点在函数内部，仅用于运行时计算)。如果通道使用线性插值，则该值仍将存在，但可以忽略，因为它与曲线的插值方式无关。","Note that passing an index value will require less processing than passing in a channel name. If the function fails (ie: no channel exists with the given name or index) then you will get an error.":"请注意，传递索引值将比传递通道名称需要更少的处理。如果函数失败 (即: 没有给定名称或索引的通道存在)，则会出现错误。","One point struct has the following variables:":"单点结构具有以下变量：","The ID or struct pointer of the animation curve to target":"动画曲线到目标的ID或结构指针",'The above code retrieves the channel struct for channel 0 in the curve asset "ac_ButtonTween", then loops through the points on the channel curve and adds one to their value.':"上面的代码在曲线资源 “ac_ButtonTween” 中检索通道0的通道结构，然后循环通过通道曲线上的点并将其值相加。","The channel name (a string) or the channel index (an integer).":"通道名称 (字符串) 或通道索引 (整数)。","The first required argument&nbsp;is the&nbsp;Animation Curve as it was defined in the Asset Browser, or the struct pointer as returned by the function {}{}animcurve_create(){}{}.":"第一个必需的参数是在资源浏览器中定义的动画曲线，或者是函数{}{}animcurve_create(){}{}返回的结构指针。","The position in time (normalised from 0 to 1) of the point.":"点的时间位置 (从0到1归一化)。","The second required argument is a string that refers to the channel as it was defined in the Animation Curve asset, or you can supply an index value, which is from 0 to {}n{}, where {}n{} is the last channel in the curve asset (eg: if an animation curve has 4 channels, they will be indexed from 0 to 3).":"第二个必需参数是一个字符串，它引用了动画曲线资源中定义的通道，或者您可以提供一个索引值，该值从0到{}n{}, 其中{}n{}是曲线资源中的最后一个通道 (例如: 如果一个动画曲线有4个通道，它们将从0到3索引)。","The value of the point.":"点的值。","The {}points{} member of the returned struct contains an array, which contains all of the channel's points as structs.":"返回的结构的{}points{}成员包含一个数组，该数组包含通道的所有点作为结构。","The {}points{} member only allows you to get and set the array variable. You cannot run&nbsp;{} {}&nbsp;on the {}points{} array to modify it.":"{}points{}成员仅允许您获取和设置数组变量。您不能在{4}points{5}数组上运行{}{}来修改它。","The {}points{} member only allows you to get and set the array variable. You cannot run&nbsp;{}&nbsp;{}&nbsp;on the {}points{} array to modify it.":"{}points{}成员仅允许您获取和设置数组变量。您不能在{}points{}数组上运行{}{}来修改它。","The {}points{} member only allows you to get and set the array variable. You cannot run&nbsp;{}Array Functions{}&nbsp;on the {}points{} array to modify it.":"{}points{} 成员仅允许您获取和设置数组变量。您不能对 {4}points{5} 数组运行{}数组函数{}来修改它。","This function returns the {}struct{} containing the channel data for the channel specified in an animation curve asset or struct (as returned by&nbsp;{}{}animcurve_get{}{}).":"此函数返回{}结构{}，其中包含动画曲线资源或结构中指定的通道的通道数据(由 {}{}animcurve_get{}{} 返回)。","This function will return the {}struct{} containing the channel data for the channel specified in an animation curve asset. You supply the animation curve ID or struct as well as the channel name or index, and the function will return a struct with the following format:":"此函数将返回{}struct{}，其中包含动画曲线资源中指定的频道数据。您提供动画曲线ID或struct以及通道名称或索引，该函数将返回具有以下格式的struct:","This is an array, where each item in the array is a point struct.":"这是一个数组，其中数组中的每个项目都是一个点结构。","This is the name of the channel.":"这是频道的名称。",'This will be one of the constants {}{}animcurvetype_linear{}{} for linear interpolation between points, {}{}animcurvetype_catmullrom{}{} for "smooth" interpolation between the points using catmull-rom interpolation, or {}animcurvetype_bezier{} for Bezier interpolation.':"这将是用于点之间的线性插值的常数{}{}animcurvetype_linear{}{}，{}{}animcurvetype_catmullrom{}{}用于使用catmull- rom插值的点之间的 “平滑” 插值，或{}animcurvetype_bezier{}用于Bezier插值。","To modify the {}points{} array, store it in a variable, which will create a copy. Then modify that copy with the array functions, and apply that copy back to the {}points{} member in the struct.":"要修改{}points{}数组，请将其存储在变量中，该变量将创建一个副本。然后使用数组函数修改该副本，并将该副本应用回结构中的{}points{}成员。","You supply the animation curve ID or struct as well as the channel name or index, and the function will return a struct with the following format:":"您提供动画曲线ID或结构以及通道名称或索引，该函数将返回以下格式的结构：","{}{}Array{}{}&nbsp;pointer":"{}{}Array{}{}指针"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(t){json_global=t}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.3.2.0_3"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>animcurve_get_channel</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page explaining the function animcurve_get_channel"><meta name="rh-index-keywords" content="animcurve_get_channel"><meta name="search-keywords" content="animcurve_get_channel,animcurvetype_linear,animcurvetype_catmullrom"><meta name="is_pure" content="true"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Asset_Management/Animation_Curves/animcurve_channel_evaluate.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Asset_Management/Animation_Curves/animcurve_get_channel_index.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="animcurve_get_channel"><span>animcurve_get_channel</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>animcurve_get_channel</h1><p>This function returns the <a href="../../../GML_Overview/Structs.htm">struct</a> containing the channel data for the channel specified in an animation curve asset or struct (as returned by&nbsp;<span class="inline3_func"><a href="animcurve_get.htm">animcurve_get</a></span>).</p><p>You supply the animation curve ID or struct as well as the channel name or index, and the function will return a struct with the following format:</p><table><colgroup><col><col style="width:183px"><col style="width:883px"></colgroup><tbody><tr><th>Variable Name</th><th>Data Type</th><th>Description</th></tr><tr><td><span class="inline">name</span></td><td style=""><span data-keyref="Type_String"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">String</a></span></td><td style="">This is the name of the channel.</td></tr><tr><td><span class="inline">type</span></td><td style=""><span data-keyref="Type_Constant_AnimCurve_Interp_Type"><a target="_blank" href="animcurve_channel_new.htm">Animation Curve Interpolation Type Constant</a></span></td><td style="">This will be one of the constants <span class="inline"><b>animcurvetype_linear</b></span> for linear interpolation between points, <span class="inline"><b>animcurvetype_catmullrom</b></span> for "smooth" interpolation between the points using catmull-rom interpolation, or <span class="inline">animcurvetype_bezier</span> for Bezier interpolation.</td></tr><tr><td><span class="inline">iterations</span></td><td style=""><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td style="">If the channel is using catmull-rom ("smooth") interpolation this holds how many points have been generated for each segment of the curve (note that these extra points are internal to the function and only used for the runtime calculations). If the channel is using linear interpolation, this value will still exist but can be ignored as it has no bearing on how the curve is interpolated.</td></tr><tr><td><span class="inline">points</span></td><td style=""><span data-keyref="Type_Array"><a target="_blank" href="../../../GML_Overview/Arrays.htm">Array</a></span>&nbsp;pointer</td><td style="">This is an array, where each item in the array is a point struct.</td></tr></tbody></table><p>The first required argument&nbsp;is the&nbsp;Animation Curve as it was defined in the Asset Browser, or the struct pointer as returned by the function <a href="animcurve_create.htm"><span class="inline">animcurve_create()</span></a>.</p><p>The second required argument is a string that refers to the channel as it was defined in the Animation Curve asset, or you can supply an index value, which is from 0 to <i>n</i>, where <i>n</i> is the last channel in the curve asset (eg: if an animation curve has 4 channels, they will be indexed from 0 to 3).</p><p>Note that passing an index value will require less processing than passing in a channel name. If the function fails (ie: no channel exists with the given name or index) then you will get an error.</p><h3>'points' Array</h3><p>The <span class="inline2">points</span> member of the returned struct contains an array, which contains all of the channel's points as structs.</p><p>One point struct has the following variables:</p><table><tbody><tr><th>Variable Name</th><th>Data Type</th><th>Description</th></tr><tr><td><span class="inline">posx</span></td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The position in time (normalised from 0 to 1) of the point.</td></tr><tr><td><span class="inline">value</span></td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The value of the point.</td></tr></tbody></table><p>The <span class="inline2">points</span> member only allows you to get and set the array variable. You cannot run&nbsp;<a href="../../Variable_Functions/Variable_Functions.htm#h"></a> &nbsp;on the <span class="inline2">points</span> array to modify it.</p><p>To modify the <span class="inline2">points</span> array, store it in a variable, which will create a copy. Then modify that copy with the array functions, and apply that copy back to the <span class="inline2">points</span> member in the struct.</p><p class="code">var _points_copy = channel_struct.points;<br><br>array_delete(_points_copy, 0, 1);<br><br>channel_struct.points = _points_copy;</p><p>&nbsp;</p><p>&nbsp;</p><h4>Syntax:</h4><p class="code">animcurve_get_channel(curve_struct_or_id, channel_name_or_index);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>curve_struct_or_id</td><td><span data-keyref="Type_Struct_AnimCurve"><a target="_blank" href="animcurve_get.htm">Animation Curve Struct</a></span>&nbsp;or&nbsp;<span data-keyref="Type_Asset_Animation_Curve"><a target="_blank" href="../../../../The_Asset_Editors/Animation_Curves.htm">Animation Curve Asset</a></span></td><td>The ID or struct pointer of the animation curve to target</td></tr><tr><td>channel_name_or_index</td><td><span data-keyref="Type_String"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">String</a></span>&nbsp;or&nbsp;<span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The channel name (a string) or the channel index (an integer).</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Struct_AnimCurve_Channel"><a target="_blank" href="animcurve_get_channel.htm">Animation Curve Channel Struct</a></span></p><p>&nbsp;</p><h4>Example:</h4><p class="code">var _channeldata = animcurve_get_channel(ac_ButtonTween, 0);<br>var _points = _channeldata.points;<br>for (var i = 0; i &lt; array_length(_points); ++i;)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;_points[i].value += 1;<br>}</p><p>The above code retrieves the channel struct for channel 0 in the curve asset "ac_ButtonTween", then loops through the points on the channel curve and adds one to their value.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Animation_Curves.htm">Animation&nbsp;Curves</a></div><div style="float:right">Next:&nbsp;<a href="animcurve_channel_evaluate.htm">animcurve_channel_evaluate</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>