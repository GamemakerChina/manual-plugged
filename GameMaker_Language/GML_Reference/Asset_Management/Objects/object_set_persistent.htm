<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,n){let o;o=n?e.attr(n):e.html();let s=t[removeHtml(o)];if(null!=s&&s.length){t=retHtml(o);let a=0;t&&t.forEach(function(e,t){var n=s.replace("{"+a+"}",e);s=n===s?s.replace("{}",e):n,a++}),n?e.attr(n,s):e.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Please note that this is not an instance function! You can set the persistent flag of individual instances using the {}{}persistent{}{}&nbsp;variable and so have ten instances all flagged as persistent even though the object in question has the flag set to false in the IDE, and even if you change the persistent flag of the object to true using this function, all instances that currently in the room will remain as they were, and only instances created after calling the function will start with persistent flagged as true.":"请注意这不是实例函数！您可以使用{}{}持久{}{}变量设置单个实例的持久标记，因此即使相关对象在 IDE 中将标记设置为 false，仍有 10 个实例全部标记为持久化，即使使用此函数将对象的持久标记更改为 true，房间中当前的所有实例将保持原样，只有调用函数后创建的实例才会以永久标记为 true 开始。",'The above code checks to see in which room the instance is currently in and if it is in the specified "rm_final" then it sets the persistence of the object "obj_Player" to false and then creates the instance.':'上面的代码检查实例当前位于哪个房间，如果它位于指定的"rm_final"中，则它将对象"obj_Player"的持久性设置为false，然后创建实例。',"The index of the object to change.":"要更改的对象的索引。",'When you create an instance with persistence enabled in a room, it will be assigned a layer or a depth (depending on which function you used to create the instance of the object). When the room is changed, and if the following room does {}not{} have a layer with the same name or depth as the one assigned, then a new layer will be created for the instance that is persisting across the rooms. If you gave a named layer when the instance was created, then the new layer will also be named the same as original layer, while if you assigned a depth to the instance then the new layer will be named "{}_layer_XXX{}", where "XXX" is a hex value used to give the layer a unique name. These layers will be removed from the room on Room End. Another thing to note about layers and persistent instances is that if you have assigned the instance a named layer on creation, and there is another layer in the following rooms with the same name, then the persisted instance will be assigned to the layer with the same name {}regardless of the depth of the layer{}. Finally, if a persisted instance moves to a room with a layer at the same depth as the instance was created on, it will {}not{} be assigned to this layer, but instead a new layer will be created at the same depth (following the naming convention explained previously).':'在房间中创建启用持久性的实例时，将为其指定一个图层或深度(取决于用于创建对象实例的函数)。更改房间时，如果下列房间{}没有{}与所分配的图层具有相同名称或深度的图层，则将为贯穿这些房间的实例创建新的图层。如果在创建实例时指定了命名层，则新层的名称也与原始层相同，而如果为实例指定了深度，则新层将命名为"{}_layer_XXX{}"，其中"XXX"是用于给层指定唯一名称的十六进制值。这些层将从房间末端的房间移除。关于层和持久实例，需要注意的是，如果您在创建时为实例分配了命名层，并且以下房间中有另一个层具有相同名称，则不管层{}的深度如何，持久实例都将被分配给具有相同名称的层{}。 最后，如果持久实例移动到层深度与实例创建深度相同的房间，则{}不会{}将其分配给此层，而是在相同深度创建新层(遵循前面说明的命名约定)。',"Whether the object should be flagged as persistent ({}true{}) or not ({}false{}).":"对象是否应标记为持久({}true{})或不标记为持久({}false{})。",'With this function you can set the persistence of a specific object. A persistent object is "carried over" from room to room and maintains its properties at all times (for more information on persistence see the section on the&nbsp;{}Object Editor{}). Setting the persistence of the object means that all instances of this object that are created {}after the persistence has been changed{} will be created persistent, while instances that are already in the room may not be affected.':'使用此函数，可以设置特定对象的持久性。永久对象从房间"携带"到另一个房间，并始终保持其属性(有关持久性的更多信息，请参阅{}对象编辑器{}部分)。 设置对象的持久性意味着该对象的所有实例(在持久性被更改{}后创建{})将持久创建，而已经在房间中的实例可能不会受到影响。'},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.3.12.1_13"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>object_set_persistent</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page outlining the function object_set_persistent"><meta name="rh-index-keywords" content="object_set_persistent"><meta name="search-keywords" content="object_set_persistent"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Asset_Management/Objects/object_set_solid.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Asset_Management/Objects/object_set_mask.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="object_set_persistent"><span>object_set_persistent</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>object_set_persistent</h1><p>With this function you can set the persistence of a specific object. A persistent object is "carried over" from room to room and maintains its properties at all times (for more information on persistence see the section on the&nbsp;<a href="../../../../The_Asset_Editors/Objects.htm">Object Editor</a>). Setting the persistence of the object means that all instances of this object that are created <i>after the persistence has been changed</i> will be created persistent, while instances that are already in the room may not be affected.</p><p>When you create an instance with persistence enabled in a room, it will be assigned a layer or a depth (depending on which function you used to create the instance of the object). When the room is changed, and if the following room does <i>not</i> have a layer with the same name or depth as the one assigned, then a new layer will be created for the instance that is persisting across the rooms. If you gave a named layer when the instance was created, then the new layer will also be named the same as original layer, while if you assigned a depth to the instance then the new layer will be named "<span class="inline">_layer_XXX</span>", where "XXX" is a hex value used to give the layer a unique name. These layers will be removed from the room on Room End. Another thing to note about layers and persistent instances is that if you have assigned the instance a named layer on creation, and there is another layer in the following rooms with the same name, then the persisted instance will be assigned to the layer with the same name <i>regardless of the depth of the layer</i>. Finally, if a persisted instance moves to a room with a layer at the same depth as the instance was created on, it will <i>not</i> be assigned to this layer, but instead a new layer will be created at the same depth (following the naming convention explained previously).</p><p>Please note that this is not an instance function! You can set the persistent flag of individual instances using the <a href="../Instances/Instance_Variables/persistent.htm"><span class="inline">persistent</span></a>&nbsp;variable and so have ten instances all flagged as persistent even though the object in question has the flag set to false in the IDE, and even if you change the persistent flag of the object to true using this function, all instances that currently in the room will remain as they were, and only instances created after calling the function will start with persistent flagged as true.</p><p>&nbsp;</p><h4>Syntax:</h4><p class="code">object_set_persistent(index, pers);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>index</td><td><span data-keyref="Type_Asset_Object"><a target="_blank" href="../../../../The_Asset_Editors/Objects.htm">Object Asset</a></span></td><td>The index of the object to change.</td></tr><tr><td>pers</td><td><span data-keyref="Type_Bool"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Boolean</a></span></td><td>Whether the object should be flagged as persistent (<span class="inline">true</span>) or not (<span class="inline">false</span>).</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Void">N/A</span></p><p>&nbsp;</p><h4>Example:</h4><p class="code">if (room == rm_final)<br>{<br>&nbsp; &nbsp; object_set_persistent(obj_Player, false);<br>}<br>instance_create_layer(32, 32, "Instances", obj_Player);</p><p>The above code checks to see in which room the instance is currently in and if it is in the specified "rm_final" then it sets the persistence of the object "obj_Player" to false and then creates the instance.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Objects.htm">Objects</a></div><div style="float:right">Next: <a href="object_set_solid.htm">object_set_solid</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>