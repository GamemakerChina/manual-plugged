<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(t){return t=(t=(t=(t=t.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(t){return t.match(/(<([^>]+)>)/gi)},setTranslator=function(t,n,a){let e;e=a?t.attr(a):t.html();let l=n[removeHtml(e)];if(null!=l&&l.length){n=retHtml(e);let o=0;n&&n.forEach(function(t,n){var a=l.replace("{"+o+"}",t);l=a===l?l.replace("{}",t):a,o++}),a?t.attr(a,l):t.html(l)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){$(".header").length&&$(".header").append(`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`)},removeExtensionFromHash=function(t){return t.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")},$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.5.2"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Motion Planning</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference section for Motion Planning functions and variables"><meta name="rh-index-keywords" content=""><meta name="search-keywords" content="Motion Planning,mp,mp funtions"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Movement_And_Collisions/Motion_Planning/mp_linear_step.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Movement_And_Collisions/Movement/move_and_collide.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Motion Planning"><span>Motion Planning</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Motion Planning</span></h1><p>In many games you want opponents, NPC's, enemies, etc. to interact with the player and show certain intelligence when moving around,&nbsp;i.e.&nbsp;you want them to avoid obstacles, plan routes and generally not bump into everything in their path! To aid in this <span data-keyref="GameMaker Name">GameMaker</span> has a series of functions that deal with motion planning. Note that while these are designed for things like game enemies, they can be used for all sorts of things like creating a smooth way to introduce text, or to create transitions, etc. However, whatever you choose to use from the list below in your game, it should be noted that in many situations a single function set will not give you a perfect solution and that you will have to "mix and match" the functions, using one or the other depending on the situation within your game.</p><p>Motion planning in <span data-keyref="GameMaker Name">GameMaker</span> is dealt with by the <span class="inline2">mp_*</span>&nbsp;functions, which themselves are split into the following three groups:</p><h2><label for="one">Linear Functions</label></h2><p>This kind of function tries to compute a collision-free path for the instance. Once this path has been computed you can assign it to the instance to move towards the goal. The computation of the path will take some time but after that the execution of the path will be fast. Of course this is only valid if the situation has not changed in the meantime. For example, if obstacles change you possibly will need to recompute the path. Again notice that these functions might fail and that no path may be found for the instance.</p><ul class="colour"><li><a href="mp_linear_step.htm">mp_linear_step</a></li><li><a href="mp_linear_step_object.htm">mp_linear_step_object</a></li><li><a href="mp_linear_path.htm">mp_linear_path</a></li><li><a href="mp_linear_path_object.htm">mp_linear_path_object</a></li></ul><p>&nbsp;</p><h2><label for="three">Potential Functions</label></h2><p>These are the basic avoidance functions and good for simple AI. They work by making an instance take a step towards a particular goal position while trying to go straight if possible but taking a different direction if required. These functions should be used in the&nbsp;<b>Step Event</b>&nbsp;of an instance.</p><ul class="colour"><li><a href="mp_potential_settings.htm">mp_potential_settings</a></li><li><a href="mp_potential_step.htm">mp_potential_step</a></li><li><a href="mp_potential_step_object.htm">mp_potential_step_object</a></li><li><a href="mp_potential_path.htm">mp_potential_path</a></li><li><a href="mp_potential_path_object.htm">mp_potential_path_object</a></li></ul><p>&nbsp;</p><h2><label for="two">Grid Functions</label></h2><p>The final type of function use a much more complex mechanism based on a grid-based approach (sometimes called an A* algorithm). It will be much more successful in finding paths (although it still might fail) and will find the shortest paths possible but it requires more work on your side to set it up.</p><p>The global idea is as follows - First of all we create a grid that covers the room (or the relevant part of it). You can choose to use a fine grid, which will be slower, or a coarse grid, but both of them should be based on the resolution of the room so that the path-finding is as accurate as possible. For example, if you have a room that is 400x200 pixels, you can have a grid resolution of 40, or 20, or 10... it all depends on how accurate you need the path to be and how much processing you want <span data-keyref="GameMaker Name">GameMaker</span>&nbsp;to do to generate it.</p><p>Next, for all relevant objects that we want to avoid we need to determine the grid cells they overlap (based either on their bounding boxes or their precise sprite) and mark these cells as being forbidden. So a cell will be marked totally forbidden, even if an obstacle is only partially overlapping.</p><p>Finally we specify a start position and a goal position, both of which&nbsp;<i>must</i>&nbsp;lie in free cells, and the function then computes the shortest path possible between these two positions. The path will run between the centers of all free cells, so if the cells are large enough so that the instance placed at its center will lie completely inside it this will be successful. This path is then assigned to the instance to follow using the&nbsp;<a href="../../Asset_Management/Paths/Paths.htm"><span class="inline">path_*</span></a>&nbsp;functions. You should realise how important cell size is for this as the cells must be large enough so that the moving object placed with its origin on the center of a cell will lie&nbsp;<i>completely</i>&nbsp;inside the cell. (Be careful about the position of the origin of the object. Also realize that you can shift the path if the origin of the object is not in its center!) On the other hand, the smaller the cells the more possible paths exist. If you make cells too large, openings between obstacles may get closed because all cells intersect an obstacle.</p><ul class="colour"><li><a href="mp_grid_create.htm">mp_grid_create</a></li><li><a href="mp_grid_destroy.htm">mp_grid_destroy</a></li><li><a href="mp_grid_path.htm">mp_grid_path</a></li><li><a href="mp_grid_add_cell.htm">mp_grid_add_cell</a></li><li><a href="mp_grid_add_instances.htm">mp_grid_add_instances</a></li><li><a href="mp_grid_add_rectangle.htm">mp_grid_add_rectangle</a></li><li><a href="mp_grid_get_cell.htm">mp_grid_get_cell</a></li><li><a href="mp_grid_clear_all.htm">mp_grid_clear_all</a></li><li><a href="mp_grid_clear_cell.htm">mp_grid_clear_cell</a></li><li><a href="mp_grid_clear_rectangle.htm">mp_grid_clear_rectangle</a></li><li><a href="mp_grid_to_ds_grid.htm">mp_grid_to_ds_grid</a>&nbsp;/&nbsp;<a href="../../Data_Structures/DS_Grids/ds_grid_to_mp_grid.htm">ds_grid_to_mp_grid</a></li><li><a href="mp_grid_draw.htm">mp_grid_draw</a></li></ul><p>&nbsp;</p><p>The grid-based approach is very powerful (and is used in many professional games) but it requires that you do some careful thinking as you must determine which area and cell size are good enough for solving the game. Also, you must determine which objects must be avoided and whether precise checking is important. All these parameters strongly influence the efficiency of the approach. You must also decide whether it is actually necessary as maybe one of the less costly <span class="inline2">mp_*</span>&nbsp;functions can do the job just as well.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="../Movement_And_Collisions.htm">Movement And Collisions</a></div><div style="float:right">Next: <a href="../Collisions/Collisions.htm">Collisions</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>