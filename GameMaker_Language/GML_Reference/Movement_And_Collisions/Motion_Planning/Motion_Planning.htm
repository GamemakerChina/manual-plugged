<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,o){let n;n=o?e.attr(o):e.html();let i=t[removeHtml(n)];if(null!=i&&i.length){t=retHtml(n);let a=0;t&&t.forEach(function(e,t){var o=i.replace("{"+a+"}",e);i=o===i?i.replace("{}",e):o,a++}),o?e.attr(o,i):e.html(i)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Finally we specify a start position and a goal position, both of which&nbsp;{}must{}&nbsp;lie in free cells, and the function then computes the shortest path possible between these two positions. The path will run between the centers of all free cells, so if the cells are large enough so that the instance placed at its center will lie completely inside it this will be successful. This path is then assigned to the instance to follow using the&nbsp;{}{}path_*{}{}&nbsp;functions. You should realise how important cell size is for this as the cells must be large enough so that the moving object placed with its origin on the center of a cell will lie&nbsp;{}completely{}&nbsp;inside the cell. (Be careful about the position of the origin of the object. Also realize that you can shift the path if the origin of the object is not in its center!) On the other hand, the smaller the cells the more possible paths exist. If you make cells too large, openings between obstacles may get closed because all cells intersect an obstacle.":"最后，我们指定一个起始位置和一个目标位置，这两个位置都{}必须{}位于自由单元格中，然后函数计算这两个位置之间可能的最短路径。路径将在所有自由单元格的中心之间运行，因此，如果单元格足够大，以便放置在其中心的实例将完全位于其内部，这将是成功的。然后使用 {}{}path_*{}{} 函数将此路径分配给要跟随的实例。您应该意识到单元格大小对于此有多重要，因为单元格必须足够大，以便将移动对象放置在单元格中心，使其原点{}完全{}位于单元格内部。(请注意对象原点的位置。还要注意，如果对象的原点不在其中心，则可以移动路径！)另一方面，单元越小，可能存在的路径越多。如果将单元格设置得太大，则障碍物之间的洞口可能会关闭，因为所有单元格都与障碍物相交。",'In many games you want opponents, NPC\'s, enemies etc... to interact with the player and show certain intelligence when moving around ie: you want them to avoid obstacles, plan routes and generally not bump into everything in their path! To aid in this {}GameMaker{} has a series of functions that deal with motion planning. Note that while these are designed for things like game enemies, they can be used for all sorts of things like creating a smooth way to introduce text, or to create transitions etc... However, whatever you choose to use from the list below in your game, it should be noted that in many situations a single function set will not give you a perfect solution and that you will have to "mix and match" the functions, using one or the other depending on the situation within your game.':'在许多游戏中，你希望对手，Npc，敌人等……与玩家互动，并在四处移动时表现出某种智慧：你希望他们避开障碍，规划路线，并且通常不会碰到他们路径中的任何东西！{}GameMaker{}具有一系列处理运动规划的函数。请注意，虽然这些是针对游戏敌人等事物而设计的，但它们可以用于各种各样的事情，如创建引入文本的流畅方式，或创建过渡等……然而，无论您在游戏中从下面的列表中选择使用什么，都应该注意，在许多情况下，单个函数集不会给您提供完美的解决方案，您必须根据游戏中的情况使用其中一个或另一个来"混合和匹配"函数。','In many games you want opponents, NPC\'s, enemies, etc. to interact with the player and show certain intelligence when moving around,&nbsp;i.e.&nbsp;you want them to avoid obstacles, plan routes and generally not bump into everything in their path! To aid in this {}GameMaker{} has a series of functions that deal with motion planning. Note that while these are designed for things like game enemies, they can be used for all sorts of things like creating a smooth way to introduce text, or to create transitions, etc. However, whatever you choose to use from the list below in your game, it should be noted that in many situations a single function set will not give you a perfect solution and that you will have to "mix and match" the functions, using one or the other depending on the situation within your game.':'在许多游戏中，您希望对手、NPC、敌人等与玩家互动并在移动时表现出一定的智能，即您希望他们避开障碍物、规划路线并且通常不会撞到路径上的所有物体！为了帮助实现这一目标，{}GameMaker{} 提供了一系列处理运动规划的函数。请注意，虽然这些是为游戏敌人之类的事情而设计的，但它们可以用于各种事情，例如创建平滑的方式来引入文本或创建过渡等。但是，无论您从下面的列表中选择使用什么，游戏中，应该注意的是，在许多情况下，单一功能集不会为您提供完美的解决方案，您必须 " 混合和匹配 " 功能，根据游戏中的情况使用其中一种或另一种。',"Motion planning in {}GameMaker{} is dealt with by the {}mp_*{}&nbsp;functions, which themselves are split into the following three groups:":"{}GameMaker{} 中的运动规划由 {}mp_*{} 函数处理，这些函数本身分为以下三组：","Motion planning in {}GameMaker{} is dealt with by the {}mp_{} functions, which themselves are split into the following three groups:":"{}GameMaker{}中的运动规划由{}mp_{}函数处理，这些函数本身分为以下三个组：","Next, for all relevant objects that we want to avoid we need to determine the grid cells they overlap (based either on their bounding boxes or their precise sprite) and mark these cells as being forbidden. So a cell will be marked totally forbidden, even if an obstacle is only partially overlapping.":"接下来，对于我们想要避免的所有相关对象，我们需要确定它们重叠的栅格单元格(基于它们的边界框或精确的精灵)，并将这些单元格标记为禁止。因此，一个细胞将被标记为完全禁止，即使障碍只是部分重叠。","The final type of function use a much more complex mechanism based on a grid-based approach (sometimes called an A* algorithm). It will be much more successful in finding paths (although it still might fail) and will find the shortest paths possible but it requires more work on your side to set it up.":"最后一种类型的函数使用更复杂的基于网格的方法(有时称为A*算法)的机制。它将更成功地找到路径(尽管它仍然可能失败)，并且会找到可能的最短路径，但是它需要你做更多的工作来设置它。","The global idea is as follows - First of all we create a grid that covers the room (or the relevant part of it). You can choose to use a fine grid, which will be slower, or a coarse grid, but both of them should be based on the resolution of the room so that the path-finding is as accurate as possible. For example, if you have a room that is 400x200 pixels, you can have a grid resolution of 40, or 20, or 10... it all depends on how accurate you need the path to be and how much processing you want GameMaker to do to generate it.":"全局设想如下-首先，我们创建一个网格来覆盖房间(或其相关部分)。您可以选择使用较慢的细栅格或粗栅格，但这两种栅格都应基于房间的分辨率，以便尽可能精确地查找路径。例如，如果您有一个400 x 200像素的房间，则可以将栅格分辨率设置为40、20或10...这完全取决于您需要路径的准确程度，以及您希望GameMaker执行多少处理来生成该路径。","The global idea is as follows - First of all we create a grid that covers the room (or the relevant part of it). You can choose to use a fine grid, which will be slower, or a coarse grid, but both of them should be based on the resolution of the room so that the path-finding is as accurate as possible. For example, if you have a room that is 400x200 pixels, you can have a grid resolution of 40, or 20, or 10... it all depends on how accurate you need the path to be and how much processing you want {}GameMaker{}&nbsp;to do to generate it.":"总体思路如下 - 首先，我们创建一个覆盖房间 (或其相关部分) 的网格。您可以选择使用细网格 (速度会较慢) 或粗网格，但两者都应基于房间的分辨率，以便寻路尽可能准确。例如，如果您有一个 400x200 像素的房间，则网格分辨率可以为 40、20 或 10... 这完全取决于您需要路径的精确度以及您想要的处理量 {}GameMaker{} 来生成它。","The grid-based approach is very powerful (and is used in many professional games) but it requires that you do some careful thinking as you must determine which area and cell size are good enough for solving the game. Also, you must determine which objects must be avoided and whether precise checking is important. All these parameters strongly influence the efficiency of the approach. You must also decide whether it is actually necessary as maybe one of the less costly {}mp_*{}&nbsp;functions can do the job just as well.":"基于网格的方法非常强大(在许多专业游戏中使用)，但它需要你仔细思考，因为你必须确定哪个区域和单元格大小足以解决游戏。此外，还必须确定必须避免哪些对象，以及精确检查是否重要。所有这些参数都极大地影响了该方法的效率。您还必须确定是否实际上有必要这样做，因为成本较低的{}mp_*{}函数也可以完成这项工作。","These are the basic avoidance functions and good for simple AI. They work by making an instance take a step towards a particular goal position while trying to go straight if possible but taking a different direction if required. These functions should be used in the&nbsp;{}Step Event{}&nbsp;of an instance.":"这些都是基本的回避函数，对简单的Ai有好处。它们的工作方式是使实例朝着特定目标位置迈出一步，同时尽可能直接尝试，但如果需要，可以采用不同的方向。应在实例的{}步骤事件{}中使用这些函数。","This kind of function tries to compute a collision-free path for the instance. Once this path has been computed you can assign it to the instance to move towards the goal. The computation of the path will take some time but after that the execution of the path will be fast. Of course this is only valid if the situation has not changed in the meantime. For example, if obstacles change you possibly will need to recompute the path. Again notice that these functions might fail and that no path may be found for the instance.":"此类函数尝试计算实例的无碰撞路径。计算此路径后，可以将其指定给实例以向目标移动。路径的计算将需要一些时间，但在此之后，路径的执行将会很快。当然，这只有在情况没有改变的情况下才有效。例如，如果障碍物发生变化，则可能需要重新计算路径。请再次注意，这些函数可能会失败，并且可能找不到实例的路径。","{}Grid Functions{}":"{}网格函数{}","{}Linear Functions{}":"{}线性函数{}","{}Potential Functions{}":"{}潜在函数{}"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.5.2"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Motion Planning</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference section for Motion Planning functions and variables"><meta name="rh-index-keywords" content=""><meta name="search-keywords" content="Motion Planning,mp,mp funtions"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Movement_And_Collisions/Motion_Planning/mp_linear_step.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Movement_And_Collisions/Movement/move_and_collide.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Motion Planning"><span>Motion Planning</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Motion Planning</span></h1><p>In many games you want opponents, NPC's, enemies, etc. to interact with the player and show certain intelligence when moving around,&nbsp;i.e.&nbsp;you want them to avoid obstacles, plan routes and generally not bump into everything in their path! To aid in this <span data-keyref="GameMaker Name">GameMaker</span> has a series of functions that deal with motion planning. Note that while these are designed for things like game enemies, they can be used for all sorts of things like creating a smooth way to introduce text, or to create transitions, etc. However, whatever you choose to use from the list below in your game, it should be noted that in many situations a single function set will not give you a perfect solution and that you will have to "mix and match" the functions, using one or the other depending on the situation within your game.</p><p>Motion planning in <span data-keyref="GameMaker Name">GameMaker</span> is dealt with by the <span class="inline2">mp_*</span>&nbsp;functions, which themselves are split into the following three groups:</p><h2><label for="one">Linear Functions</label></h2><p>This kind of function tries to compute a collision-free path for the instance. Once this path has been computed you can assign it to the instance to move towards the goal. The computation of the path will take some time but after that the execution of the path will be fast. Of course this is only valid if the situation has not changed in the meantime. For example, if obstacles change you possibly will need to recompute the path. Again notice that these functions might fail and that no path may be found for the instance.</p><ul class="colour"><li><a href="mp_linear_step.htm">mp_linear_step</a></li><li><a href="mp_linear_step_object.htm">mp_linear_step_object</a></li><li><a href="mp_linear_path.htm">mp_linear_path</a></li><li><a href="mp_linear_path_object.htm">mp_linear_path_object</a></li></ul><p>&nbsp;</p><h2><label for="three">Potential Functions</label></h2><p>These are the basic avoidance functions and good for simple AI. They work by making an instance take a step towards a particular goal position while trying to go straight if possible but taking a different direction if required. These functions should be used in the&nbsp;<b>Step Event</b>&nbsp;of an instance.</p><ul class="colour"><li><a href="mp_potential_settings.htm">mp_potential_settings</a></li><li><a href="mp_potential_step.htm">mp_potential_step</a></li><li><a href="mp_potential_step_object.htm">mp_potential_step_object</a></li><li><a href="mp_potential_path.htm">mp_potential_path</a></li><li><a href="mp_potential_path_object.htm">mp_potential_path_object</a></li></ul><p>&nbsp;</p><h2><label for="two">Grid Functions</label></h2><p>The final type of function use a much more complex mechanism based on a grid-based approach (sometimes called an A* algorithm). It will be much more successful in finding paths (although it still might fail) and will find the shortest paths possible but it requires more work on your side to set it up.</p><p>The global idea is as follows - First of all we create a grid that covers the room (or the relevant part of it). You can choose to use a fine grid, which will be slower, or a coarse grid, but both of them should be based on the resolution of the room so that the path-finding is as accurate as possible. For example, if you have a room that is 400x200 pixels, you can have a grid resolution of 40, or 20, or 10... it all depends on how accurate you need the path to be and how much processing you want <span data-keyref="GameMaker Name">GameMaker</span>&nbsp;to do to generate it.</p><p>Next, for all relevant objects that we want to avoid we need to determine the grid cells they overlap (based either on their bounding boxes or their precise sprite) and mark these cells as being forbidden. So a cell will be marked totally forbidden, even if an obstacle is only partially overlapping.</p><p>Finally we specify a start position and a goal position, both of which&nbsp;<i>must</i>&nbsp;lie in free cells, and the function then computes the shortest path possible between these two positions. The path will run between the centers of all free cells, so if the cells are large enough so that the instance placed at its center will lie completely inside it this will be successful. This path is then assigned to the instance to follow using the&nbsp;<a href="../../Asset_Management/Paths/Paths.htm"><span class="inline">path_*</span></a>&nbsp;functions. You should realise how important cell size is for this as the cells must be large enough so that the moving object placed with its origin on the center of a cell will lie&nbsp;<i>completely</i>&nbsp;inside the cell. (Be careful about the position of the origin of the object. Also realize that you can shift the path if the origin of the object is not in its center!) On the other hand, the smaller the cells the more possible paths exist. If you make cells too large, openings between obstacles may get closed because all cells intersect an obstacle.</p><ul class="colour"><li><a href="mp_grid_create.htm">mp_grid_create</a></li><li><a href="mp_grid_destroy.htm">mp_grid_destroy</a></li><li><a href="mp_grid_path.htm">mp_grid_path</a></li><li><a href="mp_grid_add_cell.htm">mp_grid_add_cell</a></li><li><a href="mp_grid_add_instances.htm">mp_grid_add_instances</a></li><li><a href="mp_grid_add_rectangle.htm">mp_grid_add_rectangle</a></li><li><a href="mp_grid_get_cell.htm">mp_grid_get_cell</a></li><li><a href="mp_grid_clear_all.htm">mp_grid_clear_all</a></li><li><a href="mp_grid_clear_cell.htm">mp_grid_clear_cell</a></li><li><a href="mp_grid_clear_rectangle.htm">mp_grid_clear_rectangle</a></li><li><a href="mp_grid_to_ds_grid.htm">mp_grid_to_ds_grid</a>&nbsp;/&nbsp;<a href="../../Data_Structures/DS_Grids/ds_grid_to_mp_grid.htm">ds_grid_to_mp_grid</a></li><li><a href="mp_grid_draw.htm">mp_grid_draw</a></li></ul><p>&nbsp;</p><p>The grid-based approach is very powerful (and is used in many professional games) but it requires that you do some careful thinking as you must determine which area and cell size are good enough for solving the game. Also, you must determine which objects must be avoided and whether precise checking is important. All these parameters strongly influence the efficiency of the approach. You must also decide whether it is actually necessary as maybe one of the less costly <span class="inline2">mp_*</span>&nbsp;functions can do the job just as well.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="../Movement_And_Collisions.htm">Movement And Collisions</a></div><div style="float:right">Next: <a href="../Collisions/Collisions.htm">Collisions</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>