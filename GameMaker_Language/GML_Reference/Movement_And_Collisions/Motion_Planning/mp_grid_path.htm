<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(t){return t=(t=(t=(t=t.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(t){return t.match(/(<([^>]+)>)/gi)},setTranslator=function(t,e,a){let o;o=a?t.attr(a):t.html();let i=e[removeHtml(o)];if(null!=i&&i.length){e=retHtml(o);let n=0;e&&e.forEach(function(t,e){var a=i.replace("{"+n+"}",t);i=a===i?i.replace("{}",t):a,n++}),a?t.attr(a,i):t.html(i)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var t=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(t):($(".topic-header").append(t),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(t){return t.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Finishing x coordinate of the new path":"完成新路径的 X 坐标","Finishing y coordinate of the new path":"完成新路径的 Y 坐标","Index of the mp_grid that is to be used":"要使用的 mp_grid 的索引","Indicates whether diagonal moves are allowed instead of just horizontal or vertical":"指示是否允许对角线移动，而不仅仅是水平或垂直移动","Starting x coordinate of the new path":"新路径的起始 X 坐标","Starting y coordinate of the new path":"新路径的起始 Y 坐标",'The above code creates a global variable "global.grid", then generates an mp_grid and assigns its index (id) to that variable for use in all further mp_grid function calls. It then adds all instances of "obj_Wall" into the grid before getting all instances of "obj_Enemy" to create a path and then use {}mp_grid_path{} to calculate a rout from their position to the position of "obj_Player". If a route exists then the object starts itself along the path.':'上述代码创建一个全局变量 global.grid，然后生成一个 mp_grid 并将其 index(id) 分配给该变量，以便在所有进一步的 mp_grid 函数调用中使用。然后将 "obj_Wall" 的所有实例添加到网格中，然后获取 "obj_Enemy" 的所有实例以创建路径，然后使用 {}mp_grid_path{} 计算从其位置到 "obj_Player" 位置的路由。如果存在路由，则对象将沿路径启动自身。',"With this function you can create a path that will navigate from a start point to a finish point using an {}mp_grid{} that you have previously defined, avoiding any obstacles that have already been added into the grid. The xstart and ystart arguments indicate the start of the path in room coordinates, while xgoal, ygoal arguments indicate the destination. You can also select either horizontal/vertical movement only, or allow full diagonal movements by specifying true in the allowdiag argument. The function returns either true (it succeeded in finding a path) or false (it failed) as well as setting the chosen path. In the following image, you can see how this all works together:":"使用此函数，您可以创建一个路径，该路径将使用先前定义的 {}mp_grid{} 从起点导航到终点，从而避免已添加到网格中的任何障碍。xstart 和 ystart 参数指示房间坐标中路径的起点，而 xgoal 和 ygoal 参数指示目标。也可以只选择水平 / 垂直移动，或者通过在 allowdiag 参数中指定 true 来允许完全对角线移动。函数返回 true(成功查找路径) 或 false(失败) 以及设置所选路径。在下图中，您可以看到这一切是如何协同工作的：","index of the path that is to be used by the function":"函数要使用的路径的索引",'{}As you can see, the "pipe" objects have been added into the grid, meaning that any path created has to go around them. There are two paths created in the image, one (green) has been made with diagonals allowed and the other (red) without. The difference between the two is pretty obvious with the green path appearing much more "elegant" and direct, but it all depends what use you are going to put them to which one you prefer. Note that the path is independent of the current instance - it is a path through the grid, not a path for a specific instance, even though a specific instance may have the variable that stores the path index. You may also need to debug these paths to see how they are made and interact within the game environment, in which case you should be using the {}{}draw_path(){}{}&nbsp;function.':'{} 如您所见，"管道 " 对象已添加到网格中，这意味着创建的任何路径都必须绕过它们。在图像中创建了两条路径，一条 (绿色) 为允许对角线，另一条 (红色) 为不允许对角线。两者之间的区别非常明显，绿色道路显得更加 " 优雅 " 和直接，但这完全取决于你将他们放在你更喜欢的地方有什么用。请注意，路径与当前实例无关-它是通过网格的路径，而不是特定实例的路径，即使特定实例可能具有存储路径索引的变量。您可能还需要调试这些路径以查看它们是如何在游戏环境中创建和交互的，在这种情况下，您应该使用 {}{}draw_path(){}{} 函数。',"{}NOTE{}: The path must have been previously created (either in code with {}{}{}path_add(){}{}{} or as a resource) and will be replaced by the path generated by this function.":"{} 注意 {}: 路径必须是以前创建的 (使用 {}{}{}path_add(){}{}{} 的代码或作为资源)，并且将由此函数生成的路径替换。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(t){json_global=t}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.5.2.0_12"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>mp_grid_path</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="This page outlines the function mp_grid_path"><meta name="rh-index-keywords" content="mp_grid_path"><meta name="search-keywords" content="mp_grid_path"><meta name="is_pure" content="true"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Movement_And_Collisions/Motion_Planning/mp_grid_add_cell.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Movement_And_Collisions/Motion_Planning/mp_grid_destroy.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="mp_grid_path"><span>mp_grid_path</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>mp_grid_path</h1><p>With this function you can create a path that will navigate from a start point to a finish point using an <span class="inline">mp_grid</span> that you have previously defined, avoiding any obstacles that have already been added into the grid. The xstart and ystart arguments indicate the start of the path in room coordinates, while xgoal, ygoal arguments indicate the destination. You can also select either horizontal/vertical movement only, or allow full diagonal movements by specifying true in the allowdiag argument. The function returns either true (it succeeded in finding a path) or false (it failed) as well as setting the chosen path. In the following image, you can see how this all works together:</p><p><img alt="MP Grid path example" class="center" src="../../../../assets/Images/Scripting_Reference/GML/Reference/Movement_Collisions/mp_grid_path_image.png">As you can see, the "pipe" objects have been added into the grid, meaning that any path created has to go around them. There are two paths created in the image, one (green) has been made with diagonals allowed and the other (red) without. The difference between the two is pretty obvious with the green path appearing much more "elegant" and direct, but it all depends what use you are going to put them to which one you prefer. Note that the path is independent of the current instance - it is a path through the grid, not a path for a specific instance, even though a specific instance may have the variable that stores the path index. You may also need to debug these paths to see how they are made and interact within the game environment, in which case you should be using the <span class="inline"><a href="../../Drawing/Basic_Forms/draw_path.htm">draw_path()</a></span>&nbsp;function.</p><p class="note"><b>NOTE</b>: The path must have been previously created (either in code with <span style="font-size:1px"><a href="../../Asset_Management/Paths/Path_Manipulation/path_add.htm"><span class="inline">path_add()</span></a></span> or as a resource) and will be replaced by the path generated by this function.</p><p>&nbsp;</p><h4>Syntax:</h4><p class="code">mp_grid_path(id, path, xstart, ystart, xgoal, ygoal, allowdiag);</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>id</td><td><span data-keyref="Type_ID_MP_Grid"><a target="_blank" href="mp_grid_create.htm">MP Grid ID</a></span></td><td>Index of the mp_grid that is to be used</td></tr><tr><td>path</td><td><span data-keyref="Type_Asset_Path"><a target="_blank" href="../../../../The_Asset_Editors/Paths.htm">Path Asset</a></span></td><td>index of the path that is to be used by the function</td></tr><tr><td>xstart</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>Starting x coordinate of the new path</td></tr><tr><td>ystart</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>Starting y coordinate of the new path</td></tr><tr><td>xgoal</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>Finishing x coordinate of the new path</td></tr><tr><td>ygoal</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>Finishing y coordinate of the new path</td></tr><tr><td>allowdiag</td><td><span data-keyref="Type_Bool"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Boolean</a></span></td><td>Indicates whether diagonal moves are allowed instead of just horizontal or vertical</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Bool"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Boolean</a></span></p><p>&nbsp;</p><h4>Example:</h4><p class="code">global.grid = mp_grid_create(0, 0, room_width div 32, room_height div 32, 32, 32);<br>mp_grid_add_instances(global.grid, obj_wall, false);<br>with (obj_Enemy)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;path = path_add();<br>&nbsp;&nbsp;&nbsp;&nbsp;if (mp_grid_path(global.grid, path, x, y, obj_Player.x, obj_Player.y, 1))<br>&nbsp; &nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path_start(path, 0, 3, 0);<br>&nbsp; &nbsp; }<br>}</p><p>The above code creates a global variable "global.grid", then generates an mp_grid and assigns its index (id) to that variable for use in all further mp_grid function calls. It then adds all instances of "obj_Wall" into the grid before getting all instances of "obj_Enemy" to create a path and then use <span class="inline">mp_grid_path</span> to calculate a rout from their position to the position of "obj_Player". If a route exists then the object starts itself along the path.</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back:&nbsp;<a href="Motion_Planning.htm">Motion Planning</a></div><div style="float:right">Next:&nbsp;<a href="mp_grid_add_cell.htm">mp_grid_add_cell</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>