<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let o;o=a?e.attr(a):e.html();let r=t[removeHtml(o)];if(null!=r&&r.length){t=retHtml(o);let n=0;t&&t.forEach(function(e,t){var a=r.replace("{"+n+"}",e);r=a===r?r.replace("{}",e):a,n++}),a?e.attr(a,r):e.html(r)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Garbage Collection":"垃圾回收","In general you should never need to interact with the {}GameMaker{} garbage collection system and normally the results of its operation are not visible but some GML commands are available to get information about what the collector is doing and to influence its behaviour to a limited degree.":"一般来说，你永远不需要与{}GameMaker{}垃圾回收系统进行交互，通常它的操作结果是不可见的，但是有些 GML 命令可用于获取有关收集器正在做什么的信息，并在有限程度上影响其行为。",'The garbage collection which {}GameMaker{} uses is "generational". This means that, in order to reduce the work that must be done every frame, objects are divided into "generations". New objects are created in generation 0 and they are moved into older generations as they themselves age. The general idea is that objects which hang around for a while don\'t need to be continuously tested to see if they should be deleted, but can be checked less frequently (note that "objects" here refers to anything that can be garbage collected and {}not{} general object instances as defined in the Asset Browser). Note that while the checking system is generational, the actual checks are done in an "incremental" way, such that instead of clearing up potentially thousands of objects from a generation in a single frame - causing a large spike in CPU use and potentially affecting the gameplay - each generation will be checked and if required the cleaning will be spread over multiple frames so the garbage collector runs more frequently but does less work each frame it is collecting (you can set the target time for the garbage collector to spend on each frame using the function {}{}gc_target_frame_time(){}{}).':'{}GameMaker{}使用的垃圾回收是 "世代相传"。这意味着，为了减少每帧必须完成的工作，将对象划分为 "世代"。新对象是在第 0 代中创建的，随着它们自身的老化，它们会被移到较早的一代。总体思路是，暂停一段时间的对象不需要持续测试以查看是否应将其删除，但可以减少检查频率(请注意，这里的 "对象" 是指任何可以进行垃圾回收的对象，{}不是{}资源浏览器中定义的通用对象实例)。请注意，虽然检查系统是世代相传的，但实际检查是以 "增量" 的方式完成的，因此，与其在单帧中清除一代中可能存在的数千个物体(导致 CPU 使用率激增并可能影响游戏玩法)，而是检查每一代对象，如果需要，清理将分散在多个帧上，这样垃圾收集器的运行频率就会更高，但每收集一帧的工作量就会减少(你可以为垃圾收集器设置目标时间)使用函数{在每帧上消费}{}{}gc_target_frame_time(){}{})。',"The {}GameMaker{} {}Garbage Collector{} exists because methods can be passed on the stack and left unreferenced, as can structs and a few other things, which in turn would cause a memory leak if they weren't \"cleaned up\" in some way. This is where the garbage collector comes in and it will run in the background of the game, collecting anything that's been de-referenced and maintaining an optimal memory usage. When we talk about something being de-referenced, we generally refer to&nbsp;any struct or function which isn't connected (it doesn't have to be directly, but through a chain of other variables) to a {}global {}variable or an {}object instance variable{}. Also note that functions defined in scripts in the IDE are also not collected, as they are implicitly made global.":'{}GameMaker{}{}垃圾收集器{}之所以存在，是因为方法可以在堆栈上传递而不被引用，结构和其他一些东西也是如此，如果不以某种方式 "清理" 它们，反过来又会导致内存泄漏。这就是垃圾收集器的用武之地，它将在游戏后台运行，收集任何被取消引用的内容并保持最佳的内存使用率。当我们谈论被解引用的东西时，我们通常指任何与{}global{}变量或{}对象实例变量{}没有连接(不必直接连接，而是通过一系列其他变量)的结构或函数。另请注意，在 IDE 脚本中定义的函数也不会被收集，因为它们被隐式设置为全局函数。','To help decide what needs garbage collected and when you also have a few functions that can be used to create and check&nbsp;{}weak references{}&nbsp;to structs. A&nbsp;weak reference is a reference that does not protect the referenced object from collection by a garbage collector, and so can be used to check if a struct is still "alive" (referenced) or not somewhere in the game. The functions available for weak referencing are:':'为了帮助决定哪些需要收集垃圾，以及何时还有一些函数可以用来创建和检查{}对结构的弱引用{}。弱引用是一种不能保护被引用对象免受垃圾回收器收集的引用，因此可用于检查结构是否仍在 "活着"(被引用)或不在游戏中的某个地方。可用于弱引用的函数有：',"{}IMPORTANT!{} Note that on the HTML5 target platform garbage collection is handled by the JavaScript engine and therefore none of the functions listed below will affect its operation and the function {}gc_get_stats(){} will returns 0 for all fields.":"{}重要！{}请注意，在 HTML5 目标平台上，垃圾回收由 JavaScript 引擎处理，因此下面列出的任何函数都不会影响其操作，函数{}gc_get_stats(){}将为所有字段返回 0。","{}NOTE{}: Please note that things like surfaces, data structures, buffers and other dynamic resources are {}not{} garbage collected and have their own {}destroy{} functions to clean up the memory associated with them. As a rule of thumb, if anything you create at run time has a {}destroy{} function then it won't be garbage collected and you will have to deal with it yourself in code. The exceptions to this are sequences, animation curves and instances, which also require the&nbsp;garbage collector, {}but still need to have their destroy function called{}.":"{}注意{}：请注意，诸如表面、数据结构、缓冲区和其他动态资源之类的内容{}未收集到{}垃圾，并且其自身的{}函数已被销毁{}，以清理与其关联的内存。根据经验，如果您在运行时创建的任何内容具有{}销毁{}函数，则不会对其进行垃圾收集，您必须在代码中自行处理。例外情况是序列、动画曲线和实例，它们也需要垃圾收集器{}，但仍需要调用其销毁函数{}。","{}{}IMPORTANT{}{}&nbsp;On the HTML5 target platform garbage collection is handled by the JavaScript engine and therefore none of the functions listed below will affect its operation and the function&nbsp;{}{}gc_get_stats{}{} will return 0 for all fields.":"{}{} 重要信息{}{} 在 HTML5 目标平台上，垃圾回收由 JavaScript 引擎处理，因此下面列出的函数都不会影响其操作，并且函数 {}{}gc_get_stats{}{} 将返回 0 所有领域。","{}{}{}NOTE{}{}&nbsp;{}Please note that things like surfaces, data structures, buffers and other dynamic resources are {}not{} garbage collected and have their own {}destroy{} functions to clean up the memory associated with them. As a rule of thumb, if anything you create at run time has a {}destroy{} function then it won't be garbage collected and you will have to deal with it yourself in code. The exceptions to this are sequences, animation curves and instances, which also require the&nbsp;garbage collector, {}but still need to have their destroy function called{}.":"{}{}{} 注意{}{}{} 请注意，诸如表面、数据结构、缓冲区和其他动态资源之类的东西 {} 不会 {} 被垃圾收集，并且有自己的 {} 销毁 {} 函数来清理与他们相关的记忆。根据经验，如果您在运行时创建的任何内容具有 {}destroy{} 函数，那么它不会被垃圾回收，您必须自己在代码中处理它。序列、动画曲线和实例除外，它们也需要垃圾收集器，{} 但仍需要调用其销毁函数 {}。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.2.23"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Garbage Collection</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference section for the Garbage Collection functions"><meta name="rh-index-keywords" content=""><meta name="search-keywords" content="Garbage Collection"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Garbage_Collection/gc_enable.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Debugging/is_keyboard_used_debug_overlay.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Garbage Collection"><span>Garbage Collection</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Garbage Collection</span></h1><p>The <span data-keyref="GameMaker Name">GameMaker</span> <strong>Garbage Collector</strong> exists because methods can be passed on the stack and left unreferenced, as can structs and a few other things, which in turn would cause a memory leak if they weren't "cleaned up" in some way. This is where the garbage collector comes in and it will run in the background of the game, collecting anything that's been de-referenced and maintaining an optimal memory usage. When we talk about something being de-referenced, we generally refer to&nbsp;any struct or function which isn't connected (it doesn't have to be directly, but through a chain of other variables) to a <strong>global</strong> variable or an <strong>object instance variable</strong>. Also note that functions defined in scripts in the IDE are also not collected, as they are implicitly made global.</p><p class="note"><b><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;</b>Please note that things like surfaces, data structures, buffers and other dynamic resources are <b>not</b> garbage collected and have their own <span class="inline">destroy</span> functions to clean up the memory associated with them. As a rule of thumb, if anything you create at run time has a <span class="inline">destroy</span> function then it won't be garbage collected and you will have to deal with it yourself in code. The exceptions to this are sequences, animation curves and instances, which also require the&nbsp;garbage collector, <b>but still need to have their destroy function called</b>.</p><p>The garbage collection which <span data-keyref="GameMaker Name">GameMaker</span> uses is "generational". This means that, in order to reduce the work that must be done every frame, objects are divided into "generations". New objects are created in generation 0 and they are moved into older generations as they themselves age. The general idea is that objects which hang around for a while don't need to be continuously tested to see if they should be deleted, but can be checked less frequently (note that "objects" here refers to anything that can be garbage collected and <i>not</i> general object instances as defined in the Asset Browser). Note that while the checking system is generational, the actual checks are done in an "incremental" way, such that instead of clearing up potentially thousands of objects from a generation in a single frame - causing a large spike in CPU use and potentially affecting the gameplay - each generation will be checked and if required the cleaning will be spread over multiple frames so the garbage collector runs more frequently but does less work each frame it is collecting (you can set the target time for the garbage collector to spend on each frame using the function <span class="inline"><a href="gc_target_frame_time.htm">gc_target_frame_time()</a></span>).</p><p>In general you should never need to interact with the <span data-keyref="GameMaker Name">GameMaker</span> garbage collection system and normally the results of its operation are not visible but some GML commands are available to get information about what the collector is doing and to influence its behaviour to a limited degree.</p><p class="note"><span data-conref="../../../assets/snippets/Tag_important.hts"><span class="important">IMPORTANT</span></span>&nbsp;On the HTML5 target platform garbage collection is handled by the JavaScript engine and therefore none of the functions listed below will affect its operation and the function&nbsp;<span class="inline3_func"><a href="gc_get_stats.htm">gc_get_stats</a></span> will return 0 for all fields.</p><ul class="colour"><li><a href="gc_enable.htm">gc_enable</a></li><li><a href="gc_is_enabled.htm">gc_is_enabled</a></li><li><a href="gc_collect.htm">gc_collect</a></li><li><a href="gc_target_frame_time.htm">gc_target_frame_time</a></li><li><a href="gc_get_target_frame_time.htm">gc_get_target_frame_time</a></li><li><a href="gc_get_stats.htm">gc_get_stats</a></li></ul><p>&nbsp;</p><p>To help decide what needs garbage collected and when you also have a few functions that can be used to create and check&nbsp;<strong>weak references</strong>&nbsp;to structs. A&nbsp;weak reference is a reference that does not protect the referenced object from collection by a garbage collector, and so can be used to check if a struct is still "alive" (referenced) or not somewhere in the game. The functions available for weak referencing are:</p><ul class="colour"><li><a href="weak_ref_create.htm">weak_ref_create</a></li><li><a href="weak_ref_alive.htm">weak_ref_alive</a></li><li><a href="weak_ref_any_alive.htm">weak_ref_any_alive</a></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../GML_Reference.htm">GML Reference</a></div><div style="float:right">Next:&nbsp;<a href="../Steam/Steam.htm">Steam</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>