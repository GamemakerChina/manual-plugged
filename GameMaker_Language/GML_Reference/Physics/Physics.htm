<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,o){let n;n=o?e.attr(o):e.html();let i=t[removeHtml(n)];if(null!=i&&i.length){t=retHtml(n);let a=0;t&&t.forEach(function(e,t){var o=i.replace("{"+a+"}",e);i=o===i?i.replace("{}",e):o,a++}),o?e.attr(o,i):e.html(i)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={'Care should be taken when binding fixtures, as they can be bound to objects and instances independently. This means that if you bind a fixture to (for example) "o_Wall", {}all{} instances of that object will get the fixture. If you only want to bind a fixture to one instance, then use that instance\'s id in the appropriate function.':'绑定装置时应该小心，因为它们可以独立地绑定到对象和实例上。这意味着，如果你将一个装置绑定到(例如) "o_Wall"，{}该对象的所有{}实例都将获得该装置。如果你只想把装置绑定到一个实例上，那么在适当的函数中使用该实例的ID。',"Finally, there are a couple of special physics functions which may be useful for more advanced physics simulations. The first is for testing for possible collisions at a specific point in the room, and the second is for generating custom mass and inertia properties within an instance:":"最后，有几个特殊的物理函数可能对更高级的物理模拟有用。第一个用于测试房间中特定点上的可能碰撞，第二个用于在实例中生成自定义质量和惯性属性：",Fixtures:"装置",Forces:"力","Information on the physics functions can be found on the following pages:":"有关物理函数的信息，请参阅以下页面：",Joints:"关节",Physics:"物理","Physics Variables":"物理变量","Please be aware that due to differences in floating point precision you may find that versions of your game for different target platforms may exhibit subtly different behaviour to the standard Windows version, though each version will be self-consistent across subsequent executions.":"请注意，由于浮点精度的差异，您可能会发现不同目标平台的游戏版本可能会表现出与标准 Windows 版本微妙不同的行为，尽管每个版本在后续执行过程中都会保持自我一致。","Soft Body Particles":"柔体粒子","The Physics World":"物理世界",'The integration of a dedicated physics library to {}GameMaker{} means that you can now take control over all aspects of the physical behaviour of objects within your game world, particularly collisions and object interaction. The "traditional" collision system (which {}GameMaker{} defaults to) is a "reactive" system, where you check for a collision and {}then{} react to that collision with code that you place in individual objects. This is fine for simple games, but when you have a large number of objects and have to code how they all react to different situations in the game world, it quickly becomes obvious that this system is just not enough. That\'s when you have to turn to the {}GameMaker{} physics system.':'{}GameMaker{} 集成了专用的物理库，这意味着您现在可以控制游戏世界中对象物理行为的所有方面，尤其是碰撞和对象交互。"传统"碰撞系统({}GameMaker{} 默认为该系统)是"被动"系统，您可以在其中检查碰撞，{}然后{}对碰撞做出反应，并将代码放入各个对象中。这对于简单的游戏来说是可以的，但当你拥有大量的对象，并且必须对它们如何对游戏世界中的不同情况做出反应进行编码时，很快就会发现，这个系统只是不够。那时你必须求助于 {}GameMaker{} 物理系统。','The physics system exists "apart" from the basic room and instance structure of {}GameMaker{} meaning that its timings and functions are not necessarily tied into the room speed and step order like everything else.':'{}GameMaker{} 的物理系统与基本房间和实例结构"分开"，这意味着它的时间和函数不一定像其他任何东西那样与房间速度和步进顺序相关。',"The physics system replaces many of the normal instance functions... for example, rather than set a speed and a direction for an instance, if it has been declared as being a fully simulated physical body, you would use a {}force{} or {}impulse{} to get it to move around in the game world, or if it is not physics enabled you will need to set the x an y positions yourself. This takes a bit of getting used to, so experiment with the physics functions and get to know how everything works before trying to integrate them into your project.":"物理系统取代了许多正常的实例函数。。。。。。例如，不是为某个实例设置速度和方向，如果它已被声明为完全模拟的物理身体，您将使用{}力{}或{}脉冲{}使其在游戏世界中移动，或者如果它未启用物理函数，则需要自己设置 X 和 Y 位置。这需要一点时间来适应，所以在尝试将它们集成到项目中之前，先试验一下物理函数并了解一切是如何工作的。",'The physics system works in a very different way to normal collisions. It is more of a "passive" system where you define a series of properties for your objects in the game world, as well as the properties of the game world itself, before any collisions or interactions occur. These coded "rules" will then govern the way everything in your game world interacts. In this way, with a few simple code and the correct room setup, you can create very complex interactions between objects and the world which will occur and resolve {}without{} you having to code for every single possible outcome.':'物理系统的工作方式与普通碰撞完全不同。它更像是一个"被动"的系统，在游戏世界中，在发生任何碰撞或交互之前，您会为您的对象定义一系列属性，以及游戏世界本身的属性。然后，这些代码化的"规则"将控制游戏世界中的一切相互作用的方式。通过这种方式，使用几个简单的代码和正确的房间设置，您可以在对象和世界之间创建非常复杂的交互并解决，而{}无需{}为每个可能的结果编码。',"There are a few things that you should note when working with the {}GameMaker{} physics world:":"使用 {}GameMaker{} 物理世界时，应注意以下几点：","To prevent instabilities in the physical simulation Box2D constrains to upper limits the amount a body may rotate and translate within a single update. The apparent limitations will vary according to the accuracy of the physical simulation in accordance with the number of updates and update speed of the physics world, and also in accordance with the physics world scaling. This means that (for example) if you have a world update speed of 60, the maximum movement speed would be 20.":"为了防止物理模拟中的不稳定性，Box2D 对一个物体在一次更新中的旋转和平移量进行了上限限制。明显的限制将根据物理模拟的精度，按照物理世界的更新次数和更新速度，以及物理世界的缩放比例而变化。这意味着(例如)如果你有一个 60 的世界更新速度，最大的移动速度将是 20。","Try not to move instances from one point of the room to another in any way other than using the physics functions (ie: do not set the x/y coordinates manual). Although this can be done and in some circumstances it may be necessary, this is generally to be avoided due to the unpredictable results that it may have on the physics engine, especially when trying to resolve collisions.":"除了使用物理函数，尽量不要以任何方式将实例从房间的一个点移动到另一个点(即：不要手动设置 X/Y 坐标)。尽管可以这样做，而且在某些情况下可能是必要的，但由于它可能对物理引擎产生不可预测的结果，特别是在试图解决碰撞的时候，一般要避免这样做。","When setting up collisions, use parents as much as possible since the collision system has a limited number of {}collision bits{} available to assign to instances for Box2D to detect collisions. For example, if you have five different wall objects, don't check for five collisions, rather, create a parent object and assign it to the five walls then have ONE collision check with the parent. The physical properties of the objects are {}not inherited{} only the collisions. In this way you can keep your game optimised and error free.":"在设置碰撞时，尽量使用父对象，因为碰撞系统有有限的{}碰撞位{}可以分配给 Box2D 的实例来检测碰撞。例如，如果你有五个不同的墙体对象，不要检查五个碰撞，而是创建一个父对象，并将其分配给五个墙体，然后让一个碰撞检查与父对象进行碰撞。对象的物理属性{}不会被继承{}，只有碰撞会被继承。通过这种方式，你可以保持游戏的优化和解决错误。","You should limit the number of instances that are created, as well as the number of collisions and collision groups that the physics world has to deal with. You {}cannot{} have thousands of instances, all with physical properties and collisions and expect everything to work fine due to the fact that physics requires some pretty intensive calculations, so limit yourself and optimise where possible.":"您应该限制创建的实例数，以及物理世界必须处理的碰撞和碰撞组的数量。{}不能{}有成千上万的实例，所有这些实例都具有物理属性和碰撞，并且由于物理需要一些非常密集的计算，因此，请尽可能限制自己并进行优化。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.2.13"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Physics</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference section for physics functions"><meta name="rh-index-keywords" content=""><meta name="search-keywords" content="Physics"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Physics/The_Physics_World/The_Physics_World.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Time_Sources/call_cancel.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Physics"><span>Physics</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>Physics</h1><p>The integration of a dedicated physics library to <span data-keyref="GameMaker Name">GameMaker</span> means that you can now take control over all aspects of the physical behaviour of objects within your game world, particularly collisions and object interaction. The "traditional" collision system (which <span data-keyref="GameMaker Name">GameMaker</span> defaults to) is a "reactive" system, where you check for a collision and <i>then</i> react to that collision with code that you place in individual objects. This is fine for simple games, but when you have a large number of objects and have to code how they all react to different situations in the game world, it quickly becomes obvious that this system is just not enough. That's when you have to turn to the <span data-keyref="GameMaker Name">GameMaker</span> physics system.</p><p>The physics system works in a very different way to normal collisions. It is more of a "passive" system where you define a series of properties for your objects in the game world, as well as the properties of the game world itself, before any collisions or interactions occur. These coded "rules" will then govern the way everything in your game world interacts. In this way, with a few simple code and the correct room setup, you can create very complex interactions between objects and the world which will occur and resolve <i>without</i> you having to code for every single possible outcome.</p><p>There are a few things that you should note when working with the <span data-keyref="GameMaker Name">GameMaker</span> physics world:</p><ul class="colour"><li>The physics system exists "apart" from the basic room and instance structure of <span data-keyref="GameMaker Name">GameMaker</span> meaning that its timings and functions are not necessarily tied into the room speed and step order like everything else.</li><li>The physics system replaces many of the normal instance functions... for example, rather than set a speed and a direction for an instance, if it has been declared as being a fully simulated physical body, you would use a <i>force</i> or <i>impulse</i> to get it to move around in the game world, or if it is not physics enabled you will need to set the x an y positions yourself. This takes a bit of getting used to, so experiment with the physics functions and get to know how everything works before trying to integrate them into your project.</li><li>You should limit the number of instances that are created, as well as the number of collisions and collision groups that the physics world has to deal with. You <i>cannot</i> have thousands of instances, all with physical properties and collisions and expect everything to work fine due to the fact that physics requires some pretty intensive calculations, so limit yourself and optimise where possible.</li><li>When setting up collisions, use parents as much as possible since the collision system has a limited number of <i>collision bits</i> available to assign to instances for Box2D to detect collisions. For example, if you have five different wall objects, don't check for five collisions, rather, create a parent object and assign it to the five walls then have ONE collision check with the parent. The physical properties of the objects are <i>not inherited</i> only the collisions. In this way you can keep your game optimised and error free.</li><li>Try not to move instances from one point of the room to another in any way other than using the physics functions (ie: do not set the x/y coordinates manual). Although this can be done and in some circumstances it may be necessary, this is generally to be avoided due to the unpredictable results that it may have on the physics engine, especially when trying to resolve collisions.</li><li>Care should be taken when binding fixtures, as they can be bound to objects and instances independently. This means that if you bind a fixture to (for example) "o_Wall", <b>all</b> instances of that object will get the fixture. If you only want to bind a fixture to one instance, then use that instance's id in the appropriate function.</li><li>Please be aware that due to differences in floating point precision you may find that versions of your game for different target platforms may exhibit subtly different behaviour to the standard Windows version, though each version will be self-consistent across subsequent executions.</li><li>To prevent instabilities in the physical simulation Box2D constrains to upper limits the amount a body may rotate and translate within a single update. The apparent limitations will vary according to the accuracy of the physical simulation in accordance with the number of updates and update speed of the physics world, and also in accordance with the physics world scaling. This means that (for example) if you have a world update speed of 60, the maximum movement speed would be 20.</li></ul><p>Information on the physics functions can be found on the following pages:</p><ul class="colour"><li><a href="The_Physics_World/The_Physics_World.htm">The Physics World</a></li><li><a href="Forces/Forces.htm">Forces</a></li><li><a href="Fixtures/Fixtures.htm">Fixtures</a></li><li><a href="Joints/Joints.htm">Joints</a></li><li><a href="Soft_Body_Particles/Soft_Body_Particles.htm">Soft Body Particles</a></li><li><a href="Physics_Variables/Physics_Variables.htm">Physics Variables</a></li></ul><p>&nbsp;</p><p>Finally, there are a couple of special physics functions which may be useful for more advanced physics simulations. The first is for testing for possible collisions at a specific point in the room, and the second is for generating custom mass and inertia properties within an instance:</p><ul class="colour"><li><a href="physics_test_overlap.htm">physics_test_overlap</a></li><li><a href="physics_mass_properties.htm">physics_mass_properties</a></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../GML_Reference.htm">GML Reference</a></div><div style="float:right">Next: <a href="../In_App_Purchases/In_App_Purchases.htm">In App Purchases</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>