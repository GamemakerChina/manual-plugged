<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,n){let a;a=n?e.attr(n):e.html();let s=t[removeHtml(a)];if(null!=s&&s.length){t=retHtml(a);let o=0;t&&t.forEach(function(e,t){var n=s.replace("{"+o+"}",e);s=n===s?s.replace("{}",e):n,o++}),n?e.attr(n,s):e.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Basically, a socket is an object which can send, receive, connect and listen to {}ports{} on the network. These functions deal with just TCP/IP connections, which is what the internet is based on (IPv4 to be more precise). In essence this lets you connect one socket using an IP address (let's say 192.168.1.10) to another socket on another IP address (say 192.168.1.11). Once connected, these two sockets can send data back and forth using the {}network_send_*{} functions (like {}{}network_send_packet(){}{}) and the dedicated asynchronous event that is triggered by them. This async event will generate a {}DS map{} containing the data received as well as other details, and you can find the complete details in the section on the {}Network Async Event{}.":"基本上，套接字是可以发送、接收、连接和监听网络上{}端口{}的对象。这些函数只处理TCP/IP连接，这是互联网的基础(更准确的说是IPv4)。本质上，这允许您使用IP地址(比如说192.168.1.10)将一个套接字连接到另一个IP地址(如192.168.1.11)上的另一个套接字。一旦连接，这两个套接字可以使用{}network_send_*{}函数(如{}{}network_send_packet(){}{})和由它们触发的专用异步事件来回发送数据。此异步事件将生成包含接收数据和其他详细信息的{}DS map{}，您可以在{}网络异步事件{}部分中找到完整详细信息。","Basically, a socket is an object which can send, receive, connect and listen to {}ports{} on the network. These functions deal with just TCP/IP connections, which is what the internet is based on. In essence this lets you connect one socket using an IP address (let's say 192.168.1.10) to another socket on another IP address (say 192.168.1.11). Once connected, these two sockets can send data back and forth using the {}network_send_*{} functions (like {}{}network_send_packet(){}{}) and the dedicated asynchronous event that is triggered by them. This async event will generate a {}DS map{} containing the data received as well as other details, and you can find the complete details in the section on the {}Network Async Event{}.":"基本上，套接字是可以发送、接收、连接和监听网络上{}端口{}的对象。这些函数只处理TCP/IP连接，这是互联网的基础。本质上，这允许您使用IP地址(比如说192.168.1.10)将一个套接字连接到另一个IP地址(如192.168.1.11)上的另一个套接字。一旦连接，这两个套接字可以使用{}network_send_*{}函数(如{}{}network_send_packet(){}{})和由它们触发的专用异步事件来回发送数据。此异步事件将生成包含接收数据和其他详细信息的{}DS map{}，您可以在{}网络异步事件{}部分中找到完整详细信息。","Basically, a socket is an object which can send, receive, connect and listen to {}ports{} on the network. When using TCP, you connect one socket using an IP address (let's say 192.168.1.10) to another socket on another IP address (say 192.168.1.11). Once connected, these two sockets can send data back and forth using the {}network_send_*{}&nbsp;functions (like {}{}network_send_packet{}{}) and the dedicated asynchronous event that is triggered by them. This async event will generate a {}DS map{} containing the data received as well as other details, and you can find the complete details in the section on the {}Network Async Event{}.":"基本上，套接字是一个可以发送、接收、连接和侦听网络上的 {} 端口 {} 的对象。使用 TCP 时，您可以将使用 IP 地址 (假设为 192.168.1.10) 的一个套接字连接到另一个 IP 地址 (假设为 192.168.1.11) 上的另一个套接字。连接后，这两个套接字可以使用 {}network_send_*{} 函数 (如 {}{}network_send_packet{}{}) 以及由它们触发的专用异步事件来回发送数据。此异步事件将生成一个包含接收到的数据以及其他详细信息的 {}DS 映射 {}，您可以在有关 {} 网络异步事件 {} 的部分中找到完整的详细信息。","Function Reference":"功能参考","Functions used for creating sockets, connecting to servers and sending data have raw alternatives, which you can see in the list below.":"用于创建套接字、连接到服务器和发送数据的函数有原始的替代方案，您可以在下面的列表中看到。","Instead of programs having to read and deal with every bit of network traffic coming into a machine, IP addresses also deal with ports, which are numbered from 0 to 65535. This allows each program to get only the packets of data that it's interested in, and not everything that has been sent by every program. This also saves considerable CPU time, as it seriously cuts down on data processing, so with {}GameMaker{} you can also “listen” to ports. So, a server will create a socket, and then bind it to a specific port to listen to. It will then get notified of connections, disconnections and data transfers from that socket.":'与程序必须读取和处理进入计算机的每一位网络流量不同，IP地址还处理从0到65535的端口。这允许每个程序只获得它感兴趣的数据包，而不是每个程序发送的所有数据。这还节省了大量Cpu时间，因为它严重减少了数据处理，因此使用{}GameMaker{}，您还可以"侦听"端口。因此，服务器将创建一个套接字，然后将其绑定到要侦听的特定端口。然后，它将收到来自该套接字的连接、断开连接和数据传输的通知。',"It is worth noting that if you are creating a project for the HTML5 target, then you will not be able to use the server create functions due to browser restrictions and will have to write your own server for this platform using something like {}Electron {}or {}NodeJS{}. Also note that if your game is cross platform and you anticipate connecting to an HTML5 instance of the game from a server running on a mobile or desktop device, then your server can only communicate to the HTML5 instance using the Web Socket protocol (this is done using the constant {}network_socket_ws{}&nbsp;or&nbsp;{}network_socket_wss{} - see {}{}network_create_server(){}{} for more information). This means that your server may have to create two sockets on different ports, one to connect to non HTML5 targets (Android, Windows, etc...) and one to connect to the HTML5 target.":"值得注意的是，如果您正在为HTML5目标创建项目，则由于浏览器限制，您将无法使用服务器创建函数，并且必须使用类似{}Electron{}或{}NodeJS{}的内容为此平台编写自己的服务器。另请注意，如果您的游戏是跨平台的，并且您希望从运行在移动设备或桌面设备上的服务器连接到游戏的HTML5实例，则您的服务器只能使用Web套接字协议与HTML5实例通信(这是使用常量{}network_socket_ws{}或{}network_socket_wss{}-有关详细信息，请参阅 {}{}network_create_server(){}{}这意味着您的服务器可能必须在不同的端口上创建两个插槽，一个用于连接到非HTML5目标(Android、Windows等)，另一个用于连接到HTML5目标。","It is worth noting that if you are creating a project for the HTML5 target, then you will not be able to use the server create functions due to browser restrictions and will have to write your own server for this platform using something like {}Electron {}or {}NodeJS{}. Also note that if your game is cross-platform and you anticipate connecting to an HTML5 instance of the game from a server running on a mobile or desktop device, then your server can only communicate to the HTML5 instance using the Web Socket protocol (this is done using the constant {}network_socket_ws{}&nbsp;or&nbsp;{}network_socket_wss{} - see&nbsp;{}{}network_create_server{}{} for more information). This means that your server may have to create two sockets on different ports, one to connect to non HTML5 targets (Android, Windows, etc.) and one to connect to the HTML5 target.":"值得注意的是，如果您要为 HTML5 目标创建项目，那么由于浏览器限制，您将无法使用服务器创建功能，并且必须使用 {}Electron{} 或 {}NodeJS{}。另请注意，如果您的游戏是跨平台的，并且您预计从移动或桌面设备上运行的服务器连接到游戏的 HTML5 实例，那么您的服务器只能使用 Web Socket 协议 (这是使用常量 {}network_socket_ws{} 或 {}network_socket_wss{} 完成 - 请参阅 {}{}network_create_server{}{} 了解更多信息)。这意味着您的服务器可能必须在不同端口上创建两个套接字，一个用于连接到非 HTML5 目标 (Android、Windows 等)，另一个用于连接到 HTML5 目标。","Packet Separation":"数据包分离","Packets/requests sent through regular networking functions (e.g.&nbsp;{}{}network_connect{}{}) include additional header data inserted by GameMaker, so only GameMaker games can talk to each other.":"通过常规网络功能 (例如 {}{}network_connect{}{}) 发送的数据包 / 请求包含 GameMaker 插入的附加标头数据，因此只有 GameMaker 游戏可以相互通信。","Raw Functions":"原始函数","The UDP protocol is connectionless, so you don't connect sockets, you instead send data to an IP address and port directly using&nbsp;{}{}network_send_udp{}{}. GameMaker also supports WebSockets.":"UDP 协议是无连接的，因此您无需连接套接字，而是使用 {}{}network_send_udp{}{} 直接将数据发送到 IP 地址和端口。 GameMaker 还支持 WebSocket。",'The data "packets" themselves are made up of binary data taken from a buffer. This buffer can be created and manipulated using the {}GameMaker{} {}Buffer functions{}.':'数据 "packets" 本身由从缓冲器获取的二进制数据组成。可以使用 {}GameMaker{}{}Buffer{} 系列函数创建和操作此缓冲区。',"The following functions exist for you to use for networking:":"您可以使用以下函数进行联网：","The raw functions (e.g.&nbsp;{}{}network_connect_raw{}{}) are used to connect with non-GameMaker servers/clients, e.g. if you want to connect to a server written in JavaScript, PHP, etc.":"原始函数 (例如 {}{}network_connect_raw{}{}) 用于与非 GameMaker 服务器 / 客户端连接，例如如果你想连接到用 JavaScript、PHP 等编写的服务器。","The {}GameMaker{} networking functions are based on {}sockets{}, which is an industry standard on all platforms. With sockets, you have the ability to create both clients and servers using simple GML which allows you to create even a single player game using the client/server model (something which will allow multiplayer to be added easily later).":"{}GameMaker{}网络函数基于{}套接字{}，这是所有平台上的行业标准。使用套接字，您可以使用简单的 GML 创建客户端和服务器，这允许您使用客户端/服务器模型创建单个玩家游戏(这将允许稍后轻松添加多人游戏)。","When using UDP or WebSockets, packets will be delivered in the form that they were sent, so using the non-raw functions for these protocols only adds unnecessary overhead.":"使用 UDP 或 WebSocket 时，数据包将以发送时的形式进行传递，因此对这些协议使用非原始函数只会增加不必要的开销。","When using raw TCP functions, it will fall on the game to read the incoming packets and separate/combine them as they were sent.":"当使用原始 TCP 函数时，游戏将负责读取传入的数据包并在发送数据包时将它们分开 / 组合。","When using raw TCP networking, multiple packets sent by one client may be received as a single packet by the receiving client, and the opposite may also happen where a single packet is split into multiple packets. Non-raw networking functions prevent this from happening as GameMaker inserts headers into each packet, allowing the receiving GameMaker client to separate or combine incoming packets to represent them as they were sent.":"当使用原始 TCP 网络时，一个客户端发送的多个数据包可能会被接收客户端作为单个数据包接收，并且相反的情况也可能发生，即单个数据包被拆分为多个数据包。非原始网络功能可以防止这种情况发生，因为 GameMaker 将标头插入到每个数据包中，从而允许接收 GameMaker 客户端分离或组合传入数据包以代表它们发送时的情况。","{}You must not mix the use of regular and raw functions in your game, as doing so will cause issues. This means for a connection made with&nbsp;{}{}network_connect{}{}, you must use&nbsp;{}{}network_send_packet{}{}, and for&nbsp;{}{}network_connect_raw{}{}, use&nbsp;{}{}network_send_raw{}{}.{}":"{} 您不得在游戏中混合使用常规函数和原始函数，因为这样做会导致问题。这意味着，对于使用 {}{}network_connect{}{} 建立的连接，您必须使用 {}{}network_send_packet{}{}，而对于 {}{}network_connect_raw{}{}，则必须使用 {}{}network_send_raw{}{}.{}","{}{}NOTE{}{}&nbsp;GameMaker supports IPv4 and IPv6 addresses on all platforms excluding the Nintendo Switch, PlayStation 4 and PlayStation 5.":"{}{} 注意{}{}GameMaker 在除 Nintendo Switch、PlayStation 4 和 PlayStation 5 之外的所有平台上支持 IPv4 和 IPv6 地址。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.2.15"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Networking</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference section for the Networking  functions"><meta name="rh-index-keywords" content=""><meta name="search-keywords" content="Networking"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Networking/network_create_server.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Asynchronous_Functions/Facebook/Facebook.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Networking"><span>Networking</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Networking</span></h1><p>The <span data-keyref="GameMaker Name">GameMaker</span> networking functions are based on <i>sockets</i>, which is an industry standard on all platforms. With sockets, you have the ability to create both clients and servers using simple GML which allows you to create even a single player game using the client/server model (something which will allow multiplayer to be added easily later).</p><p>Basically, a socket is an object which can send, receive, connect and listen to <i>ports</i> on the network. When using TCP, you connect one socket using an IP address (let's say 192.168.1.10) to another socket on another IP address (say 192.168.1.11). Once connected, these two sockets can send data back and forth using the <span class="inline2">network_send_*</span>&nbsp;functions (like <span class="inline3_func"><a href="network_send_packet.htm">network_send_packet</a></span>) and the dedicated asynchronous event that is triggered by them. This async event will generate a <a href="../Data_Structures/DS_Maps/DS_Maps.htm">DS map</a> containing the data received as well as other details, and you can find the complete details in the section on the <a href="../../../The_Asset_Editors/Object_Properties/Async_Events/Networking.htm">Network Async Event</a>.</p><div data-conref="../../../assets/snippets/Note_Networking_socket_limit.hts"><p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;There is a maximum limit of 1024 sockets on Windows, macOS and Ubuntu, and 64 sockets on all other platforms.</p></div><p>The UDP protocol is connectionless, so you don't connect sockets, you instead send data to an IP address and port directly using&nbsp;<span class="inline3_func"><a href="network_send_udp.htm">network_send_udp</a></span>. GameMaker also supports WebSockets.</p><p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;GameMaker supports IPv4 and IPv6 addresses on all platforms excluding the Nintendo Switch, PlayStation 4 and PlayStation 5.</p><p>Instead of programs having to read and deal with every bit of network traffic coming into a machine, IP addresses also deal with ports, which are numbered from 0 to 65535. This allows each program to get only the packets of data that it's interested in, and not everything that has been sent by every program. This also saves considerable CPU time, as it seriously cuts down on data processing, so with <span data-keyref="GameMaker Name">GameMaker</span> you can also “listen” to ports. So, a server will create a socket, and then bind it to a specific port to listen to. It will then get notified of connections, disconnections and data transfers from that socket.</p><p>The data "packets" themselves are made up of binary data taken from a buffer. This buffer can be created and manipulated using the <span data-keyref="GameMaker Name">GameMaker</span> <a href="../Buffers/Buffers.htm">Buffer functions</a>.</p><p>It is worth noting that if you are creating a project for the HTML5 target, then you will not be able to use the server create functions due to browser restrictions and will have to write your own server for this platform using something like <strong>Electron</strong> or <strong>NodeJS</strong>. Also note that if your game is cross-platform and you anticipate connecting to an HTML5 instance of the game from a server running on a mobile or desktop device, then your server can only communicate to the HTML5 instance using the Web Socket protocol (this is done using the constant <span class="inline">network_socket_ws</span>&nbsp;or&nbsp;<span class="inline">network_socket_wss</span> - see&nbsp;<span class="inline3_func"><a href="network_create_server.htm">network_create_server</a></span> for more information). This means that your server may have to create two sockets on different ports, one to connect to non HTML5 targets (Android, Windows, etc.) and one to connect to the HTML5 target.</p><h2>Raw Functions</h2><p>Functions used for creating sockets, connecting to servers and sending data have raw alternatives, which you can see in the list below.</p><p>Packets/requests sent through regular networking functions (e.g.&nbsp;<span class="inline3_func"><a href="network_connect.htm">network_connect</a></span>) include additional header data inserted by GameMaker, so only GameMaker games can talk to each other.</p><p>The raw functions (e.g.&nbsp;<span class="inline3_func"><a href="network_connect_raw.htm">network_connect_raw</a></span>) are used to connect with non-GameMaker servers/clients, e.g. if you want to connect to a server written in JavaScript, PHP, etc.</p><p><span data-conref="../../../assets/snippets/Networking_dont_mix_raw_reg.hts">You must not mix the use of regular and raw functions in your game, as doing so will cause issues. This means for a connection made with&nbsp;<span class="inline3_func"><a href="network_connect.htm" title="Cross-reference [network_connect.htm]" data-tcx-title="Cross-reference [network_connect.htm]">network_connect</a></span>, you must use&nbsp;<span class="inline3_func"><a href="network_send_packet.htm" title="Cross-reference [network_send_packet.htm]" data-tcx-title="Cross-reference [network_send_packet.htm]">network_send_packet</a></span>, and for&nbsp;<span class="inline3_func"><a href="network_connect_raw.htm" title="Cross-reference [network_connect_raw.htm]" data-tcx-title="Cross-reference [network_connect_raw.htm]">network_connect_raw</a></span>, use&nbsp;<span class="inline3_func"><a href="network_send_raw.htm" title="Cross-reference [network_send_raw.htm]" data-tcx-title="Cross-reference [network_send_raw.htm]">network_send_raw</a></span>.</span></p><h3 id="h">Packet Separation</h3><p>When using raw TCP networking, multiple packets sent by one client may be received as a single packet by the receiving client, and the opposite may also happen where a single packet is split into multiple packets. Non-raw networking functions prevent this from happening as GameMaker inserts headers into each packet, allowing the receiving GameMaker client to separate or combine incoming packets to represent them as they were sent.</p><p>When using raw TCP functions, it will fall on the game to read the incoming packets and separate/combine them as they were sent.</p><p>When using UDP or WebSockets, packets will be delivered in the form that they were sent, so using the non-raw functions for these protocols only adds unnecessary overhead.</p><h2 id="func_ref">Function Reference</h2><ul class="colour"><li><a href="network_create_server.htm">network_create_server</a></li><li><a href="network_create_server_raw.htm">network_create_server_raw</a></li><li><a href="network_create_socket.htm">network_create_socket</a></li><li><a href="network_create_socket_ext.htm">network_create_socket_ext</a></li><li><a href="network_connect.htm">network_connect</a></li><li><a href="network_connect_async.htm">network_connect_async</a></li><li><a href="network_connect_raw.htm">network_connect_raw</a></li><li><a href="network_connect_raw_async.htm">network_connect_raw_async</a></li><li><a href="network_resolve.htm">network_resolve</a></li><li><a href="network_set_config.htm">network_set_config</a></li><li><a href="network_set_timeout.htm">network_set_timeout</a></li><li><a href="network_send_broadcast.htm">network_send_broadcast</a></li><li><a href="network_send_packet.htm">network_send_packet</a></li><li><a href="network_send_raw.htm">network_send_raw</a></li><li><a href="network_send_udp.htm">network_send_udp</a></li><li><a href="network_send_udp_raw.htm">network_send_udp_raw</a></li><li><a href="network_destroy.htm">network_destroy</a></li></ul><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../GML_Reference.htm">GML Reference</a></div><div style="float:right">Next:&nbsp;<a data-condition="Export:StableOnly" href="../Web_And_HTML5/Web_And_HTML5.htm">Web And HTML5</a>&nbsp;</div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>