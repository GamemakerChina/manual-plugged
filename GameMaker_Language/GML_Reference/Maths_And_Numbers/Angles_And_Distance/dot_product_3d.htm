<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,o){let n;n=o?e.attr(o):e.html();let r=t[removeHtml(n)];if(null!=r&&r.length){t=retHtml(n);let a=0;t&&t.forEach(function(e,t){var o=r.replace("{"+a+"}",e);r=o===r?r.replace("{}",e):o,a++}),o?e.attr(o,r):e.html(r)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"If a and b are perpendicular (at 90 degrees to each other), the result of the dot product will be zero, because {}cos(ang){} will be zero":"如果 a 和 b 彼此垂直(90度) ，点乘的结果将为零，因为{} cos (ang){}将为零","If the angle between a and b are greater than 90 degrees, the dot product will be negative (less than zero), as {}cos(ang){} will be negative":"如果 a 和 b 之间的夹角大于90度，则点乘为负(小于零) ，因为{} cos (ang){}为负","If the angle between a and b are less than 90 degrees, the dot product will be positive (greater than zero), as {}cos(ang){} will be positive":"如果 a 和 b 之间的夹角小于90度，则点乘为正(大于零) ，因为{} cos (ang){}为正","In 2D, the dot product of vectors {}a[x1,y1]{} and {}b[x2,y2]{} is {}x1x2 + y1y2{}, so in 3D, the dot product of vectors {}a[x1,y1,z1]{} and {}b[x1,y1,z1]{} is {}x1x2 + y1y2 + z1z2{}. So, the dot_product_3d in {}GameMaker{} is calculated as:":"在二维中，向量{}a[x1,y1]{}和{}b[x2,y2]{}的点积是{}x1x2 + y1y2{}，在三维中，向量{}a[x1,y1,z1]{}和{}b[x1,y1,z1]{}的点积是{}x1x2 + y1y2 + z1z2{}。所以，{}GameMaker{}中的dot_product_3d被计算为:",'So what does this mean for those of us that make games? Well, this mathematical relationship can be used in quite a few circumstances, but the best way to see it is to build an actual scenario and see for yourself what is going on. One of the simplest ways to do this is to generate a simple "height" check for an enemy in, say, a platform game so that the enemy will "see" the player if they are above the plane formed by the enemy {}normal{} vector and the 3d floor.':"这对我们这些游戏开发者来说意味着什么呢?这种数学关系可以用在很多情况下，但最好的方法是建立一个实际的场景，自己看看发生了什么。最简单的方法之一就是在平台游戏中为敌人生成一个简单的“高度”检查，这样如果敌人位于敌人{}法向量和3d地板组成的平面之上，敌人就会“看到”玩家。","That is to say, the dot product of two vectors will be equal to the cosine of the angle between those vectors, multiplied by the lengths of each of them. Here is an image to illustrate:":"也就是说，两个向量的点积等于这两个向量夹角的余弦，乘以它们各自的长度。这里有一张图片来说明:",'The above code creates a vector normal along the instances y (up) axis, and then gets the vector of the player object "o_Player" to itself. Finally it calculates the dot product of these two vectors and if it is greater tan 0 it sets the variable "above" to true, and if it is less than or equal to 0 it sets it to "false".':"上面的代码创建了一个沿实例y(向上)轴的向量，然后获取播放器对象“o_Player”的向量。最后，它计算这两个向量的点积，如果它大于tan0，它将变量above设为真，如果它小于或等于0，它将设为假。","The actual mathematical formula can be written like this:":"实际的数学公式可以这样写:","The curious thing about the dot product is the relationship it has to the angle formed by the input vectors which can be expressed as:":"点积的奇妙之处在于它与输入向量形成的角度之间的关系，可以表示为:",'The dot product is a value expressing the angular relationship between two vectors and is found by taking two vectors, multiplying them together and then adding the results. The name "dot product" is derived from the centered dot "·" that is often used to designate this operation (the alternative name "scalar product" emphasizes the scalar rather than vector nature of the result).':"点积是一个表示两个向量之间角度关系的值，它是通过取两个向量，将它们相乘，然后将结果相加得到的。“点积”这个名称来源于通常用于指定此操作的居中点“·”(另一个名称“标量积”强调结果的标量性质而不是向量性质)。","The x coordinate of the first vector.":"第一个向量的 x 坐标。","The x coordinate of the second vector.":"第二个向量的 x 坐标。","The y coordinate of the first vector.":"第一个向量的 y 坐标。","The y coordinate of the second vector.":"第二个向量的 y 坐标。","The z coordinate of the first vector.":"第一个向量的 z 坐标。","The z coordinate of the second vector.":"第二个向量的 z 坐标。","There are a few things that we can now state from any two vectors in relation to the result of their dot product:":"我们现在可以从任意两个向量，关于它们的点积的结果，来说明一些事情:",'{}Basically, we are getting the vector normal from the enemy perpendicular to the floor and then we are getting the vector of the player to the enemy. We will then get the dot_product of these vectors, and if the result is positive the player is "above" the enemy floor plane and if it is negative he is below. The actual code to get this working is supplied in the example below.':"{}基本上，我们得到的是敌人垂直于地面的法向量，然后我们得到的是玩家到敌人的向量。然后我们将得到这些向量的点积，如果结果是正的，那么玩家就在敌人平面的“上方”，如果结果是负的，那么他就在敌人平面的下方。下面的示例中提供了实现此函数的实际代码。","{}NOTE{}: For more information on vectors, see {}here{}.":"{}注意{}:有关向量的更多信息，请参见{}这里{}。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.11.3.0_23"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>dot_product_3d</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference page for dot_product_3d"><meta name="rh-index-keywords" content="dot_product_3d"><meta name="search-keywords" content="dot_product_3d"><meta name="is_pure" content="true"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/dot_product_normalised.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/dot_product.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="dot_product_3d"><span>dot_product_3d</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>dot_product_3d</h1><p>The dot product is a value expressing the angular relationship between two vectors and is found by taking two vectors, multiplying them together and then adding the results. The name "dot product" is derived from the centered dot "·" that is often used to designate this operation (the alternative name "scalar product" emphasizes the scalar rather than vector nature of the result).</p><p>The actual mathematical formula can be written like this:</p><p><img alt="Dot Product formula" class="center" src="../../../../assets/Images/Scripting_Reference/GML/Reference/Maths/dot_product_image.png"></p><p>In 2D, the dot product of vectors <span class="inline">a[x1,y1]</span> and <span class="inline">b[x2,y2]</span> is <span class="inline">x1x2 + y1y2</span>, so in 3D, the dot product of vectors <span class="inline">a[x1,y1,z1]</span> and <span class="inline">b[x1,y1,z1]</span> is <span class="inline">x1x2 + y1y2 + z1z2</span>. So, the dot_product_3d in <span data-keyref="GameMaker Name">GameMaker</span> is calculated as:</p><p class="code">a · b = (x1*x2) + (y1*y2) + (z1*z2);</p><p>The curious thing about the dot product is the relationship it has to the angle formed by the input vectors which can be expressed as:</p><p class="code">a · b = (length of a) * (length of b) * cos(angle)</p><p>That is to say, the dot product of two vectors will be equal to the cosine of the angle between those vectors, multiplied by the lengths of each of them. Here is an image to illustrate:</p><p><img alt="Dot Product ilustration" class="center" height="143" src="../../../../assets/Images/Scripting_Reference/GML/Reference/Maths/dot_product_image_2.png" width="406"></p><p class="note"><strong>NOTE</strong>: For more information on vectors, see <a href="../../../../Additional_Information/Vectors.htm">here</a>.</p><p>There are a few things that we can now state from any two vectors in relation to the result of their dot product:</p><ul class="colour"><li>If a and b are perpendicular (at 90 degrees to each other), the result of the dot product will be zero, because <span class="inline">cos(ang)</span> will be zero</li><li>If the angle between a and b are less than 90 degrees, the dot product will be positive (greater than zero), as <span class="inline">cos(ang)</span> will be positive</li><li>If the angle between a and b are greater than 90 degrees, the dot product will be negative (less than zero), as <span class="inline">cos(ang)</span> will be negative</li></ul><p>So what does this mean for those of us that make games? Well, this mathematical relationship can be used in quite a few circumstances, but the best way to see it is to build an actual scenario and see for yourself what is going on. One of the simplest ways to do this is to generate a simple "height" check for an enemy in, say, a platform game so that the enemy will "see" the player if they are above the plane formed by the enemy <i>normal</i> vector and the 3d floor.</p><p><img alt="Dot product 3D example" class="center" src="../../../../assets/Images/Scripting_Reference/GML/Reference/Maths/dot_product_3d_image.png">Basically, we are getting the vector normal from the enemy perpendicular to the floor and then we are getting the vector of the player to the enemy. We will then get the dot_product of these vectors, and if the result is positive the player is "above" the enemy floor plane and if it is negative he is below. The actual code to get this working is supplied in the example below.</p><p>&nbsp;</p><h4><b>Syntax:</b></h4><p class="code">dot_product_3d(x1, y1, z1, x2, y2, z2)</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>x1</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The x coordinate of the first vector.</td></tr><tr><td>y1</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The y coordinate of the first vector.</td></tr><tr><td>z1</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The z coordinate of the first vector.</td></tr><tr><td>x2</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The x coordinate of the second vector.</td></tr><tr><td>y2</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The y coordinate of the second vector.</td></tr><tr><td>z2</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The z coordinate of the second vector.</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></p><p>&nbsp;</p><h4>Example:</h4><p class="code">var x1, y1, x2, y2;<br>x1 = 0;<br>y1 = 1;<br>z1 = 0;<br>x2 = o_Player.x - x;<br>y2 = o_Player.y - y;<br>z2 = o_Player.z - z; if dot_product_3d(x1, y1, z1, x2, y2, z2) &gt; 0 above=true else above=false;</p><p>The above code creates a vector normal along the instances y (up) axis, and then gets the vector of the player object "o_Player" to itself. Finally it calculates the dot product of these two vectors and if it is greater tan 0 it sets the variable "above" to true, and if it is less than or equal to 0 it sets it to "false".</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Angles_And_Distance.htm">Angles And Distance</a></div><div style="float:right">Next:&nbsp;<a href="dot_product_normalised.htm">dot_product_normalised</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>