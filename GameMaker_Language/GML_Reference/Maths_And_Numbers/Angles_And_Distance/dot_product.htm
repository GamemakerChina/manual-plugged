<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let n;n=a?e.attr(a):e.html();let s=t[removeHtml(n)];if(null!=s&&s.length){t=retHtml(n);let o=0;t&&t.forEach(function(e,t){var a=s.replace("{"+o+"}",e);s=a===s?s.replace("{}",e):a,o++}),a?e.attr(a,s):e.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"If a and b are perpendicular (at 90 degrees to each other), the result of the dot product will be zero, because {}cos(ang){} will be zero":"如果 a 和 b 彼此垂直(90度) ，点乘的结果将为零，因为{} cos (ang){}将为零","If the angle between a and b are greater than 90 degrees, the dot product will be negative (less than zero), as {}cos(ang){} will be negative":"如果 a 和 b 之间的夹角大于90度，则点乘为负(小于零) ，因为{} cos (ang){}为负","If the angle between a and b are less than 90 degrees, the dot product will be positive (greater than zero), as {}cos(ang){} will be positive":"如果 a 和 b 之间的夹角小于90度，则点乘为正(大于零) ，因为{} cos (ang){}为正",'So what does this mean for those of us that make games? Well, this mathematical relationship can be used in quite a few circumstances, but the best way to see it is to build an actual scenario and see for yourself what is going on. One of the simplest ways to do this is to generate a simple "line of sight" check for an enemy in, say, a platform game so that the enemy will "see" the player if they are within 90° of either side of their vector {}normal{}.':"这对我们这些游戏开发者来说意味着什么呢?这种数学关系可以用在很多情况下，但最好的方法是建立一个实际的场景，自己看看发生了什么。最简单的方法之一是，在平台游戏中为敌人生成一个简单的“视线”检查，这样敌人就会“看到”玩家，如果他们在向量{}法线{}两边的90°内。","So, in 2D the dot product of vectors {}a[x1,y1]{} and {}b[x2,2]{} is {}x1x2 + y1y2{}, meaning that the dot_product in {}GameMaker{} is calculated as:":"因此，在2D中，向量{}a[x1,y1]{}和{}b[x2,2]{}的点积是{}x1x2 + y1y2{}，这意味着{}GameMaker{}中的点积计算为:","That is to say, the dot product of two vectors will be equal to the cosine of the angle between those vectors, multiplied by the lengths of each of them. Here is an image to illustrate:":"也就是说，两个向量的点积等于这两个向量夹角的余弦，乘以它们各自的长度。这里有一张图片来说明:",'The above code creates a vector using the instances image angle, and then gets the vector of the player object "o_Player" to itself. Finally it calculates the dot product of these two vectors and if it is greater than 0 it sets the variable "seen" to true, and if it is equal to or less than 0 it sets it to "false".':"上面的代码使用实例的图像角度创建一个向量，然后获取播放器对象“o_Player”的向量。最后，它计算这两个向量的点积，如果它大于0，它将变量“seen”设置为true，如果它等于或小于0，它将设置为“false”。","The actual mathematical formula can be written like this:":"实际的数学公式可以写成这样:","The curious thing about the dot product is the relationship it has to the angle formed by the input vectors which can be expressed as:":"点积的奇妙之处在于它与输入向量形成的角度之间的关系，可以表示为:",'The dot product is a value expressing the angular relationship between two vectors and is found by taking two vectors, multiplying them together and then adding the results. The name "dot product" is derived from the centered dot "·" that is often used to designate this operation (the alternative name "scalar product" emphasizes the scalar rather than vector nature of the result).':"点积是一个表示两个向量之间角度关系的值，它是通过取两个向量，将它们相乘，然后将结果相加得到的。“点积”这个名称来源于通常用于指定此操作的居中点“·”(另一个名称“标量积”强调结果的标量性质而不是向量性质)。","The x coordinate of the first vector.":"第一个向量的 x 坐标。","The x coordinate of the second vector.":"第二个向量的 x 坐标。","The y coordinate of the first vector.":"第一个向量的 y 坐标。","The y coordinate of the second vector.":"第二个向量的 y 坐标。","There are a few things that we can now state from any two vectors in relation to the result of their dot product:":"我们现在可以从任意两个向量与它们点积的结果的关系中得出一些结论:","{}Basically, we have to get the vector normal from the enemy (ie: comprised of a direction and sight distance) and then we need to get the vector of the player to the enemy. We will then get the dot_product of these vectors, and if the result is positive the player has been seen, and if it is negative he hasn't. The actual code to get this working is supplied in the example below.":"{}基本上，我们必须获得敌人的法向量(即包含方向和视线距离)，然后我们需要获得玩家到敌人的向量。然后我们将得到这些向量的点积，如果结果是正的，则表示玩家被看过，如果结果是负的，则表示他没有看过。下面的示例中提供了实现此函数的实际代码。","{}NOTE{}: For more information on vectors, see {}here{}.":"{}注意{}:有关向量的更多信息，请参见{}这里的{}。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../../..",gTopicId="8.2.2.11.3.0_22"</script><script type="text/javascript" src="../../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>dot_product</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../../assets/css/default.css" type="text/css"><script src="../../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Reference page for dot_product"><meta name="rh-index-keywords" content="dot_product"><meta name="search-keywords" content="dot_product"><meta name="is_pure" content="true"><meta name="brsnext" value="GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/dot_product_3d.htm"><meta name="brsprev" value="GameMaker_Language/GML_Reference/Maths_And_Numbers/Angles_And_Distance/distance_to_point.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="dot_product"><span>dot_product</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>dot_product</h1><p>The dot product is a value expressing the angular relationship between two vectors and is found by taking two vectors, multiplying them together and then adding the results. The name "dot product" is derived from the centered dot "·" that is often used to designate this operation (the alternative name "scalar product" emphasizes the scalar rather than vector nature of the result).</p><p>The actual mathematical formula can be written like this:</p><p><img alt="Dot Product formula" class="center" src="../../../../assets/Images/Scripting_Reference/GML/Reference/Maths/dot_product_image.png"></p><p>So, in 2D the dot product of vectors <span class="inline">a[x1,y1]</span> and <span class="inline">b[x2,2]</span> is <span class="inline">x1x2 + y1y2</span>, meaning that the dot_product in <span data-keyref="GameMaker Name">GameMaker</span> is calculated as:</p><p class="code">a · b = (x1*x2)+(y1*y2);</p><p>The curious thing about the dot product is the relationship it has to the angle formed by the input vectors which can be expressed as:</p><p class="code">a · b = (length of a) * (length of b) * cos(angle)</p><p>That is to say, the dot product of two vectors will be equal to the cosine of the angle between those vectors, multiplied by the lengths of each of them. Here is an image to illustrate:</p><p><img alt="Dot Product ilustration" class="center" height="143" src="../../../../assets/Images/Scripting_Reference/GML/Reference/Maths/dot_product_image_2.png" width="406"></p><p class="note"><strong>NOTE</strong>: For more information on vectors, see <a href="../../../../Additional_Information/Vectors.htm">here</a>.</p><p>There are a few things that we can now state from any two vectors in relation to the result of their dot product:</p><ul class="colour"><li>If a and b are perpendicular (at 90 degrees to each other), the result of the dot product will be zero, because <span class="inline">cos(ang)</span> will be zero</li><li>If the angle between a and b are less than 90 degrees, the dot product will be positive (greater than zero), as <span class="inline">cos(ang)</span> will be positive</li><li>If the angle between a and b are greater than 90 degrees, the dot product will be negative (less than zero), as <span class="inline">cos(ang)</span> will be negative</li></ul><p>So what does this mean for those of us that make games? Well, this mathematical relationship can be used in quite a few circumstances, but the best way to see it is to build an actual scenario and see for yourself what is going on. One of the simplest ways to do this is to generate a simple "line of sight" check for an enemy in, say, a platform game so that the enemy will "see" the player if they are within 90° of either side of their vector <i>normal</i>.</p><p><img alt="Dot product example" class="center" src="../../../../assets/Images/Scripting_Reference/GML/Reference/Maths/dot_product_image_1.png">Basically, we have to get the vector normal from the enemy (ie: comprised of a direction and sight distance) and then we need to get the vector of the player to the enemy. We will then get the dot_product of these vectors, and if the result is positive the player has been seen, and if it is negative he hasn't. The actual code to get this working is supplied in the example below.</p><p>&nbsp;</p><h4><b>Syntax:</b></h4><p class="code">dot_product(x1, y1, x2, y2)</p><table><tbody><tr><th>Argument</th><th>Type</th><th>Description</th></tr><tr><td>x1</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The x coordinate of the first vector.</td></tr><tr><td>y1</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The y coordinate of the first vector.</td></tr><tr><td>x2</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The x coordinate of the second vector.</td></tr><tr><td>y2</td><td><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></td><td>The y coordinate of the second vector.</td></tr></tbody></table><p>&nbsp;</p><h4>Returns:</h4><p class="code"><span data-keyref="Type_Real"><a target="_blank" href="../../../GML_Overview/Data_Types.htm">Real</a></span></p><p>&nbsp;</p><h4>Example:</h4><p class="code">var x1, y1, x2, y2;<br>x1 = lengthdir_x(1, image_angle);<br>y1 = lengthdir_y(1, image_angle);<br>x2 = o_Player.x - x;<br>y2 = o_Player.y - y;<br>if dot_product(x1, y1, x2, y2) &gt; 0 seen=true else seen=false;</p><p>The above code creates a vector using the instances image angle, and then gets the vector of the player object "o_Player" to itself. Finally it calculates the dot product of these two vectors and if it is greater than 0 it sets the variable "seen" to true, and if it is equal to or less than 0 it sets it to "false".</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="Angles_And_Distance.htm">Angles And Distance</a></div><div style="float:right">Next:&nbsp;<a href="dot_product_3d.htm">dot_product_3d</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>