<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,a){let n;n=a?e.attr(a):e.html();let s=t[removeHtml(n)];if(null!=s&&s.length){t=retHtml(n);let i=0;t&&t.forEach(function(e,t){var a=s.replace("{"+i+"}",e);s=a===s?s.replace("{}",e):a,i++}),a?e.attr(a,s):e.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={Accessors:"访问器",'After creating your grid with the&nbsp;{}ds_grid_create(){}&nbsp;function, you would use the grid index that you have stored in a variable to reference it, with the "xpos" and "ypos" being the position within the grid to get or set a value. For example, the following code creates a grid, clears it to 0, then and then adds a few entries to it:':'使用{}ds_grid_create(){}函数创建网格后，可以使用存储在变量中的网格索引来引用它，其中"xpos"和"ypos"是网格中用于获取或设置值的位置。例如，以下代码将创建一个网格，将其清除为0，然后向其添加几个条目：',"After creating your grid with the&nbsp;{}{}ds_grid_create{}{}&nbsp;function, you would use the grid index that you have stored in a variable to reference it, with the {}xpos{} and {}ypos{} being the position within the grid to get or set a value. For example, the following code creates a grid, clears it to 0, then and then adds a few entries to it:":"使用{}{}ds_grid_create{}{}函数创建网格后，您将使用存储在变量中的网格索引来引用它，{}xpos{}和{}ypos{}是网格中的位置，以获取或设置值。例如，下面的代码创建一个网格，将其清除为0，然后向其中添加几个条目：","After creating your map with {}{}ds_map_create{}{}, you would use the map index that you have stored in a variable to reference it, with the {}key{} value being the map key to set or get. For example, the following code creates a map and then adds a few entries to it using this syntax:&nbsp;":"使用{}{}ds_map_create{}{}创建映射后，您将使用存储在变量中的映射索引来引用它，{}key{}值是要设置或获取的映射键。例如，下面的代码创建一个映射，然后使用以下语法向其中添加几个条目：",'After creating your map with&nbsp;{}ds_map_create(){}, you would use the map index that you have stored in a variable to reference it, with the "key" value being the map key to set or get. For example, the following code creates a map and then adds a few entries to it using this syntax:':'使用{}ds_map_create(){}创建映射后，应使用存储在变量中的映射索引来引用该映射，"key"值是要设置或获取的映射键。例如，以下代码将创建一个映射，然后使用此语法向其添加几个条目：',"After you have created your array in an instance, you can then pass it to a script by reference and use the accessor&nbsp;{}@{}&nbsp;to change it directly. For example you would create the array and call the funtion like this:":"在实例中创建数组后，可以通过引用将其传递给脚本，然后使用访问器{}@{}直接更改它。例如，您可以创建数组并调用如下函数：","All this function is doing is selecting 25 random positions in the array and setting the value of the chosen array position to 100.":"该函数所做的就是在数组中选择25个随机位置，并将所选数组位置的值设置为100。","An important feature of accessors is the fact that they can be {}chained{} together. This means that if you have several nested data structures and/or arrays, there is no longer the need to use a variety of functions to get access to a value that is deep within the nested structure. For example, say you have an array, and each item in the array is a DS list, like this:":"访问器的一个重要特征是它们可以被{}链接在一起{}。这意味着，如果您具有多个嵌套数据结构和/或数组，则不再需要使用各种函数来访问嵌套结构中的深层值。例如，假设您有一个数组，并且数组中的每个项目都是DS list，如下所示：","Arrays also have their own accessors which works in a similar way as those listed above for data structures. However array accessors have an interesting property and that is to permit you to modify an array from a {}script function{} or {}method{} without having to copy it. When you pass an array into a function, it is&nbsp;{}passed by reference{}, meaning that the array itself isn't being given into the script but rather it is simply being referenced to get the data. Normally if you then need to change the array, it would be {}copied {}to the script and then you would need to pass back (return) the copied array for the original array to be updated. This can have costly processing overheads, and so you can use the accessor instead, as that will change the original array {}directly {}without the need for it to be copied. You can see how this works in the examples below.":"数组也有自己的访问器，其工作方式与上面列出的数据结构的访问器类似。然而，数组访问器有一个有趣的属性，那就是允许你从{}脚本函数{}或{}方法{}中修改一个数组，而不需要复制它。当你把一个数组传递到一个函数中时，它是{}通过引用{}传递的，这意味着数组本身并没有被赋予到脚本中，而只是被引用来获取数据。通常情况下，如果你需要改变这个数组，它将被{}复制{}到脚本中，然后你需要将复制的数组传回(返回)，以更新原始数组。这可能会产生昂贵的处理开销，所以你可以使用访问器来代替，因为这将直接改变原始数组{}{}，而不需要复制它。你可以在下面的例子中看到这是如何工作的。","As with getting a value, you supply the name of the variable to set as a string, and it will be set to the value given. If the variable name used doesn't exist in the struct, then it will be created and set to the given value.":"与获取值一样，提供要设置为字符串的变量的名称，并将其设置为给定的值。如果结构中不存在使用的变量名称，则将创建该变量名称并将其设置为给定值。","As you can see, you don't supply the variable itself, but rather a {}string{} with the variable's name.":"如您所见，您并没有提供变量本身，而是提供了一个带有变量名称的{}字符串{}。","As you can see, you don't supply the variable itself, but rather a {}string{} with the variable. Note that if the struct does not have a variable with the given name, then the accessor will return {}undefined{} as the value.":"正如你所看到的，你并没有提供变量本身，而是提供了一个带有该变量的{}字符串{}。注意，如果结构中没有给定名称的变量，那么访问器将返回{}undefined{}作为值。","However, the second example is better as it works without the unnecessary overhead of copying the entire array first.":"但是，第二个示例更好，因为它没有先复制整个数组的不必要开销。","However, you can do the same thing using chained accessors in a much cleaner way that uses less code:":"但是，你可以用更简洁的方式使用链式访问器做同样的事情，使用更少的代码：","In the above code we've created a 3 item array and assigned a DS list to each of them, and then we've populated the different lists with the instance IDs of various objects in the game. Now, to access an ID in one of the lists we can do the following:":"在上面的代码中，我们已经创建了一个3项数组，并为每个数组分配了一个DS list，然后我们用游戏中各种对象的实例ID填充了不同的列表。现在，为了访问其中一个列表中的ID，我们可以做以下工作。",'It is worth noting that when using accessors in this way, you should always use the {}@{} accessor for arrays, as otherwise you will be adding extra overhead to any actions being performed. As mentioned above, by default arrays are passed by reference into functions and then use the "copy on write" behavior when modified. However, if the array is part of a chain, then the previous item in the chain will be updated with the copied array and the "original" will be deleted. For example, doing something like this:':'值得注意的是，当以这种方式使用访问器时，你应该始终使用{}@{}访问器来访问数组，否则你将为正在执行的任何操作增加额外的开销。如上所述，默认情况下，数组是通过引用传入函数的，然后在修改时使用 "写时复制 "行为。然而，如果数组是一个链的一部分，那么链中的前一个项目将用复制的数组进行更新，而 "原始 "将被删除。例如，做这样的事情。','It is worth noting that when using accessors in this way, you should always use the {}@{} accessor for arrays, as otherwise you will be adding extra overhead to any actions being performed. As mentioned above, by default arrays are passed by reference into functions and then use the "copy on write" behaviour when modified. However, if the array is part of a chain, then the previous item in the chain will be updated with the copied array and the "original" will be deleted. For example, doing something like this:':'值得注意的是，当以这种方式使用访问器时，您应该始终对数组使用{}@{}访问器，否则您将为正在执行的任何操作添加额外的开销。如上所述，默认情况下，数组通过引用传递到函数中，然后在修改时使用"写时复制"行为。但是，如果数组是链的一部分，则链中的前一项将使用复制的数组进行更新，并且"原始"项将被删除。例如，做这样的事情：',"Note that if the map already contains the same key value as you are trying to add, it will not create a duplicate key with the new value, but rather the previous value will be replaced.":"请注意，如果映射已包含与您尝试添加的关键字值相同的关键字值，则不会使用新值创建重复的关键字，而是会替换先前的值。","Note that if you are using an expression to add a reference to an index that already has a value, the previous value will be replaced rather than have a further index added to the list. To add further entries you would need to know the DS list size and add them to the end. It is also worth noting that you can set a list index that is&nbsp;{}greater{}&nbsp;than the size of the list being referenced, and this will set that value, expanding the list at the same time and initialising all the positions in the list up to the given index to 0.":"请注意，如果您使用表达式向已经有值的索引添加引用，则先前的值将被替换，而不是向列表中添加进一步的索引。要添加更多的条目，您需要知道DS列表的大小并将它们添加到末尾。同样值得注意的是，你可以设置一个列表索引，它比被引用的列表的大小{}大{}，这将设置该值，同时扩展列表并将列表中的所有位置初始化为0。","Note that if you are using an expression to add a reference to an index that already has a value, the previous value will be replaced rather than have a further index added to the list. To add further entries you would need to know the ds_list size and add them to the end. It is also worth noting that you can set a list index that is&nbsp;{}greater{}&nbsp;than the size of the list being referenced, and this will set that value, expanding the list at the same time and initialising all the positions in the list up to the given index as 0.":"注意，如果你使用表达式向已经有一个值的索引添加引用，先前的值将被替换，而不是向列表中添加更多的索引。要增加更多的条目，你需要知道ds_list的大小，并把它们加到最后。同样值得注意的是，你可以设置一个比被引用的列表大小{}大{}的列表索引，这将设置该值，同时扩展列表，并将列表中直到给定索引的所有位置初始化为0。","Of course, the {}@{} accessor is not required when {}Copy on Write{} is disabled.":'当然，如果禁用了{}"写入时复制"{}，则不需要{}@{}访问器。',"Once you have created your grid structure and filled it with data, to get values from a specific grid position you would have something like:":"创建网格结构并使用数据填充之后，要从特定网格位置获取值，可能需要类似以下内容：","Once you have created your list structure and filled it with data, to get values from the list you would have something like:":"创建列表结构并使用数据填充后，要从列表中获取值，可能需要类似以下内容：","Once you have created your map structure and filled it with data, to get values from a specific map key you would have something like this:":"创建地图结构并使用数据填充之后，要从特定的映射键获取值，可能会出现以下情况：",'So when you have used&nbsp;{}ds_list_create(){}&nbsp;to create your list, you would use the list index (that you have stored in a variable) to reference it, with the "index" value being the position in the list to set or add. For example, the following code creates a list and then adds 10 entries, setting each entry to random number from 0 to 9:':'因此，当你使用{}ds_list_create(){}来创建你的列表时，你将使用列表的索引(你已经存储在一个变量中)来引用它，"索引 "值是要设置或添加的列表中的位置。例如，下面的代码创建了一个列表，然后添加了10个条目，将每个条目设置为0到9的随机数。',"So when you have used&nbsp;{}{}ds_list_create{}{}&nbsp;to create your list, you would use the list index (that you have stored in a variable) to reference it, with the {}index{} value being the position in the list to set or add. For example, the following code creates a list and then adds 10 entries, setting each entry to random number from 0 to 9:":"因此，当你使用{}{}ds_list_create{}{}创建列表时，你将使用列表索引(你已经存储在变量中)来引用它，{}index{}值是列表中要设置或添加的位置。例如，下面的代码创建一个列表，然后添加10个条目，将每个条目设置为从0到9的随机数：","The GameMaker Language (GML) also permits you to access certain {}Data Structures{}&nbsp;and {}Arrays{} through the use of logical expressions called {}accessors{}. This is structured in a similar way as when you are normally working with an&nbsp;array, only we use an {}identifier symbol{} before the first argument to tell {}GameMaker{} that you are working on a (previously created) data structure or the array literal.":"GameMaker语言(GML )还允许您通过使用称为{}访问器{}的逻辑表达式来访问某些{}数据结构{}和{}数组{}。这与您通常使用数组时的结构相似，只是在第一个参数之前使用了{}标识符号{}来告诉{}GameMaker{}您正在使用(以前创建的)数据结构或数组文本。","The above will get the value from position 5 (the sixth index, since lists start at 0) and store it in a variable. If you supply a position that is outside of the list size then the value {}undefined{} will be returned, which you can check for using the function {}{}is_undefined(){}{}.":"以上将从位置5(第六个索引，因为列表从0开始)获取数值，并将其存储在一个变量中。如果你提供的位置超出了列表的大小，那么将返回{}undefined{}值，你可以使用函数{}{}is_undefined(){}{}来检查。","The above will get the value from position 5 (the sixth index, since lists start at 0) and store it in a variable. If you supply a position that is outside of the list size then the value {}undefined{}&nbsp;will be returned, which you can check for using the function {}{}is_undefined{}{}.":"上面的代码将从位置5(第六个索引，因为列表从0开始)获取值并将其存储在变量中。如果您提供的位置超出列表大小，则将返回值{}undefined{}，您可以使用函数{}{}is_undefined{}{}检查。",'The above will get the value from the given DS grid based on the mouse position (divided by the "cell" width in the room to get the correct location). If you supply a position that is outside of the grid boundaries then the value {}undefined{} will be returned, which you can check for using the function {}{}is_undefined{}{}.':'上面的代码将根据鼠标位置从给定的DS网格中获取值(除以房间中的"单元格"宽度以获得正确的位置)。如果您提供的位置在网格边界之外，则将返回值{}undefined{}，您可以使用函数{}{}is_undefined{}{}检查。','The above will get the value from the given ds_grid based on the mouse position (divided by the "cell" width in the room to get the correct location). If you supply a position that is outside of the grid boundaries then the value {}undefined{} will be returned, which you can check for using the function {}{}is_undefined(){}{}.':'以上将从给定的ds_grid中获得基于鼠标位置的值(除以房间中的 "单元格 "宽度以获得正确的位置)。如果你提供的位置在网格边界之外，那么将返回{}undefined{}值，你可以使用函数{}{}is_undefined(){}{}检查。','The above will get the value from the key "Name" and store it in a variable, but be aware that if the given key does not exist in the DS map, then the value returned will be {}undefined{}. This can be checked for using the function {}{}is_undefined(){}{}.':'以上将从键 "Name "中获取数值并存储在一个变量中，但是要注意，如果给定的键在DS 映射中不存在，那么返回的数值将是{}undefined{}。这可以用函数{}{}is_undefined(){}{}来检查。','The above will get the value from the key {}"Name"{} and store it in a variable, but be aware that if the given key does not exist in the DS map, then the value returned will be {}undefined{}. This can be checked for using the function {}{}is_undefined{}{}.':'上面的代码将从键{}"Name"{}中获取值并将其存储在变量中，但要注意，如果给定的键在DS映射中不存在，则返回的值将是{}undefined{}。这可以使用函数{}{}is_undefined{}{}进行检查。',"The accessor for&nbsp;{}DS Maps{} is {}{}{}?{}&nbsp;and the syntax&nbsp;is:&nbsp;":"{}DS Maps{}的访问器是{}?{}，语法为：","The function itself would have something like this:":"函数本身具有如下内容：","The syntax for arrays, using the {}@{} accessor, is:":"使用{}@{}访问器的数组的语法为：","The syntax for {}DS grid{}&nbsp;is:":"{}DS grid{} (数据结构网格) 语法为：","The syntax for {}DS lists{}&nbsp;is:":"{}DS lists{} (数据结构列表) 语法为：","The syntax for {}DS maps{}&nbsp;is:":"{}DS maps{} (数据结构映射) 语法为:","The syntax for&nbsp;{}DS Grids{}&nbsp;is:":"{}DS网格{}的语法为：",'This accessor is essentially a wrapper for the functions&nbsp;{}{}{}variable_struct_get(){}{} and {}{}variable_struct_set(){}{}, and you would use it much like the accessor for a DS map.&nbsp;For example, if you have created a struct and want to retrieve a value from a variable called "my_health" then you\'d do:{}':'此访问器实质上是函数{}{}{}variable_struct_get(){}{}和{}{}variable_struct_set(){}{}的包装程序，您可以使用它，就像DS map的访问器一样。例如，如果您创建了一个结构，并希望从名为"my_health"的变量中检索一个值，则可以执行以下操作：{}',"This accessor is essentially a wrapper for the functions&nbsp;{}{}{}variable_struct_get(){}{} and {}{}variable_struct_set(){}{}, and&nbsp;{}{}variable_global_get{}{}&nbsp;and&nbsp;{}{}variable_global_set{}{}&nbsp;if you access {}The Global Struct{}&nbsp;using the {}global{} keyword.{}":"如果您使用{19}global{20}关键字访问{17}全局结构{18}，则该访问器本质上是函数{}{}{}variable_struct_get(){}{}和{}{}variable_struct_set(){}{}以及{}{}variable_global_get{}{}和{}{}variable_global_set{}{}的包装器。{}","This accessor is only used when the {}Copy on Write option{} is enabled.":"此访问器仅在启用{}写时复制选项{}时使用。","To set a variable in a struct then you would do the following":"要在结构中设置一个变量，你需要做以下工作","Using chained accessors for things not only means you can write more compact code, it will also permit you to use iteration (for example, using a {}{}for{}{}&nbsp;loop) and other techniques to access your data in a cleaner and more intuitive manner.":"对事物使用链接访问器不仅意味着您可以编写更紧凑的代码，还允许您使用迭代(例如，使用{}{}for{}{}循环)和其他技术以更干净、更直观的方式访问数据。","You can chain multiple accessors together in this way and they can be of multiple types to get access to the information stored in each part of the nested structure. Here are some more examples:":"您可以通过这种方式将多个访问器链接在一起，它们可以是多种类型的，以访问存储在嵌套结构每个部分中的信息。以下是更多示例：","achieves the same results as doing this:":"获得与以下操作相同的结果：","{}Arrays [@ ]{}{}Arrays [@ ]{}":"{}Arrays [@ ]{}{}Arrays [@ ]{} 数组","{}DS Grids [# ]{}{}DS Grids [# ]{}":"{}DS Grids [# ]{}{}DS Grids [# ]{} 网格","{}DS Lists [| ]{}{}DS Lists [| ]{}":"{}DS Lists [| ]{}{}DS Lists [| ]{} 列表","{}DS Maps [? ]{}{}DS Maps [? ]{}":"{}DS Maps [? ]{}{}DS Maps [? ]{} 映射","{}NOTE{} You cannot use the array accessor {}@{}&nbsp; when working with the&nbsp;{}argument[n]{}&nbsp;array in&nbsp;script functions.":"{}注意{}在脚本函数中使用{} argument[n]{}数组时，不能使用数组访问器{}@{}。","{}Structs [$ ]{}{}Structs [$ ]{}":"{}Structs [$ ]{}{}Structs [$ ]{} 结构","{}The struct accessor uses the {}{}{}${} sign as the identifier symbol. This makes the accessor syntax for {}structs{}:&nbsp;{}":"{}结构访问器使用{}{}{}${}符号作为标识符号。这使得{}结构{}的访问器语法为：{}","{}The syntax for {}structs{} is{}":"{}{}结构{}的语法为:{}",'{}You would use it much like the accessor for a DS map.&nbsp;For example, if you have created a struct and want to retrieve a value from a variable called "my_health" then you\'d do:{}':'{}您可以像 DS 地图的访问器一样使用它。例如，如果您创建了一个结构体并希望从名为"my_health"的变量中检索值，那么您可以执行以下操作：{}',"{}{}NOTE{}{}&nbsp;If the map already contains the same key value as you are trying to add, it will not create a duplicate key with the new value, but rather the previous value will be replaced.":"{}{}注意{}{}如果映射已经包含与您尝试添加的键值相同的键值，则不会使用新值创建重复的键值，而是会替换先前的值。","{}{}NOTE{}{}&nbsp;If the struct does not have a variable with the given name, then the accessor will return {}undefined{} as the value.":"{}{}注意{}{} 如果结构没有具有给定名称的变量，则访问器将返回 {}undefined{} 作为值。","{}{}NOTE{}{}&nbsp;You cannot use the array accessor {}@{}&nbsp; when working with the&nbsp;{}argument[n]{}&nbsp;array in&nbsp;script functions.":"{}{}注意{}{}在脚本函数中使用{}参数[n]{}数组时，不能使用数组访问器{}@{}。",'{}{}TIP{}{}&nbsp;In case a value returned by the accessor is (or might be)&nbsp;{}undefined{}&nbsp;you might want to provide a "default" value to be used instead. A clean, shorthand way to do this is the&nbsp;{}nullish{}&nbsp;operator.':'{}{}提示{}{} 如果访问器返回的值是(或可能是) {}undefined{} ，您可能希望提供要使用的"默认"值。要做到这一点，一种简单快捷的方法是{}空值{}运算符。',"{}{}TIP{}{}&nbsp;The key isn't limited to strings and can be of any&nbsp;type, including a&nbsp;{}struct{}.":"{}{}提示{}{}键不限于字符串，可以是任何类型，包括{}struct{}。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../..",gTopicId="8.2.1.2_4"</script><script type="text/javascript" src="../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Accessors</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../assets/css/default.css" type="text/css"><script src="../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page outlining the different Accessors"><meta name="rh-index-keywords" content="Accessors"><meta name="search-keywords" content="Accessors,@,[| ],[@ ],[# ],[? ],grid accessor,list accessor,map accessor,array accessor"><meta name="brsnext" value="GameMaker_Language/GML_Overview/Language_Features.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Evaluation_Order.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Accessors"><span>Accessors</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Accessors</span></h1><p>The GameMaker Language (GML) also permits you to access certain <a href="../GML_Reference/Data_Structures/Data_Structures.htm">Data Structures</a>&nbsp;and <a href="Arrays.htm">Arrays</a> through the use of logical expressions called <b>accessors</b>. This is structured in a similar way as when you are normally working with an&nbsp;array, only we use an <em>identifier symbol</em> before the first argument to tell <span data-keyref="GameMaker Name">GameMaker</span> that you are working on a (previously created) data structure or the array literal.</p><p>&nbsp;</p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down10" href="#"><span data-open-text="true" data-skip-index="true">DS Lists [| ]</span><span data-close-text="true">DS Lists [| ]</span></a></p><div class="droptext" data-targetname="drop-down10"><p class="dropspot">The syntax for <a href="../GML_Reference/Data_Structures/DS_Lists/DS_Lists.htm">DS lists</a>&nbsp;is:</p><p class="code">list_index[| index]</p><p class="dropspot">So when you have used&nbsp;<span class="inline3_func"><a href="../GML_Reference/Data_Structures/DS_Lists/ds_list_create.htm">ds_list_create</a></span>&nbsp;to create your list, you would use the list index (that you have stored in a variable) to reference it, with the <span class="inline2">index</span> value being the position in the list to set or add. For example, the following code creates a list and then adds 10 entries, setting each entry to random number from 0 to 9:</p><p class="code">ds = ds_list_create();<br>var index = 0;<br>repeat(10)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;ds[| index++] = irandom(9);<br>}</p><p class="dropspot">Note that if you are using an expression to add a reference to an index that already has a value, the previous value will be replaced rather than have a further index added to the list. To add further entries you would need to know the DS list size and add them to the end. It is also worth noting that you can set a list index that is&nbsp;<i>greater</i>&nbsp;than the size of the list being referenced, and this will set that value, expanding the list at the same time and initialising all the positions in the list up to the given index to 0.</p><p class="dropspot">Once you have created your list structure and filled it with data, to get values from the list you would have something like:</p><p class="code">value = ds[| 5];</p><p class="dropspot">The above will get the value from position 5 (the sixth index, since lists start at 0) and store it in a variable. If you supply a position that is outside of the list size then the value <span class="inline2">undefined</span>&nbsp;will be returned, which you can check for using the function <span class="inline3_func"><a href="../GML_Reference/Variable_Functions/is_undefined.htm#h">is_undefined</a></span>.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down13" href="#"><span data-open-text="true" data-skip-index="true">DS Maps [? ]</span><span data-close-text="true">DS Maps [? ]</span></a></p><div class="droptext" data-targetname="drop-down13"><p class="dropspot">The accessor for&nbsp;<a href="../GML_Reference/Data_Structures/DS_Maps/DS_Maps.htm">DS Maps</a> is<span class="inline2"><a id="?"></a> ?</span>&nbsp;and the syntax&nbsp;is:&nbsp;</p><p class="code">map_index[? key]</p><div data-conref="../../assets/snippets/Note_Tip_Map_Key_Can_Be_Any.hts"><p class="note"><span data-conref="../../assets/snippets/Tag_tip.hts"><span class="tip">TIP</span></span>&nbsp;The key isn't limited to strings and can be of any&nbsp;type, including a&nbsp;<a href="Structs.htm#struct">struct</a>.</p></div><p class="dropspot">After creating your map with <span class="inline3_func"><a href="../GML_Reference/Data_Structures/DS_Maps/ds_map_create.htm#h">ds_map_create</a></span>, you would use the map index that you have stored in a variable to reference it, with the <span class="inline2">key</span> value being the map key to set or get. For example, the following code creates a map and then adds a few entries to it using this syntax:&nbsp;</p><p class="code">ds = ds_map_create();<br>ds[? "Name"] = "Hamish";<br>ds[? "Company"] = "MacSeweeny Games";<br>ds[? "Game"] = "Catch The Haggis";</p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;If the map already contains the same key value as you are trying to add, it will not create a duplicate key with the new value, but rather the previous value will be replaced.</p><p class="dropspot">Once you have created your map structure and filled it with data, to get values from a specific map key you would have something like this:</p><p class="code">value = ds[? "Name"];</p><p class="dropspot">The above will get the value from the key <span class="inline2">"Name"</span> and store it in a variable, but be aware that if the given key does not exist in the DS map, then the value returned will be <span class="inline2">undefined</span>. This can be checked for using the function <span class="inline3_func"><a href="../GML_Reference/Variable_Functions/is_undefined.htm#h">is_undefined</a></span>.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down14" href="#"><span data-open-text="true" data-skip-index="true">DS Grids [# ]</span><span data-close-text="true">DS Grids [# ]</span></a></p><div class="droptext" data-targetname="drop-down14"><p class="dropspot">The syntax for&nbsp;<a href="../GML_Reference/Data_Structures/DS_Grids/DS_Grids.htm#h">DS Grids</a>&nbsp;is:</p><p class="code">grid_index[# xpos, ypos]</p><p class="dropspot">After creating your grid with the&nbsp;<span class="inline3_func"><a href="../GML_Reference/Data_Structures/DS_Grids/ds_grid_create.htm">ds_grid_create</a></span>&nbsp;function, you would use the grid index that you have stored in a variable to reference it, with the <span class="inline2">xpos</span> and <span class="inline2">ypos</span> being the position within the grid to get or set a value. For example, the following code creates a grid, clears it to 0, then and then adds a few entries to it:</p><p class="code">ds = ds_grid_create();<br>ds_grid_clear(ds, 0);<br>var gw = ds_grid_width(ds) - 1;<br>var gh = ds_grid_height(ds) - 1;<br>repeat(10)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;var xx = irandom(gw);<br>&nbsp;&nbsp;&nbsp;&nbsp;var yy = irandom(gh);<br>&nbsp;&nbsp;&nbsp;&nbsp;if (ds[# xx, yy] == 0)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ds[# xx, yy] = 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p><p class="dropspot">Once you have created your grid structure and filled it with data, to get values from a specific grid position you would have something like:</p><p class="code">value = ds[# mouse_x div 16, mouse_y div 16];</p><p class="dropspot">The above will get the value from the given DS grid based on the mouse position (divided by the "cell" width in the room to get the correct location). If you supply a position that is outside of the grid boundaries then the value <span class="inline2">undefined</span> will be returned, which you can check for using the function <span class="inline3_func"><a href="../GML_Reference/Variable_Functions/is_undefined.htm">is_undefined</a></span>.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down15" href="#"><span data-open-text="true" data-skip-index="true">Arrays [@ ]</span><span data-close-text="true">Arrays [@ ]</span></a></p><div class="droptext" data-targetname="drop-down15"><p class="dropspot">This accessor is only used when the <a href="../../Settings/Game_Options.htm">Copy on Write option</a> is enabled.</p><p class="dropspot">Arrays also have their own accessors which works in a similar way as those listed above for data structures. However array accessors have an interesting property and that is to permit you to modify an array from a <a href="Script_Functions.htm">script function</a> or <a href="Method_Variables.htm">method</a> without having to copy it. When you pass an array into a function, it is&nbsp;<strong>passed by reference</strong>, meaning that the array itself isn't being given into the script but rather it is simply being referenced to get the data. Normally if you then need to change the array, it would be <em>copied</em> to the script and then you would need to pass back (return) the copied array for the original array to be updated. This can have costly processing overheads, and so you can use the accessor instead, as that will change the original array <em>directly</em> without the need for it to be copied. You can see how this works in the examples below.</p><p class="dropspot">The syntax for arrays, using the <span class="inline2">@</span> accessor, is:</p><p class="code">array[@ i]</p><p class="dropspot">After you have created your array in an instance, you can then pass it to a script by reference and use the accessor&nbsp;<span class="inline">@</span>&nbsp;to change it directly. For example you would create the array and call the funtion like this:</p><p class="code">array[99] = 0;<br>array_populate(array);</p><p class="dropspot">The function itself would have something like this:</p><p class="code">function array_populate(_array)<br>{<br>&nbsp; &nbsp; var a = _array; var i = 0; repeat(25)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; i = irandom(99);<br>&nbsp; &nbsp; &nbsp; &nbsp; while (a[i] != 0)<br>&nbsp; &nbsp; &nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i = irandom(99);<br>&nbsp; &nbsp; &nbsp; &nbsp; }<br>&nbsp; &nbsp; &nbsp; &nbsp; a[@ i] = 100;<br>&nbsp; &nbsp; }<br>}</p><p class="dropspot">All this function is doing is selecting 25 random positions in the array and setting the value of the chosen array position to 100.</p><p class="dropspot">Of course, the <span class="inline">@</span> accessor is not required when <strong>Copy on Write</strong> is disabled.</p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;You cannot use the array accessor <span class="inline">@</span>&nbsp; when working with the&nbsp;<span class="inline">argument[n]</span>&nbsp;array in&nbsp;script functions.</p><p class="dropspot">&nbsp;</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down16" href="#"><span data-open-text="true" data-skip-index="true">Structs [$ ]</span><span data-close-text="true">Structs [$ ]</span></a></p><div class="droptext" data-targetname="drop-down16"><p class="dropspot"><span>The struct accessor uses the<span class="inline2"><a id="$"></a> $</span> sign as the identifier symbol. This makes the accessor syntax for <a href="Structs.htm">structs</a>:&nbsp;</span></p><p class="code">struct[$ "name"]</p><p class="dropspot">This accessor is essentially a wrapper for the functions&nbsp;<span><a href="../GML_Reference/Variable_Functions/variable_struct_get.htm"><span class="inline2">variable_struct_get()</span></a> and <a href="../GML_Reference/Variable_Functions/variable_struct_set.htm"><span class="inline2">variable_struct_set()</span></a>, and&nbsp;<span class="inline3_func"><a href="../GML_Reference/Variable_Functions/variable_global_get.htm">variable_global_get</a></span>&nbsp;and&nbsp;<span class="inline3_func"><a href="../GML_Reference/Variable_Functions/variable_global_set.htm">variable_global_set</a></span>&nbsp;if you access <a href="Variables/Global_Variables.htm#the_global_struct">The Global Struct</a>&nbsp;using the <span class="inline2">global</span> keyword.</span></p><p class="dropspot"><span>You would use it much like the accessor for a DS map.&nbsp;For example, if you have created a struct and want to retrieve a value from a variable called "my_health" then you'd do:</span></p><p class="code">var _hp = struct[$ "my_health"];</p><p class="dropspot">As you can see, you don't supply the variable itself, but rather a <em>string</em> with the variable's name.</p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;If the struct does not have a variable with the given name, then the accessor will return <span class="inline2">undefined</span> as the value.</p><div data-conref="../../assets/snippets/Note_tip_use_nullish_with_accessors.hts"><p class="note"><span data-conref="../../assets/snippets/Tag_tip.hts"><span class="tip">TIP</span></span>&nbsp;In case a value returned by the accessor is (or might be)&nbsp;<span class="inline2">undefined</span>&nbsp;you might want to provide a "default" value to be used instead. A clean, shorthand way to do this is the&nbsp;<a href="Expressions_And_Operators.htm#nullish">nullish</a>&nbsp;operator.</p></div><p class="dropspot">To set a variable in a struct then you would do the following</p><p class="code">struct[$ "my_score"] = 100;</p><p class="dropspot">As with getting a value, you supply the name of the variable to set as a string, and it will be set to the value given. If the variable name used doesn't exist in the struct, then it will be created and set to the given value.</p><p class="dropspot">&nbsp;</p></div><p>&nbsp;</p><p>An important feature of accessors is the fact that they can be <i>chained</i> together. This means that if you have several nested data structures and/or arrays, there is no longer the need to use a variety of functions to get access to a value that is deep within the nested structure. For example, say you have an array, and each item in the array is a DS list, like this:</p><p class="code">array = array_create(3);<br>for (var i = 0; i &lt; 3; ++i;)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;array[i] = ds_list_create();<br>&nbsp;&nbsp;&nbsp;&nbsp;switch(i)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 0:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with (obj_Wall) ds_list_add(array[i], id);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 1:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with (obj_Door) ds_list_add(array[i], id);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case 2:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;with (obj_Chest) ds_list_add(array[i], id);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p><p>In the above code we've created a 3 item array and assigned a DS list to each of them, and then we've populated the different lists with the instance IDs of various objects in the game. Now, to access an ID in one of the lists we can do the following:</p><p class="code">var _list = array[0];<br>var _id = ds_list_find_value(_list, 0);</p><p>However, you can do the same thing using chained accessors in a much cleaner way that uses less code:</p><p class="code">var _id = array[0][| 0];</p><p>You can chain multiple accessors together in this way and they can be of multiple types to get access to the information stored in each part of the nested structure. Here are some more examples:</p><p class="code">// Access a grid that has been added to a list that is part of a map:<br>var _a = data[? "lists"][| 0][# 0, 0];<br><br>// Access an array nested in a list from a script and modify it:<br>data[| 0][@ 10] = 100;<br><br>// Access a map nested in a grid nested in a list nested in an array:<br>data[0][| 10][# 3, 4][? "key"] = "hello world";</p><p>Using chained accessors for things not only means you can write more compact code, it will also permit you to use iteration (for example, using a <a href="Language_Features/for.htm"><span class="inline">for</span></a>&nbsp;loop) and other techniques to access your data in a cleaner and more intuitive manner.</p><p>It is worth noting that when using accessors in this way, you should always use the <span class="inline2">@</span> accessor for arrays, as otherwise you will be adding extra overhead to any actions being performed. As mentioned above, by default arrays are passed by reference into functions and then use the "copy on write" behaviour when modified. However, if the array is part of a chain, then the previous item in the chain will be updated with the copied array and the "original" will be deleted. For example, doing something like this:</p><p class="code">// In an object event<br>data[| 0][0] = 100;<br><br>// In a function<br>data[| 0][0] = 200;</p><p>achieves the same results as doing this:</p><p class="code">// In an object event<br>data[| 0][0] = 100;<br><br>// In a function<br>data[| 0][@ 0] = 200;</p><p>However, the second example is better as it works without the unnecessary overhead of copying the entire array first.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="GML_Overview.htm">GML&nbsp;Overview</a></div><div style="float:right">Next:&nbsp;<a href="Language_Features.htm">Language Features</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>