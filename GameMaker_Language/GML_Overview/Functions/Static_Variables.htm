<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(t){return t=(t=(t=(t=t.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(t){return t.match(/(<([^>]+)>)/gi)},setTranslator=function(t,e,a){let n;n=a?t.attr(a):t.html();let s=e[removeHtml(n)];if(null!=s&&s.length){e=retHtml(n);let i=0;e&&e.forEach(function(t,e){var a=s.replace("{"+i+"}",t);s=a===s?s.replace("{}",t):a,i++}),a?t.attr(a,s):t.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var t=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(t):($(".topic-header").append(t),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(t){return t.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"A static variable is always initialised at the top of the function,&nbsp;so no matter where you define a static variable in the function, it will always be available to be read and changed throughout the function (even if it's used before being defined). See the following example:":"静态变量总是在函数的顶部进行初始化，因此无论您在函数中的哪个位置定义静态变量，都始终可以在整个函数中读取和更改它(即使它是在定义之前使用的)。请参阅以下示例：","A static variable is always initialized at the top of the function,&nbsp;so no matter where you define a static variable in the function, it will always be available to be read and changed throughout the function (even if it's used before being defined). See the following example:":"静态变量总是在函数的顶部初始化，因此，无论你在函数的哪个位置定义静态变量，它在整个函数中都始终可供读取和更改(即使在定义之前已使用过静态变量)。参见以下示例：","A static variable is defined the first time the function is called and will maintain its value from then onward. It can only be changed inside the original function, and returning it will simply give you a copy of its value&nbsp;- essentially the shared static variable can only be changed by the function that contains it.":"静态变量在第一次调用函数时定义，并且从那时起将保持其值。它只能在原始函数内部更改，返回它只会为您提供其值的副本 - 本质上共享静态变量只能由包含它的函数更改。","Accessing Static Variables":"访问静态变量","After being called twice, the value of that variable becomes&nbsp;{}2{}, which can be read from any of its structs, or from the constructor directly by writing {}weapon.number_of_weapons{}.":"在被调用两次之后，该变量的值变成了 {}2{}，可以从它的任何结构中读取，也可以通过编写 {}weapon.number_of_weapons{} 直接从构造函数中读取。","All static variables belonging to a function are stored in a struct, which you can retrieve using {}{}static_get{}{}. You can modify the static struct of a function to change the static variables it has using&nbsp;{}{}static_set{}{}, however this function is only provided for use with structs for deserialisation purposes.":"属于一个函数的所有静态变量都存储在一个结构中，您可以使用 {}{}static_get{}{} 检索该结构。您可以使用 {}{}static_set{}{} 修改函数的静态结构以更改其拥有的静态变量，但此函数仅用于反序列化目的的结构。","All three {}show_debug_message(){} calls above would print the same value, as they are reading the exact same variable.":"上面的所有三个 {}show_debug_message(){} 调用都将打印相同的值，因为它们读取的是完全相同的变量。","An interesting feature of {}script functions{} and {}method variables{}&nbsp;is that they can have {}static variables{}.":"{}脚本函数{}和{}方法变量{}的一个有趣功能是它们可以具有{}静态变量{}。","An interesting feature of {}script functions{} and {}method variables{}&nbsp;is that they can have {}static variables{}. A static variable is one that is defined the first time that the function is called and that will maintain its value from then onward. To create a static variable you need to define it using the {}static{} keyword, as shown in this simple example:":"{}脚本函数{}和{}方法变量{}的一个有趣特征是，它们可以有{}静态变量{}。静态变量是指在函数第一次被调用时定义的变量，它将从那时起保持其数值。要创建静态变量，需要使用{}static{}关键字来定义它，如这个简单的例子所示。","Calling the {}Child(){}&nbsp;constructor prints this to the output log:":"调用{}Child(){}构造函数会将以下内容打印到输出日志：","Calling the {}child(){}&nbsp;constructor prints this to the output log:":"调用 {}child(){} 构造函数会将以下内容打印到输出日志：","For constructors, you can access static variables from the constructor function directly, or from any of the structs created from the constructor:":"对于构造函数，可以直接从构造函数访问静态变量，也可以从构造函数创建的任何结构访问静态变量：","Generally, static variables are scoped to the function you define them in. In a hierarchy of constructors, a static variable is scoped to the constructor you define it in using the {}static{} keyword:&nbsp;":"一般来说，静态变量的作用域为您定义它们的函数。在构造函数的层次结构中，静态变量的作用域为您使用{}static{}关键字定义它的构造函数：","Here the static variable {}number{} belongs to {}item{} and the static variable {}types{} belongs to {}weapon{}.":"这里，静态变量{}number{}属于{}item{}，静态变量{}types{}属于{}weapon{}。",'Here&nbsp;the static variable "{}my_health{}" is being changed and printed to the compiler output&nbsp;{}before{}&nbsp;being initialised. While that looks wrong, it is perfectly fine because static variables are initialised {}before {}any function code is executed. Note that if there are multiple static variables in a function, the order in which they were defined will be kept when they are initialised at the top.':'这里，在初始化{}之前，静态变量 "{0}my_health{1}" 被更改并打印到编译器输出{}。虽然这看起来是错误的，但它完全没有问题，因为静态变量是在{}任何函数代码执行之前{}初始化的。请注意，如果函数中有多个静态变量，则在顶部初始化它们时，它们的定义顺序将保持不变。','Here&nbsp;the static variable "{}my_health{}" is being changed and printed to the compiler output&nbsp;{}before{}&nbsp;being initialized. While that looks wrong, it is perfectly fine because static variables are initialized {}before {}any function code is executed. Note that if there are multiple static variables in a function, the order in which they were defined will be kept when they are initialized at the top.':'在这里，静态变量"{}my_health{}"在{}被初始化之前被改变并打印到编译器输出{}。虽然这看起来不对，但这是很好的，因为静态变量在执行{}任何函数代码之前就被初始化{}。注意，如果一个函数中有多个静态变量，当它们在顶部被初始化时，它们被定义的顺序将被保留。',"If you didn't use the {}static{} keyword here the output would simply be {}0{} for every iteration of the loop, since the variable {}num{}&nbsp;will be getting defined as {}0{} every time the function is called before being returned.":"如果您没有在此处使用{}static{}关键字，则循环每次迭代的输出将仅为{}0{}，因为变量{}num{}每次都会被定义为{}0{}返回函数之前调用该函数的时间。","If you didn't use the {}static{} keyword here then the output would simply be {}0{} for every iteration of the loop, since the variable {}num{}&nbsp;will be getting defined as {}0{} every time the function is called before being returned. Note that a static variable can only be changed inside the original function, and returning it will simply give you a copy of its value&nbsp;- essentially the shared static variable can only be changed by the function that contains it.":"如果此处没有使用{}static{}关键字，则循环的每次迭代的输出都将是{}0{}，因为在返回之前，每次调用函数时，变量{}num{}都将被定义为{}0{}。请注意，静态变量只能在原始函数内部进行更改，返回它将简单地为您提供其值的副本-实际上，共享的静态变量只能由包含它的函数进行更改。","In the above example, the constructor function&nbsp;{}{}Vector2{}{} can be used to create a struct, and the struct will have some variables, one of which is the method variable {}{}Add{}{}. Since this variable has been defined as static, the function it contains will only be initialized {}once {}the first time the {}Vector2{} function is called, and all further structs created with this constructor will reference the function {}Add{} that was created initially, instead of creating a new function for each struct (for more information on structs and the {}constructor{} keyword please see {}here{}).":"在上面的示例中，构造函数{}{}Vector2{}{}可以用来创建结构，并且该结构将有一些变量，其中一个是方法变量{}{}Add{}{}。由于此变量已被定义为静态变量，因此它包含的函数仅在首次调用{}Vector2{}时初始化{}一次{}，使用此构造函数创建的所有其他结构将引用最初创建的函数{}Add{}，而不是为每个结构创建一个新函数(有关结构和{}构造函数{}的更多信息，请参阅{}此处{})。","In the above example, the variable {}num{}&nbsp;is a static variable, and so will be defined as {}0{} the first time the function is called, but every time the function is called after that, the variable&nbsp;initialisation will be ignored. So, if you then call this function like this:":"上面的例子中，变量 {}num{} 是一个静态变量，所以在第一次调用函数时将被定义为 {}0{}，但之后每次调用函数时，变量的初始化都会被忽略。因此，如果你再这样调用这个函数：","In the above example, the variable {}num{}&nbsp;is a static variable, and so will be defined as {}0{} the first time the function is called, but every time the function is called after that, the variable&nbsp;initialization will be ignored. So, if you then call this function like this:":"在上面的例子中，变量{}num{}是一个静态变量，所以在第一次调用函数时将被定义为{}0{}，但之后每次调用函数时，变量的初始化都会被忽略。因此，如果你再这样调用这个函数。","In the above example, the {}constructor function{}&nbsp;{}{}Vector2{}{} can be used to create a struct, and the struct will have some variables, one of which is the method variable {}{}Add{}{}. Since this variable has been defined as static, the function it contains will only be initialised {}once {}the first time the {}Vector2{} function is called, and all further structs created with this constructor will reference the function {}Add{} that was created initially, instead of creating a new function for each struct (for more information on structs and the {}constructor{} keyword please see {}Structs &amp; Constructors{}).":"在上面的例子中，{}构造函数{}&nbsp;{}{}Vector2{}{}可以用来创建一个结构体，该结构体将有一些变量，其中一个是方法变量{}{}Add{}{}。由于这个变量被定义为静态的，它所包含的函数只会在{}第一次调用{}Vector2{}函数时被初始化{}一次，并且用这个构造函数创建的所有其他结构将引用最初创建的函数{}Add{}，而不是为每个结构创建一个新函数(有关结构和{}构造函数{}关键字的更多信息，请参阅{}结构 & 构造函数{})。","In the above example, the {}constructor function{}&nbsp;{}{}Vector2{}{} can be used to create a struct, and the struct will have some variables, one of which is the method variable {}{}Add{}{}. Since this variable has been defined as static, the function it contains will only be initialised {}once {}the first time the {}Vector2{} function is called, and all further structs created with this constructor will reference the function {}Add{} that was created initially, instead of creating a new function for each struct (for more information on structs and the {}constructor{} keyword please see {}here{}).":"在上面的示例中，{}构造函数 {}{}Vector2{}{}{}可以用来创建结构，并且该结构将有一些变量，其中一个是方法变量{}{}Add{}{}。由于此变量已被定义为静态变量，因此它包含的函数仅在首次调用{}Vector2{}时初始化{}一次{}，使用此构造函数创建的所有其他结构将引用最初创建的函数{}Add{}，而不是为每个结构创建一个新函数(有关结构和{}构造函数{}的更多信息，请参阅{}此处{})。","In the example above, the {}weapon{} constructor holds a static variable called {}number_of_weapons{}, which is shared across all of its structs. With each new call to the {}weapon{} constructor, the {}number_of_weapons{} value goes up by 1.":"在上面的示例中，{}weapons{} 构造函数包含一个名为 {}number_of_weapons{} 的静态变量，该变量在其所有结构中共享。每次新调用 {}weapons{} 构造函数时，{}number_of_weapons{} 值就会增加 1。","Initialisation Order":"初始化顺序","Inside the function, as with other variables, you should always {}define{} static variables {}before {}{}accessing{} them.":"在函数内部，与其他变量一样，在{}{}访问{}静态变量之前，您应该始终{}定义{}静态变量{}。","Just like with regular functions, you can't access a static variable from a constructor if that constructor was never called.":"就像使用常规函数一样，如果构造函数从未被调用过，则不能从该构造函数访问该静态变量。","Say, for a function called {}counter{}, you have a static variable {}count{}. You can access that by typing {}counter.count{} after its first call.":"比方说，对于一个名为 {}count{} 的函数，您有一个静态变量 {}count{}。您可以在它的第一次调用之后输入 {}counter.count{} 来访问它。","Static Methods":"静态方法","Static Struct":"静态结构","Static Variables":"静态变量","Static structs have most of their use with structs created from constructors. See:&nbsp;{}Static Struct{}":"静态结构主要用于从构造函数创建的结构。请参阅：{}静态结构{}","Static variables in constructors are only initialised once for that constructor, and {}they are not duplicated{} for each new struct made from the constructor.":"构造函数中的静态变量只为该构造函数初始化一次，并且{}不会为从该构造函数生成的每个新结构复制{}它们。","Statics in Parent-Child Constructors":"父子构造函数中的静态","Statics with Constructors":"在构造函数中使用静态变量","The first value is from the parent&nbsp;constructor, and the second is from the child&nbsp;constructor. This shows that the child's static variable {}value{} was not initialised until the parent constructor was finished, and that in each constructor the static variable was initialised before the {}show_debug_message(){} call.":"第一个值来自父构造函数，第二个值来自子构造函数。这表明，在父构造函数完成之前，子对象的静态变量{}值{}才被初始化，并且在每个构造函数中，静态变量在调用 {}show_debug_message(){} 之前被初始化。","The first value is from the parent&nbsp;constructor, and the second is from the child&nbsp;constructor. This shows that the child's static variable {}value{} was not initialised until the parent constructor was finished.":"第一个值来自父构造函数，第二个值来自子构造函数。这表明子对象的静态变量{}value{}直到父构造函数完成后才初始化。","The first value is from the parent&nbsp;constructor, and the second is from the child&nbsp;constructor. This shows that the child's static variable {}value{} was not initialized until the parent constructor was finished, and that in each constructor the static variable was initialized before the {}show_debug_message(){} call.":"第一个值来自父构造函数，第二个值来自子构造函数。这表明在父构造函数完成之前未初始化孩子的静态变量{}值{}，并且在每个构造函数中，在{}show_debug_message(){}调用之前已初始化静态变量。","The output will be:":"输出将为：","This means that no matter how many structs you create from a constructor, they will all {}share the same value{} for each static variable they have.":"这意味着无论从构造函数创建多少个结构，它们都将为它们拥有的每个静态变量共享相同的值{}。","To create a static variable you need to define it using the {}static{} keyword, as shown in this simple example:":"要创建静态变量，您需要使用{}static{}关键字定义它，如以下简单示例所示：","When using inheritance with constructors, any static variables in the child constructor will only be initialised once the parent constructor has been executed, so the child constructor's static variables will not override the parent's static variables. See the following example:":"当将继承与构造函数一起使用时，子构造函数中的任何静态变量仅在父构造函数执行后才会被初始化，因此子构造函数的静态变量不会覆盖父构造函数的静态变量。请参阅以下示例：","When using inheritance with constructors, any static variables in the child constructor will only be initialised once the parent constructor has been executed. See the following example:":"当使用构造函数的继承时，子构造函数中的任何静态变量只有在父构造函数执行后才会初始化。请参见以下示例：","When using inheritance with constructors, any static variables in the child constructor will only be initialized once the parent constructor has been executed, so the child constructor's static variables will not override the parent's static variables. See the following example:":"当使用构造函数的继承性时，子构造函数中的任何静态变量只有在父构造函数被执行后才会被初始化，所以子构造函数的静态变量不会覆盖父构造函数的静态变量。请看下面的例子。","While it is possible to access a static variable before the line where it's defined (as, before running the function,&nbsp;{}GameMaker{}&nbsp;first initalises all of its static variables),&nbsp;it is recommended to follow a natural order (define first, access after):":"虽然可以在定义静态变量的行之前访问它(因为在运行函数之前，{}GameMaker{}首先初始化所有静态变量)，但建议遵循自然顺序(首先定义，之后访问)：","You can access both static variables through structs created from {}weapon{}:&nbsp;":"您可以通过从{}weapon{}创建的结构访问这两个静态变量：","You can also use static variables in&nbsp;{}constructor functions{}. These functions are used to create new structs that contain the variables defined within the function.":"还可以在{}构造函数{}中使用静态变量。这些函数用于创建包含函数中定义的变量的新结构。","You can also use the {}static{}&nbsp;keyword within a function to create a {}static function{}, which - like with variables - simply means that the function will only be defined once, which is the first time the function is called, for example:":"你也可以在一个函数中使用{}static{}关键字来创建一个{}static函数{}，这和变量一样，只是意味着该函数只被定义一次，也就是第一次调用该函数的时候，例如。","You can read a static value for a function using the {}&lt;function_name&gt;.&lt;static_variable&gt;{} syntax.":"您可以使用 {}&lt;function_name&gt;.&lt;static_variable&gt;{} 语法读取函数的静态值。","You can't access a static variable from a function that was never called, as static variables are initialised on the first call to a function. Trying to do so will give you an error and crash your game.":"您不能从从未调用过的函数访问静态变量，因为静态变量是在第一次调用函数时初始化的。尝试这样做会给你一个错误，并使你的游戏崩溃。","{}Static Variables{}":"{}静态变量{}","{}{}NOTE{}{}&nbsp;In more complex constructor hierarchies you might need to traverse the&nbsp;{}Static Chain{}.":"{}{}注意{}{}在更复杂的构造函数层次结构中，您可能需要遍历{}静态链{}。","{}{}NOTE{}{}&nbsp;{}Feather{}&nbsp;will show a GM2043 warning if you try to access a static variable before it's initialised.":"{}{}注意{}{}{}Feather{}将显示GM 2043警告，如果您尝试在静态变量初始化之前访问该变量。","{}{}WARNING{}{}&nbsp;You can't access a static variable from a function that was never called, as static variables are initialised on the first call to a function. Trying to do so will give you an error and crash your game.":"{}{}警告{}{}您无法从从未调用过的函数访问静态变量，因为静态变量是在第一次调用函数时初始化的。尝试这样做将会出现错误并导致游戏崩溃。","{}{}WARNING{}{}&nbsp;{}Static Variables{}&nbsp;cannot be declared&nbsp;outside of functions.":"{}{}警告{}{}不能在函数外部声明{}静态变量{}。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(t){json_global=t}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.1.1_8"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Static Variables</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Gurpreet S. Matharoo"><meta name="topic-comment" content="Page outlining the use of Static Variables"><meta name="rh-index-keywords" content="Static Variables"><meta name="search-keywords" content="Static Variables,static"><meta name="brsnext" value="GameMaker_Language/GML_Overview/Arrays.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Script_Functions_vs_Methods.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Static Variables"><span>Static Variables</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Static Variables</span></h1><p>An interesting feature of <a href="../Script_Functions.htm">script functions</a> and <a href="../Method_Variables.htm">method variables</a>&nbsp;is that they can have <strong>static variables</strong>.</p><p>A static variable is defined the first time the function is called and will maintain its value from then onward. It can only be changed inside the original function, and returning it will simply give you a copy of its value&nbsp;- essentially the shared static variable can only be changed by the function that contains it.</p><p class="note"><span data-conref="../../../assets/snippets/Tag_warning.hts"><span class="warning">WARNING</span></span>&nbsp;<span data-field="title" data-format="default">Static Variables</span>&nbsp;cannot be declared&nbsp;outside of functions.</p><p>To create a static variable you need to define it using the <span class="inline2">static</span> keyword, as shown in this simple example:</p><p class="code">counter = function()<br>{<br>&nbsp; &nbsp; static num = 0;<br>&nbsp; &nbsp; return num++;<br>}</p><p>In the above example, the variable <span class="inline2">num</span>&nbsp;is a static variable, and so will be defined as <span class="inline">0</span> the first time the function is called, but every time the function is called after that, the variable&nbsp;initialisation will be ignored. So, if you then call this function like this:</p><p class="code">repeat (10)<br>{<br>&nbsp; &nbsp; show_debug_message(counter());<br>}</p><p>The output will be:</p><p class="code">0<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p><p>If you didn't use the <span class="inline2">static</span> keyword here the output would simply be <span class="inline2">0</span> for every iteration of the loop, since the variable <span class="inline2">num</span>&nbsp;will be getting defined as <span class="inline2">0</span> every time the function is called before being returned.</p><h3>Initialisation Order</h3><p>When a function is called, its static variables are initialised first, before the rest of the function body is executed.</p><p>This mean it's possible to access a static variable before the line where it's defined, as it would have already been initialised, even in the first call:</p><p class="code">function static_test()<br>{<br>&nbsp;&nbsp; &nbsp;show_debug_message(static_variable);<br>&nbsp;&nbsp; &nbsp;static static_variable = 1000;<br>}</p><p>However, it is not recommended to do this, and&nbsp;<a href="../../../Setting_Up_And_Version_Information/IDE_Preferences/Feather_Settings.htm">Feather</a>&nbsp;will show a GM2043 warning if you try to access a static variable before its initialisation line.</p><p>This also means you cannot have conditionally defined static variables, as they will always exist throughout the function body. For example, if you have a static variable initialised inside an <span class="inline2">if</span> condition block, it will be initialised at the top regardless of the condition's result.</p><h2>Statics with Constructors</h2><p>You can also use static variables in&nbsp;<a href="../Structs.htm#constr">constructor functions</a>. These functions are used to create new structs that contain the variables defined within the function.</p><p>Static variables in constructors are only initialised once for that constructor, and <strong>they are not duplicated</strong> for each new struct made from the constructor.</p><p>This means that no matter how many structs you create from a constructor, they will all <strong>share the same value</strong> for each static variable they have.</p><p class="code">function weapon() constructor<br>{<br>&nbsp;&nbsp; &nbsp;static number_of_weapons = 0;<br>&nbsp;&nbsp; &nbsp;number_of_weapons++;<br>}<br><br>var _weapon1 = new weapon();<br>var _weapon2 = new weapon();<br><br>show_debug_message(_weapon1.number_of_weapons); // Prints 2</p><p>In the example above, the <span class="inline2">weapon</span> constructor holds a static variable called <span class="inline2">number_of_weapons</span>, which is shared across all of its structs. With each new call to the <span class="inline2">weapon</span> constructor, the <span class="inline2">number_of_weapons</span> value goes up by 1.</p><p>After being called twice, the value of that variable becomes&nbsp;<span class="inline2">2</span>, which can be read from any of its structs, or from the constructor directly by writing <span class="inline2">weapon.number_of_weapons</span>.</p><h3>Statics in Parent-Child Constructors</h3><p>Generally, static variables are scoped to the function you define them in. In a hierarchy of constructors, a static variable is scoped to the constructor you define it in using the <span class="inline2">static</span> keyword:&nbsp;</p><p class="code">function item() constructor<br>{<br>&nbsp; &nbsp; static number = 0;<br>}<br>function weapon() : item() constructor<br>{<br>&nbsp; &nbsp; static types = ["sword", "bow", "hammer"];<br>}<br><br>my_weapon = new weapon();</p><p>Here the static variable <span class="inline2">number</span> belongs to <span class="inline2">item</span> and the static variable <span class="inline2">types</span> belongs to <span class="inline2">weapon</span>.</p><p>You can access both static variables through structs created from <span class="inline2">weapon</span>:&nbsp;</p><p class="code">show_debug_message(my_weapon.number); // 0<br>show_debug_message(my_weapon.types);&nbsp; // ["sword", "bow", "hammer"]</p><p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;In more complex constructor hierarchies you might need to traverse the&nbsp;<a href="../Structs/Static_Structs.htm#h">Static Chain</a>.</p><h3>Initialisation Order</h3><p>When using inheritance with constructors, any static variables in the child constructor will only be initialised once the parent constructor function has been completely executed. See the following example:</p><p class="code">function parent() constructor<br>{<br>&nbsp; &nbsp;&nbsp;static value = 10;<br>&nbsp;&nbsp; &nbsp;show_debug_message(value);<br>}<br><br>function child() : parent() constructor<br>{<br>&nbsp; &nbsp;&nbsp;static value = 20;<br>&nbsp;&nbsp; &nbsp;show_debug_message(value);<br>}<br><br>var _child = new child();</p><p>Calling the <span class="inline2">child()</span>&nbsp;constructor prints this to the output log:</p><p class="code">10<br>20</p><p>The first value is from the parent&nbsp;constructor, and the second is from the child&nbsp;constructor. This shows that the child's static variable <span class="inline2">value</span> was not initialised until the parent constructor was finished.</p><h2>Accessing Static Variables</h2><p>You can read a static value for a function using the <span class="inline2">&lt;function_name&gt;.&lt;static_variable&gt;</span> syntax.</p><p>Say, for a function called <span class="inline2">counter</span>, you have a static variable <span class="inline2">count</span>. You can access that by typing <span class="inline2">counter.count</span> after its first call.</p><p class="code">function counter() {<br>&nbsp;&nbsp; &nbsp;static count = 0;<br>&nbsp;&nbsp; &nbsp;return count ++;<br>}<br><br>repeat (10)&nbsp;<br>{<br>&nbsp;&nbsp; &nbsp;counter()<br>}<br><br>show_debug_message(counter.count);</p><div data-conref="../../../assets/snippets/Note_Warning_Static_Struct_Call_Once.hts"><p class="note"><span data-conref="../../../assets/snippets/Tag_warning.hts"><span class="warning">WARNING</span></span>&nbsp;You can't access a static variable from a function that was never called, as static variables are initialised on the first call to a function. Trying to do so will give you an error and crash your game.</p></div><p>For constructors, you can access static variables from the constructor function directly, or from any of the structs created from the constructor:</p><p class="code">function weapon() constructor<br>{<br>&nbsp;&nbsp; &nbsp;static number_of_weapons = 0;<br>&nbsp;&nbsp; &nbsp;number_of_weapons ++;<br>}<br><br>var _weapon1 = new weapon();<br>var _weapon2 = new weapon();<br><br>show_debug_message(weapon.number_of_weapons); &nbsp; // Accessing from constructor directly<br>show_debug_message(_weapon1.number_of_weapons); // Accessing from a struct<br>show_debug_message(_weapon2.number_of_weapons); // Accessing from a struct</p><p>All three <span class="inline2">show_debug_message()</span> calls above would print the same value, as they are reading the exact same variable.</p><p>Just like with regular functions, you can't access a static variable from a constructor if that constructor was never called.</p><h3>Static Struct</h3><p>All static variables belonging to a function are stored in a struct, which you can retrieve using <span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/static_get.htm">static_get</a></span>. You can modify the static struct of a function to change the static variables it has using&nbsp;<span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/static_set.htm">static_set</a></span>, however this function is only provided for use with structs for deserialisation purposes.</p><p>Static structs have most of their use with structs created from constructors. See:&nbsp;<a href="../Structs/Static_Structs.htm">Static Struct</a></p><h2>Static Methods</h2><p>You can also use the <span class="inline">static</span>&nbsp;keyword within a function to create a <strong>static function</strong>, which - like with variables - simply means that the function will only be defined once, which is the first time the function is called, for example:</p><p class="code">function(_x, _y) Vector2 constructor<br>{<br>&nbsp; &nbsp; x = _x;<br>&nbsp; &nbsp; y = _y;<br><br>&nbsp; &nbsp; static Add = function( _other )<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; x += _other.x;<br>&nbsp; &nbsp; &nbsp; &nbsp; y += _other.y;<br>&nbsp; &nbsp; }<br>}</p><p>In the above example, the <a href="../Structs.htm#constr">constructor function</a>&nbsp;<span class="inline"><span class="inline">Vector2</span></span> can be used to create a struct, and the struct will have some variables, one of which is the method variable <span class="inline"><span class="inline">Add</span></span>. Since this variable has been defined as static, the function it contains will only be initialised <em>once</em> the first time the <span class="inline">Vector2</span> function is called, and all further structs created with this constructor will reference the function <span class="inline">Add</span> that was created initially, instead of creating a new function for each struct (for more information on structs and the <span class="inline">constructor</span> keyword please see <a href="../Structs.htm">Structs &amp; Constructors</a>).</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../GML_Overview.htm">GML&nbsp;Overview</a></div><div style="float:right">Next:&nbsp;<a href="../Arrays.htm">Arrays</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>