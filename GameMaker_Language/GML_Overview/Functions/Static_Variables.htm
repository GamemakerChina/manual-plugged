<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(t){return t=(t=(t=(t=t.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(t){return t.match(/(<([^>]+)>)/gi)},setTranslator=function(t,n,a){let e;e=a?t.attr(a):t.html();let l=n[removeHtml(e)];if(null!=l&&l.length){n=retHtml(e);let o=0;n&&n.forEach(function(t,n){var a=l.replace("{"+o+"}",t);l=a===l?l.replace("{}",t):a,o++}),a?t.attr(a,l):t.html(l)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){$(".header").length&&$(".header").append(`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`)},removeExtensionFromHash=function(t){return t.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")},$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption,blockquote").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption,.expandtext").each(function(){setTranslator($(this),json)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.1.1_8"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Static Variables</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Gurpreet S. Matharoo"><meta name="topic-comment" content="Page outlining the use of Static Variables"><meta name="rh-index-keywords" content="Static Variables"><meta name="search-keywords" content="Static Variables,static"><meta name="brsnext" value="GameMaker_Language/GML_Overview/Arrays.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Script_Functions_vs_Methods.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Static Variables"><span>Static Variables</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Static Variables</span></h1><p>An interesting feature of <a href="../Script_Functions.htm">script functions</a> and <a href="../Method_Variables.htm">method variables</a>&nbsp;is that they can have <strong>static variables</strong>.</p><p>A static variable is defined the first time the function is called and will maintain its value from then onward. It can only be changed inside the original function, and returning it will simply give you a copy of its value&nbsp;- essentially the shared static variable can only be changed by the function that contains it.</p><p class="note"><span data-conref="../../../assets/snippets/Tag_warning.hts"><span class="warning">WARNING</span></span>&nbsp;<span data-field="title" data-format="default">Static Variables</span>&nbsp;cannot be declared&nbsp;outside of functions.</p><p>To create a static variable you need to define it using the <span class="inline2">static</span> keyword, as shown in this simple example:</p><p class="code">counter = function()<br>{<br>&nbsp; &nbsp; static num = 0;<br>&nbsp; &nbsp; return num++;<br>}</p><p>In the above example, the variable <span class="inline2">num</span>&nbsp;is a static variable, and so will be defined as <span class="inline">0</span> the first time the function is called, but every time the function is called after that, the variable&nbsp;initialisation will be ignored. So, if you then call this function like this:</p><p class="code">repeat (10)<br>{<br>&nbsp; &nbsp; show_debug_message(counter());<br>}</p><p>The output will be:</p><p class="code">0<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9</p><p>If you didn't use the <span class="inline2">static</span> keyword here the output would simply be <span class="inline2">0</span> for every iteration of the loop, since the variable <span class="inline2">num</span>&nbsp;will be getting defined as <span class="inline2">0</span> every time the function is called before being returned.</p><h3>Initialisation Order</h3><p>When a function is called, its static variables are initialised first, before the rest of the function body is executed.</p><p>This mean it's possible to access a static variable before the line where it's defined, as it would have already been initialised, even in the first call:</p><p class="code">function static_test()<br>{<br>&nbsp;&nbsp; &nbsp;show_debug_message(static_variable);<br>&nbsp;&nbsp; &nbsp;static static_variable = 1000;<br>}</p><p>However, it is not recommended to do this, and&nbsp;<a href="../../../Setting_Up_And_Version_Information/IDE_Preferences/Feather_Settings.htm">Feather</a>&nbsp;will show a GM2043 warning if you try to access a static variable before its initialisation line.</p><p>This also means you cannot have conditionally defined static variables, as they will always exist throughout the function body. For example, if you have a static variable initialised inside an <span class="inline2">if</span> condition block, it will be initialised at the top regardless of the condition's result.</p><h2>Statics with Constructors</h2><p>You can also use static variables in&nbsp;<a href="../Structs.htm#constr">constructor functions</a>. These functions are used to create new structs that contain the variables defined within the function.</p><p>Static variables in constructors are only initialised once for that constructor, and <strong>they are not duplicated</strong> for each new struct made from the constructor.</p><p>This means that no matter how many structs you create from a constructor, they will all <strong>share the same value</strong> for each static variable they have.</p><p class="code">function weapon() constructor<br>{<br>&nbsp;&nbsp; &nbsp;static number_of_weapons = 0;<br>&nbsp;&nbsp; &nbsp;number_of_weapons++;<br>}<br><br>var _weapon1 = new weapon();<br>var _weapon2 = new weapon();<br><br>show_debug_message(_weapon1.number_of_weapons); // Prints 2</p><p>In the example above, the <span class="inline2">weapon</span> constructor holds a static variable called <span class="inline2">number_of_weapons</span>, which is shared across all of its structs. With each new call to the <span class="inline2">weapon</span> constructor, the <span class="inline2">number_of_weapons</span> value goes up by 1.</p><p>After being called twice, the value of that variable becomes&nbsp;<span class="inline2">2</span>, which can be read from any of its structs, or from the constructor directly by writing <span class="inline2">weapon.number_of_weapons</span>.</p><h3>Statics in Parent-Child Constructors</h3><p>Generally, static variables are scoped to the function you define them in. In a hierarchy of constructors, a static variable is scoped to the constructor you define it in using the <span class="inline2">static</span> keyword:&nbsp;</p><p class="code">function item() constructor<br>{<br>&nbsp; &nbsp; static number = 0;<br>}<br>function weapon() : item() constructor<br>{<br>&nbsp; &nbsp; static types = ["sword", "bow", "hammer"];<br>}<br><br>my_weapon = new weapon();</p><p>Here the static variable <span class="inline2">number</span> belongs to <span class="inline2">item</span> and the static variable <span class="inline2">types</span> belongs to <span class="inline2">weapon</span>.</p><p>You can access both static variables through structs created from <span class="inline2">weapon</span>:&nbsp;</p><p class="code">show_debug_message(my_weapon.number); // 0<br>show_debug_message(my_weapon.types);&nbsp; // ["sword", "bow", "hammer"]</p><p class="note"><span data-conref="../../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;In more complex constructor hierarchies you might need to traverse the&nbsp;<a href="../Structs/Static_Structs.htm#h">Static Chain</a>.</p><h3>Initialisation Order</h3><p>When using inheritance with constructors, any static variables in the child constructor will only be initialised once the parent constructor function has been completely executed. See the following example:</p><p class="code">function parent() constructor<br>{<br>&nbsp; &nbsp;&nbsp;static value = 10;<br>&nbsp;&nbsp; &nbsp;show_debug_message(value);<br>}<br><br>function child() : parent() constructor<br>{<br>&nbsp; &nbsp;&nbsp;static value = 20;<br>&nbsp;&nbsp; &nbsp;show_debug_message(value);<br>}<br><br>var _child = new child();</p><p>Calling the <span class="inline2">child()</span>&nbsp;constructor prints this to the output log:</p><p class="code">10<br>20</p><p>The first value is from the parent&nbsp;constructor, and the second is from the child&nbsp;constructor. This shows that the child's static variable <span class="inline2">value</span> was not initialised until the parent constructor was finished.</p><h2>Accessing Static Variables</h2><p>You can read a static value for a function using the <span class="inline2">&lt;function_name&gt;.&lt;static_variable&gt;</span> syntax.</p><p>Say, for a function called <span class="inline2">counter</span>, you have a static variable <span class="inline2">count</span>. You can access that by typing <span class="inline2">counter.count</span> after its first call.</p><p class="code">function counter() {<br>&nbsp;&nbsp; &nbsp;static count = 0;<br>&nbsp;&nbsp; &nbsp;return count ++;<br>}<br><br>repeat (10)&nbsp;<br>{<br>&nbsp;&nbsp; &nbsp;counter()<br>}<br><br>show_debug_message(counter.count);</p><div data-conref="../../../assets/snippets/Note_Warning_Static_Struct_Call_Once.hts"><p class="note"><span data-conref="../../../assets/snippets/Tag_warning.hts"><span class="warning">WARNING</span></span>&nbsp;You can't access a static variable from a function that was never called, as static variables are initialised on the first call to a function. Trying to do so will give you an error and crash your game.</p></div><p>For constructors, you can access static variables from the constructor function directly, or from any of the structs created from the constructor:</p><p class="code">function weapon() constructor<br>{<br>&nbsp;&nbsp; &nbsp;static number_of_weapons = 0;<br>&nbsp;&nbsp; &nbsp;number_of_weapons ++;<br>}<br><br>var _weapon1 = new weapon();<br>var _weapon2 = new weapon();<br><br>show_debug_message(weapon.number_of_weapons); &nbsp; // Accessing from constructor directly<br>show_debug_message(_weapon1.number_of_weapons); // Accessing from a struct<br>show_debug_message(_weapon2.number_of_weapons); // Accessing from a struct</p><p>All three <span class="inline2">show_debug_message()</span> calls above would print the same value, as they are reading the exact same variable.</p><p>Just like with regular functions, you can't access a static variable from a constructor if that constructor was never called.</p><h3>Static Struct</h3><p>All static variables belonging to a function are stored in a struct, which you can retrieve using <span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/static_get.htm">static_get</a></span>. You can modify the static struct of a function to change the static variables it has using&nbsp;<span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/static_set.htm">static_set</a></span>, however this function is only provided for use with structs for deserialisation purposes.</p><p>Static structs have most of their use with structs created from constructors. See:&nbsp;<a href="../Structs/Static_Structs.htm">Static Struct</a></p><h2>Static Methods</h2><p>You can also use the <span class="inline">static</span>&nbsp;keyword within a function to create a <strong>static function</strong>, which - like with variables - simply means that the function will only be defined once, which is the first time the function is called, for example:</p><p class="code">function(_x, _y) Vector2 constructor<br>{<br>&nbsp; &nbsp; x = _x;<br>&nbsp; &nbsp; y = _y;<br><br>&nbsp; &nbsp; static Add = function( _other )<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; x += _other.x;<br>&nbsp; &nbsp; &nbsp; &nbsp; y += _other.y;<br>&nbsp; &nbsp; }<br>}</p><p>In the above example, the <a href="../Structs.htm#constr">constructor function</a>&nbsp;<span class="inline"><span class="inline">Vector2</span></span> can be used to create a struct, and the struct will have some variables, one of which is the method variable <span class="inline"><span class="inline">Add</span></span>. Since this variable has been defined as static, the function it contains will only be initialised <em>once</em> the first time the <span class="inline">Vector2</span> function is called, and all further structs created with this constructor will reference the function <span class="inline">Add</span> that was created initially, instead of creating a new function for each struct (for more information on structs and the <span class="inline">constructor</span> keyword please see <a href="../Structs.htm">Structs &amp; Constructors</a>).</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../GML_Overview.htm">GML&nbsp;Overview</a></div><div style="float:right">Next:&nbsp;<a href="../Arrays.htm">Arrays</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>