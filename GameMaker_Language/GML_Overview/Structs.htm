<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../assets/import/main.css"><script>let str;removeHtml=function(t){return t=(t=(t=(t=t.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(t){return t.match(/(<([^>]+)>)/gi)},setTranslator=function(t,e,a){let s;s=a?t.attr(a):t.html();let o=e[removeHtml(s)];if(null!=o&&o.length){e=retHtml(s);let n=0;e&&e.forEach(function(t,e){var a=o.replace("{"+n+"}",t);o=a===o?o.replace("{}",t):a,n++}),a?t.attr(a,o):t.html(o)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var t=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(t):($(".topic-header").append(t),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(t){return t.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"A last way to access data in a struct is by using the struct accessor {}{}${}{}. This allows access to struct variables using strings, for both reading:&nbsp;":"访问结构中数据的最后一种方法是使用结构访问器 {}{}${}{}。这允许使用字符串访问结构变量，用于读取：","A struct is created by calling a constructor function using the&nbsp;{}{}new{}{}&nbsp;operator, by creating a struct literal {}{}{}&nbsp;or returned by some function. An instance, on the other hand, is created from an object using&nbsp;{}{}instance_create_depth{}{}&nbsp;or&nbsp;{}{}instance_create_layer{}{}.":"结构体是通过使用{}{}new{}{}运算符调用构造函数、创建结构体文字{}{ }{}或由某个函数返回来创建的。另一方面，实例是使用{}{}instance_create_depth{}{}或{}{}instance_create_layer{}{}从对象创建的。","A {}struct {}is a variable that holds a collection of other variables. The variables that a struct holds can be of any {}data type{} previously mentioned and these variables can be read from and written to after the initial struct declaration, and you can also add more variables to a struct after it has been declared.":"{}struct (结构) {}是保存其他变量集合的变量。结构所持有的变量可以是前面提到的任何{}数据类型{}，这些变量可以在初始结构声明之后读取和写入，也可以在声明结构之后向其添加更多变量。","A {}{}{}struct {}is a variable that holds a collection of other variables. The variables that a struct holds can be of any {}data type{} previously mentioned and these variables can be read from and written to after the initial struct declaration, and you can also add more variables to a struct after it has been declared.":"{}{}{}struct (结构) {}是保存其他变量集合的变量。结构所持有的变量可以是前面提到的任何{}数据类型{}，这些变量可以在初始结构声明之后读取和写入，也可以在声明结构之后向其添加更多变量。","Accessing Struct Variables":"访问结构变量","After the initial creation, structs have no processing overhead while they exist, although they {}will{} take up space in memory. The struct syntax is as follows:":"在初始创建之后，虽然结构{}会占用内存空间，但它们在存在时没有处理开销。结构语法如下：","Another way to access data in a struct is by using the {}{}with(){}{} function. So, for example, you could do this:":"访问结构中数据的另一种方法是使用{}{}with(){}{}函数。例如，您可以执行以下操作：","Another way to access data in a struct is by using the&nbsp;{}{}with{}{}&nbsp;statement. So, for example, you could do this:":"访问结构中数据的另一种方法是使用 {}{}with{}{} 语句。例如，您可以这样做：","As you can see, when defining the function we use a colon \"{}:{}\" to separate the new constructor from the parent&nbsp;constructor to be inherited from. The child constructor ({}Vector3{}) passes the {}_x{} and {}_y{} arguments into the parent ({}Vector2{}) constructor, which are used to run the parent's constructor first, after which the child's constructor is executed. This way the child constructor gets the parent's variables ({}x{} and {}y{}) and can also define its own ({}z{}).":'如您所见，在定义函数时，我们使用冒号"{}:{}"将新构造函数与要从中继承的父构造函数分开。子构造函数({}Vector 3{})将{}_x{}和{}_y{}参数传递到父构造函数({}Vector 2{})中，父构造函数用于首先运行父构造函数，然后执行子构造函数。这样，子构造函数就可以获取父项的变量({}x{}和{}y{})，并且还可以定义自己的变量({}z{})。',"Both of these constructors will print {}20{} to the output log, as that was the default value for the argument set by the child constructor, and the same value was passed into the parent constructor.":"这两个构造函数都将向输出日志打印{}20{}，因为这是子构造函数设置的参数的默认值，并且已将相同的值传递到父构造函数。","Checking Constructor Inheritance":"检查构造函数继承","Constructor Functions":"构造函数","Constructors &amp; Structs vs. Objects &amp; Instances":"构造函数 和 结构与对象 和 对象实例","Constructors and structs are similar to {}Objects And Instances{}, as they also hold variables and methods that can be executed. There are, however, a couple of important differences between them:&nbsp;":"构造函数和结构与{}对象和实例{}类似，因为它们也包含可以执行的变量和方法。然而，它们之间有一些重要的区别：","Finally, structs can have other structs nested inside them, like this:":"最后，结构中可以嵌套其他结构，如下所示：","Finally, there are a number of&nbsp;runtime functions that you can use on structs to get the variables they contain&nbsp;as well as a few other things. You can find them in the following section:":"最后，有许多运行时函数可用于结构，以获取它们包含的变量以及其他一些内容。您可以在以下部分中找到它们：","Finally, there are a number of&nbsp;runtime functions that you can use on structs to get the variables they contain&nbsp;as well as a few other things. You can find them under&nbsp;{}Struct Functions{}.":"最后，您可以在结构上使用许多运行时函数来获取它们包含的变量以及其他一些内容。您可以在{}结构函数{}下找到它们。",'For example, we created the&nbsp;{}Vector2{}&nbsp;constructor function above, so we can then use that as the "parent" for another constructor function, which we\'ll call&nbsp;{}Vector3{}:':"例如，我们在上面创建了 {}Vector2{} 构造函数，因此我们可以使用它作为另一个构造函数的“父”函数，我们将其命名为 {}Vector3{}:",'For example, you\'ll notice in the above example that the struct variable "g" is being set to {}image_index{}, which is an instance variable. You might think that you\'d need to use the {}keyword{} {}other{} in this case to get the instance variable, but this is not necessary. Essentially, when you define a struct{}, all member variables on the left-hand side of the colon ":" are&nbsp;the&nbsp;{}struct{}&nbsp;variables, and the values and variables on the right-hand side use the scope of whatever is defining the struct{} (in this case, an instance).':'例如，您会注意到在上面的示例中，结构变量“g”被设置为{}image_index{}，这是一个实例变量。您可能认为在本例中需要使用{}关键字{}{}other{}来获取实例变量，但这是不必要的。本质上，当您定义一个结构{}时，冒号":"左边的所有成员变量都是   {}结构{} 变量，而右边的值和变量使用定义结构{}的范围(在本例中是一个实例)。',"For more details on the {}new{} and {}delete{} operators, please see the following pages:":"有关{}new{}和{}delete{}运算符的详细信息，请参阅以下页面：","Functions created this way will also support single {}inheritance{}, i.e.: you can create a constructor function that inherits data from another constructor function.":"以这种方式创建的函数还将支持单{}继承{}，即：您可以创建一个从另一个构造函数继承数据的构造函数。","Functions created this way will also support single {}inheritance{}, ie: you can create a constructor function that inherits data from another constructor function.":"以这种方式创建的函数还将支持单{}继承{}，即：您可以创建一个从另一个构造函数继承数据的构造函数。","Here is an example of a struct with various variables and data types:":"下面是一个具有各种变量和数据类型的结构示例：","Here we are creating a function called&nbsp;{}Vector2{} and telling {}GameMaker{} that this is a function used for creating structs&nbsp;by adding the {}constructor{} keyword after its definition. You can then call this constructor&nbsp;function like this:":"此处我们创建一个名为{}Vector 2{}的函数，并告诉{}GameMaker{}此函数用于通过在其定义后添加{}构造函数{}关键字来创建结构。然后可以这样调用此构造函数：","If you need to use strings to access a struct variable, it is faster to {}get its hash{} and use that in {}read{}/{}write{} to the variable.":"如果你需要使用字符串来访问一个结构变量，那么{}获取它的hash{}并在{}read{}/{}write{}中使用它来访问变量会更快。","In both cases {}mystruct.a{}&nbsp;will be assigned the value {}12{} and {}mystruct.b{} the value {}14{}, as it will look for a variable with the same name in the scope where the struct is being initialised.":"在这两种情况下，{}mystruct.a{}将被赋值为{}12{}，而{}mystruct.b{}将被赋值为{}14{}，因为它将在初始化结构的作用域中查找同名的变量。",'In the above code the struct member variables {}x{}&nbsp;and {}y{}&nbsp;are being set to the values held in the instance variables {}x{}&nbsp;and {}y{}, since the right-hand side of the colon ":" refers to the instance that is defining the struct. It is worth noting that this means you {}cannot{}&nbsp;use struct member variables for defining subsequent variables within the struct declaration. For example, the following would give you an error:':'在上述代码中，结构化成员变量{}x{}和{}y{}被设置为实例变量{}x{}和{}y{}中保留的值，因为冒号":"的右侧是指定义结构的实例。值得注意的是，这意味着{}不能使用结构成员变量{}来定义结构声明中的后续变量。例如，以下内容会给出一个错误：',"In the above code the struct member variables {}x{}&nbsp;and {}y{}&nbsp;are being set to the values held in the instance variables&nbsp;{}{}x{}{}&nbsp;and {}{}y{}{}, since the right-hand side of the colon {}:{} refers to the instance that is defining the struct. It is worth noting that this means you {}cannot{}&nbsp;use struct member variables for defining subsequent variables within the struct declaration. For example, the following would give you an error:":"在上述代码中，结构体成员变量 {}x{} 和 {}y{} 被设置为实例变量 {}{}x{}{} 和 {}{}y{}{} 中保存的值，因为冒号右侧的 {}:{} 指的是定义结构体的实例。值得注意的是，这意味着您 {} 不能 {} 使用结构体成员变量来定义结构体声明中的后续变量。例如，以下内容会给您带来错误：",Inheritance:"继承","Instance Variables in Struct Declaration?":"结构声明中的实例变量?","It creates a struct from the {}potion{} constructor. Using {}is_instanceof(){}, we can check that the new struct:":"它从 {}potion{} 构造函数创建一个结构。使用 {}is_instanceof(){}，我们可以检查新结构：",'Let\'s look at a simple&nbsp;example to illustrate this. Say you want to define a struct with the variables "x" and "y" and you want to set them to the "x" and "y" of the instance defining the struct. In practice the code would look like this:':'让我们看一个简单的例子来说明这一点。假设您要使用变量"x"和"y"定义结构，并要将它们设置为定义结构的实例的"x"和"y"。实际上，代码如下所示：','Let\'s look at a simple&nbsp;example to illustrate this. Say you want to define a struct with the variables "x" and "y" and you want to set them to the&nbsp;{}{}x{}{} and&nbsp;{}{}y{}{} of the instance defining the struct. In practice the code would look like this:':'让我们看一个简单的例子来说明这一点。假设您想要使用变量 "x" 和 "y" 定义一个结构体，并且希望将它们设置为定义该结构体的实例的 {}{}x{}{} 和 {}{}y{}{}。实际上，代码如下所示：',"Note that assigning a default value to an argument in a child constructor will override the parent's default value for that argument. See the following example:":"请注意，为子构造函数中的参数指定缺省值将覆盖该参数的父级缺省值。请参见以下示例：","Note that you can also call the {}{}string(){}{}&nbsp;function on a struct reference and use that to display the contents - or the {}toString{} method - to the screen, or save it to a file, or whatever, eg:":"请注意，您还可以对结构引用调用{}{}string(){}{}函数，并使用该函数将内容或{}toString{}方法显示到屏幕，或将其保存到文件或其他任何内容，例如：","Note that you can also call the&nbsp;{}{}string{}{}&nbsp;function on a struct reference and use that to display the contents - or the {}toString{} method - to the screen, or save it to a file, or whatever, e.g.:":"请注意，您还可以对结构体引用调用{}{}string{}{}函数，并使用该函数将内容(或{}toString{}方法)显示到屏幕上，或者将其保存到文件中，或者无论如何，例如：","Now when the {}show_debug_message(){} function is called, the {}toString{} method will be used to generate the output and - with the above example - you'll get:":"现在，当调用{}show_debug_message(){}函数时，{}toString{}方法将用于生成输出，并且-使用上面的示例-您将获得：","Now when the&nbsp;{}{}show_debug_message{}{} function is called, the {}toString{} method will be used to generate the output and - with the above example - you'll get:":"现在，当调用{}{}show_debug_message{}{}函数时，将使用{}toString{}方法生成输出，并且通过上面的示例，您将得到：",'Once a struct has been defined, you can access the data within it using the "point" notation, like this:':'定义结构后，可以使用"点"表示法访问其中的数据，如下所示：',"One final thing to mention about structs is that you can change what is output to the console from them for debugging. By default, calling the function {}{}show_debug_message(){}{}&nbsp;on a struct will output the contents of the struct (as shown above). However, it's possible to customise this message by adding a specifically named method to the struct called {}toString{}:":"关于结构的最后一点需要提及的是，您可以更改从结构输出到控制台的内容以进行调试。默认情况下，在结构上调用函数{}{}show_debug_message(){}{}将输出结构的内容(如上所示)。但是，可以通过在名为{}toString{}的结构中添加特定命名的方法来自定义此消息：","One final thing to mention about structs is that you can change what is output to the console from them for debugging. By default, calling the function {}{}show_debug_message(){}{}&nbsp;on a struct will output the contents of the struct (as shown above). However, it's possible to customise this message by adding a specifically named method to the struct called {}{}{}toString{}:":"关于结构，最后要提到的一点是，您可以更改从它们输出到控制台以进行调试的内容。默认情况下，对结构调用函数 {}{}show_debug_message(){}{} 将输出结构的内容 (如上所示)。但是，可以通过将一个专门命名的方法添加到名为 {}{}{}toString{} 的结构中来定制此消息：","One final thing to mention about structs is that you can change what is output to the console from them for debugging. By default, calling the function&nbsp;{}{}show_debug_message{}{} on a struct will output the contents of the struct (as shown above). However, it's possible to customise this message by adding a specifically named method to the struct called {}{}{}toString{}:":"关于结构的最后一件事是，您可以更改结构输出到控制台的内容以进行调试。默认情况下，在结构体上调用函数 {}{}show_debug_message{}{} 将输出该结构体的内容 (如上所示)。不过，可以通过向名为 {}{}{}toString{} 的结构添加专门命名的方法来自定义此消息：","Or,&nbsp;using the method variable syntax:":"或者，使用方法变量语法：","Shorthand Initialisation&nbsp;of Variables With The Same Name":"同名变量初始化的简写","So, an example of this in practice would be:":"因此，实践中的一个例子是：","String Output":"字符串输出","Struct Forbidden Variables":"结构禁止的变量","Struct Functions":"结构体函数","Struct variables that you initialise with the value&nbsp;of an existing variable&nbsp;of the same name (a local or instance variable), can be written using a shorthand notation. Instead&nbsp;of having to write:":"使用同名的现有变量(局部变量或实例变量)的值初始化的结构变量可以使用简写表示法编写。而不是写：","Structs &amp; Constructors":"结构和构造函数","Structs are just variables and don't have events.&nbsp;{}GameMaker{}&nbsp;executes events for all instances, but not for structs. Compared to an object's event, a struct's method never executes on its own, you have to call it yourself in your game's code. This can be from an&nbsp;{}Object Event{}, from a&nbsp;{}Time Source{}&nbsp;or from a more specific place where you can \"tap into\"&nbsp;{}GameMaker{}'s game loop, such as the layer and camera begin/end scripts.":'结构只是变量，没有事件。{}GameMaker{}为所有实例执行事件，但不为结构执行事件。与对象的事件相比，结构体的方法永远不会自行执行，您必须在游戏代码中自己调用它。这可以来自{}对象事件{}、{}时间源{}或更具体的位置，您可以在其中"利用"{}GameMaker{}的游戏循环，例如层和相机开始/结束脚本。',"Structs can have static variables, object instances cannot.&nbsp;{}Object Variables{}&nbsp;are not the equivalent of static variables; they don't belong to the object, rather they provide default values for&nbsp;{}Instance Variables{} that are assigned to instances created from that object before the Create event runs.":"结构体可以有静态变量，但对象实例不能。{}对象变量{}并不等同于静态变量;它们不属于该对象，而是为在 Create 事件运行之前分配给从该对象创建的实例的{}实例变量{}提供默认值。","The above code creates an instance scope struct in the variable {}mystruct{}&nbsp;and populates it with some values (structs can be created at local, instance and global scopes, just like any other variable - see the section on {}Variables and Variable Scope{} for more information). Note that you don't have to populate the contents of a struct when it is created initially and you can create an empty struct by simply doing this:":"以上代码在变量{}mystruct{}中创建实例范围结构，并使用某些值填充该结构(可以在局部、实例和全局范围内创建结构，就像任何其他变量一样-有关详细信息，请参阅{}变量和变量范围{}一节)。请注意，最初创建结构时不必填充其内容，只需执行以下操作即可创建空结构：","The above code shows three constructors:&nbsp;{}item{}, {}potion{} which is a child of {}item{}, and {}enemy{}, which is a separate constructor.":"上面的代码显示了三个构造函数：{}item{}，{}potion{}，它是 {}item{} 的子类，以及 {}enemy{}，它是一个单独的构造函数。",'The error occurs because the variables {}a{}&nbsp;and {}b{}&nbsp;are actually being evaluated at the scope of whatever is defining the struct (they are on the right-hand side of the colon ":"), and are&nbsp;{}not{}&nbsp;the ones being defined within the struct itself.{}{}':'出现错误是因为变量{}a{} 和{}b{} 实际上是在定义结构的范围内计算的(它们在冒号":"的右边)，并且 {}不是{} 是在结构本身中定义的。',"The error occurs because the variables {}a{}&nbsp;and {}b{}&nbsp;are actually being evaluated at the scope of whatever is defining the struct (they are on the right-hand side of the colon {}:{}), and are&nbsp;{}not{}&nbsp;the ones being defined within the struct itself.{}{}":"发生错误的原因是变量 {}a{} 和 {}b{} 实际上是在定义结构的范围内进行求值 (它们位于冒号 {}:{} 的右侧)，并且 {} 不是 {} 结构体本身中定义的。{}{}","The variable {}v2{} will now contain a struct with the variables {}x{} and {}y{} and the {}static{}&nbsp;{}method variable{} {}Add{}.":"变量{}v2{}现在将包含带有变量{}x{}和{}y{}以及{}static{}{}方法变量{}{}Add{}的结构。",'The variables used in a struct should follow the usual variable naming scheme, i.e.: they cannot start with a number and should only be made up of alphanumeric characters and the underscore "_" character, and also note that the contents of a struct are {}independent of the instance or function that created it{}, and as such you can - if you wish - use&nbsp;built-in variable names such as&nbsp;{}image_index{} or {}x{} and {}y{}.':'结构中使用的变量应遵循通常的变量命名方案，即：它们不能以数字开头，只能由字母数字字符和下划线"_"字符组成，并且还要注意，结构的内容与创建它的实例或函数{}无关，因此，如果您愿意，可以使用内置变量名，如{}image_index{}或{}x{}和{}y{}。','The variables used in a struct should follow the usual variable naming scheme, i.e.: they cannot start with a number and should only be made up of alphanumeric characters and the underscore "_" character, and also note that the contents of a struct are {}independent of the instance or function that created it{}, and as such you can - if you wish - use&nbsp;built-in variable names such as&nbsp;{}{}image_index{}{}&nbsp;or {}{}x{}{} and {}{}y{}{}.':'结构体中使用的变量应遵循通常的变量命名方案，即：它们不能以数字开头，只能由字母数字字符和下划线"_"字符组成，还要注意结构体的内容是{}独立于创建它的实例或函数{}，因此，如果您愿意，您可以使用内置变量名称，例如{}{}image_index{}{}或{}{}x{}{}和{}{}y{}{}。',"This constructor&nbsp;will now use {}0{} for the {}_x{} and {}_y{} arguments if they are not specified when the function is called. This means that you can create a new {}Vector2{} struct without having to specify any arguments:":"如果在调用函数时未指定{}_x{}和{}_y{}参数，则此构造函数现在将使用{}0{}。这意味着您可以创建新的{} Vector2 {}结构，而无需指定任何参数：",'This functionality makes use of "static structs". See:&nbsp;{}Static Struct{}':'该功能利用了"静态结构"。请参阅：{}静态结构{}',"This has the same result as initialising the struct like this:&nbsp;":"这与初始化结构体的结果相同：","This has the same result as initializing the struct like this:&nbsp;":"这与初始化如下结构的结果相同：","This means that the damage of a basic sword will always be {}10{}, since it passes that value to its parent constructor irrespective of what its own arguments might be.":"这意味着BasicSword的damage将始终为{}10{}，因为它将该值传递给其父构造函数，而不管其自身的参数是什么。",'This way you can check whether a struct "is" something, as {}a potion is an item{}, so it returns {}true{} for both constructors. However if wouldn\'t be true the other way around: {}an item is not a potion{}.':'通过这种方式，您可以检查结构是否"是"某物，因为 {}potion 是 item{}，因此它为两个构造函数返回 {}true{}。然而，如果不是真的，反过来：{} item 不是 potion {}。',"To access such nested structs you would still use the point notation, like this:":"要访问此类嵌套结构，仍需使用点符号，如下所示：","Using {}with(){} changes the scope of the code to the given struct where you can manipulate the member variables at the struct&nbsp;scope. Note that in the example we also use the {}{}other{} keyword{}. This works just like in an instance when using {}with(){} and will reference the instance (or struct) that is actually running the code block.":"将{}with(){}一起使用会将代码范围更改为给定结构，从而可以在结构范围内操作成员变量。请注意，在本示例中，我们还使用了{}{}other{}关键字{}。这与使用{}with(){}时的实例类似，并且将引用实际运行代码块的实例(或结构)。","Using {}with{} changes the scope of the code to the given struct where you can manipulate the member variables at the struct&nbsp;scope. Note that in the example we also use the {}{}other{} keyword{}. This works just like in an instance when using {}with{}&nbsp;and will reference the instance (or struct) that is actually running the code block.":"将 {}with{} 配合使用会将代码的作用域更改为给定的结构，您可以在其中操作结构作用域中的成员变量。请注意，在本例中，我们还使用了{} {}other{} 关键字{}。这就像在实例中将 {}with{} 一起使用时一样，并将引用实际运行代码块的实例 (或结构)。","Variable Functions":"变量函数","Variables can then be added to this struct at a later point in the game code. To add them afterwards you use the dot operator (in the same way as in&nbsp;{}Addressing Variables In Other Instances{}):&nbsp;":"然后可以在游戏代码的稍后一点将变量添加到此结构中。若要在以后添加它们，请使用点运算符(与{}其他实例中的寻址变量的方法相同{})：","When a struct is no longer required it can be removed from memory using the {}{}delete{}{} operator, which flags the struct as being able to be garbage collected. This is not strictly required as the {}garbage collector{} may do this automatically if the struct is no longer referenced in your code, but it is good practice to do so and we recommend it (for example, call {}delete{} in the {}Clean Up event{} of an instance to explicitly tell the garbage collector that an instance scope struct is to be deleted). Here is an example:":"当一个结构不再需要时，可以使用{}{}delete{}{}操作符从内存中删除它，该操作符将该结构标记为能够被垃圾回收。这不是严格要求的，因为如果代码中不再引用该结构，{}垃圾收集器{}可能会自动执行此操作，但这样做是很好的实践，我们建议这样做(例如，在实例的{}清理事件{}中调用{}delete{}，显式地告诉垃圾收集器要删除一个实例作用域结构)。下面是一个例子:","When a struct is no longer required it can be removed from memory using the {}{}delete{}{} operator, which flags the struct as being able to be garbage collected. This is not strictly required as the {}garbage collector{} may do this automatically if the struct is no longer referenced in your code, but it is good practice to do so and we recommend it (for example, call&nbsp;{}{}delete{}{}&nbsp;in the {}Clean Up event{} of an instance to explicitly tell the garbage collector that an instance scope struct is to be deleted). Here is an example:":"当不再需要某个结构体时，可以使用 {}{}delete{}{} 运算符将其从内存中删除，该运算符将该结构体标记为可以进行垃圾回收。这并不是严格要求的，因为如果您的代码中不再引用该结构，{} 垃圾收集器 {} 可能会自动执行此操作，但这样做是一种很好的做法，我们建议您这样做 (例如，在 {10} 清理事件 {11} 中调用 {}{}delete{}{} 显式告诉垃圾收集器要删除实例范围结构)。这是一个例子：","You can also make use of optional arguments in your constructor functions:":"您还可以在构造函数中使用可选参数：","You can also pass constant values into the parent constructor, so that a certain child constructor always provides the same values to its parent constructor:":"也可以将常量值传递给父构造函数，以便某个子构造函数始终为其父构造函数提供相同的值：","You can also pass values into the parent constructor, so that a certain child constructor always provides the same values to its parent constructor:":"您还可以将值传递给父构造函数，以便某个子构造函数始终向其父构造函数提供相同的值：","You can also perform operations on the variables within a struct or use them in functions, just as you would with any other variable. For example:":"您还可以对结构中的变量执行操作，或者在函数中使用它们，就像对待任何其他变量一样。例如：","You can also use {}script functions{} or&nbsp;{}methods{} to create functions that can be used to generate new structs, which requires the use of the {}constructor{} keyword for the function and the {}{}new{}{} operator when creating a struct from such a function. See the following function:":"您还可以使用{}脚本函数{}或{}方法{}来创建可用于生成新结构的函数，这需要使用函数的{}构造函数{}关键字，以及从此类函数创建结构时使用{}{}new{}{}运算符。请参阅以下函数：","You can see in the above code that you can define methods and use runtime functions in structs, and you can also use local and instance variables within the struct declaration.":"在上面的代码中可以看到，您可以在结构中定义方法和使用运行时函数，还可以在结构声明中使用局部变量和实例变量。","You can use&nbsp;{}{}is_instanceof{}{}&nbsp;to check if a struct belongs to the given constructor, or has the constructor as a parent constructor.":"您可以使用 {}{}is_instanceof{}{} 来检查结构是否属于给定的构造函数，或者是否将该构造函数作为父构造函数。","You can write:&nbsp;":"你可以这样写：","You'll notice in the above code that you can also define methods and use runtime functions in structs, and you can also use local and instance variables within the struct declaration.":"您将在上面的代码中注意到，您还可以定义方法并在结构中使用运行时函数，还可以在struct声明中使用局部变量和实例变量。",'You\'ll notice in the above example that the struct variable "g" is being set to {}image_index{}, which is an instance variable. You might think that you\'d need to use the {}keyword{} {}other{} in this case to get the instance variable, but this is not necessary. Essentially, when you define a struct{}, all member variables on the left-hand side of the colon ":" are&nbsp;the&nbsp;{}struct{}&nbsp;variables, and the values and variables on the right-hand side use the scope of whatever is defining the struct{} (in this case, an instance).':'在上面的示例中，您将注意到结构变量"g"被设置为 {}image_index{}，这是一个实例变量。在本例中，您可能认为需要使用{}关键字{} {}other{} 来获取实例变量，但这并不是必需的。本质上，当您定义结构时，{}冒号"："左侧的所有成员变量都是{}结构{}变量，而右侧的值和变量使用定义结构{}(在本例中为实例)的作用域。','You\'ll notice in the above example that the struct variable "g" is being set to {}{}image_index{}{}, which is an instance variable. You might think that you\'d need to use the {}keyword{} {}other{} in this case to get the instance variable, but this is not necessary. Essentially, when you define a struct{}, all member variables on the left-hand side of the colon ":" are&nbsp;the&nbsp;{}struct{}&nbsp;variables, and the values and variables on the right-hand side use the scope of whatever is defining the struct{} (in this case, an instance).':'您会注意到在上面的示例中，结构变量 "g" 被设置为 {}{}image_index{}{}，它是一个实例变量。您可能认为在这种情况下需要使用 {} 关键字 {}{}other{} 来获取实例变量，但这不是必需的。本质上，当您定义 struct 时，冒号 ":" 左侧的所有成员变量都是 {}{}struct{}{} 变量，右侧的值和变量使用任意范围( 在本例中是一个实例)。',"and writing:&nbsp;":"和写入：","is a {}potion{}":"是一个 {}potion{}","is an {}item{}":"是一个 {}item{}","is not an {}enemy{}":"不是一个 {}enemy{}","{}NOTE{}: When working with inheritance, you cannot use method variables to define the constructor function, only script functions.":"{}注意{}:使用继承时，不能使用方法变量来定义构造函数，只能使用脚本函数。","{}{}IMPORTANT!{}{}&nbsp; You {}cannot {}use any built-in {}{}global {}{}scope variables as struct member names, eg: {}game_id{} or {}fps{}. You can find a full list of these global variables from the following page:":"{}{}重要!{}{}您{}不能{}使用任何内置的{}{}全局{}{}范围变量作为结构成员名称，例如：{}game_id{}或{}fps{}。您可以从以下页面找到这些全局变量的完整列表：","{}{}IMPORTANT{}{}&nbsp;You cannot use any built-in {}global variables{} as struct member names, e.g.:&nbsp;{}{}game_id{}{} {}{} {}{}or {}{}fps{}{}. You can find a full list of these global variables on&nbsp;{}Struct Forbidden Variables{}. ":"{}{} 重要提示 {}{}您不能使用任何内置的 {} 全局变量 {} 作为结构体成员名称，例如：{}{}game_id{}{}{}{}{}{} 或 {}{}fps{}{}。您可以在 {} 结构禁止变量 {} 上找到这些全局变量的完整列表。","{}{}IMPORTANT{}{}&nbsp;You cannot use any built-in {}global variables{} as struct member names, eg: {}game_id{} or {}fps{}. You can find a full list of these global variables on&nbsp;{}Struct Forbidden Variables{}.":"{}{}重要!{}{} 您不能使用任何内置的{}全局{}范围变量作为结构成员名称，例如：{}game_id{} 或 {}fps{}。您可以在{}结构禁用变量{}上找到这些全局变量的完整列表。","{}{}NOTE{}{}&nbsp;There are subtle differences between&nbsp;{}Structs &amp; Constructors{}&nbsp;and&nbsp;{}Objects And Instances{}. See&nbsp;{}Constructors &amp; Structs vs. Objects &amp; Instances{} for more info.":"{}{} 注意{}{} 结构体和结构体之间存在细微差别。{} 构造函数 {} 和 {} 对象和实例 {}。请参阅 {} 构造函数和结构与对象和对象实例 {} 了解更多信息。","{}{}NOTE{}{}&nbsp;When working with inheritance, you cannot use method variables to define the constructor function, only script functions.":"{}{}注意{}{} 在使用继承时，不能使用方法变量来定义构造函数，只能使用脚本函数。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(t){json_global=t}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../..",gTopicId="8.2.1.2"</script><script type="text/javascript" src="../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Structs &amp; Constructors</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../assets/css/default.css" type="text/css"><script src="../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Gurpreet S. Matharoo"><meta name="topic-comment" content="Page outlining the use of Structs"><meta name="rh-index-keywords" content="Structs"><meta name="search-keywords" content="structs,new,delete,struct"><meta name="brsnext" value="GameMaker_Language/GML_Overview/Structs/Static_Structs.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Arrays.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Structs &amp; Constructors"><span>Structs &amp; Constructors</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Structs &amp; Constructors</span></h1><p>A<strong><a id="struct"></a> struct</strong> is a variable that holds a collection of other variables. The variables that a struct holds can be of any <a href="Data_Types.htm">data type</a> previously mentioned and these variables can be read from and written to after the initial struct declaration, and you can also add more variables to a struct after it has been declared.</p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;There are subtle differences between&nbsp;<span data-field="title" data-format="default">Structs &amp; Constructors</span>&nbsp;and&nbsp;<a href="../../Quick_Start_Guide/Objects_And_Instances.htm">Objects And Instances</a>. See&nbsp;<a href="Structs.htm#constructors_structs_vs_objects_instances">Constructors &amp; Structs vs. Objects &amp; Instances</a> for more info.</p><p>The variables used in a struct should follow the usual variable naming scheme, i.e.: they cannot start with a number and should only be made up of alphanumeric characters and the underscore "_" character, and also note that the contents of a struct are <em>independent of the instance or function that created it</em>, and as such you can - if you wish - use&nbsp;built-in variable names such as&nbsp;<span class="inline2"><a href="../GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/image_index.htm">image_index</a></span>&nbsp;or <span class="inline2"><a href="../GML_Reference/Asset_Management/Instances/Instance_Variables/x.htm">x</a></span> and <span class="inline2"><a href="../GML_Reference/Asset_Management/Instances/Instance_Variables/y.htm">y</a></span>.</p><p>After the initial creation, structs have no processing overhead while they exist, although they <i>will</i> take up space in memory. The struct syntax is as follows:</p><p class="code"><i>&lt;variable&gt;</i> =<br>{<br><i>&nbsp; &nbsp; &lt;variable&gt;</i> : <i>&lt;value&gt;</i>,<br><i>&nbsp; &nbsp; &lt;variable&gt;</i> : <i>&lt;value&gt;</i>,<br>&nbsp;&nbsp;&nbsp;&nbsp;etc...<br>};</p><p>So, an example of this in practice would be:</p><p class="code">mystruct =<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;a : 20,<br>&nbsp;&nbsp;&nbsp;&nbsp;b : "Hello World"<br>};</p><p>The above code creates an instance scope struct in the variable <span class="inline">mystruct</span>&nbsp;and populates it with some values (structs can be created at local, instance and global scopes, just like any other variable - see the section on <a href="Variables_And_Variable_Scope.htm">Variables and Variable Scope</a> for more information). Note that you don't have to populate the contents of a struct when it is created initially and you can create an empty struct by simply doing this:</p><p class="code">mystruct = {};</p><p>Variables can then be added to this struct at a later point in the game code. To add them afterwards you use the dot operator (in the same way as in&nbsp;<a href="Addressing_Variables_In_Other_Instances.htm">Addressing Variables In Other Instances</a>):&nbsp;</p><p class="code">mystruct.newItem = "Some Text";</p><p>This has the same result as initialising the struct like this:&nbsp;</p><p class="code">mystruct =<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;newItem : "Some Text"<br>};</p><p>Here is an example of a struct with various variables and data types:</p><p class="code">var _xx = 100;<br>mystruct =<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;a : 10,<br>&nbsp;&nbsp;&nbsp;&nbsp;b : "Hello World",<br>&nbsp;&nbsp;&nbsp;&nbsp;c : int64(5),<br>&nbsp;&nbsp;&nbsp;&nbsp;d : _xx + 50,<br>&nbsp;&nbsp;&nbsp;&nbsp;e : function(a, b)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return a + b;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;f : [ 10, 20, 30, 40, 50 ],<br>&nbsp; &nbsp; g : image_index<br>};</p><p>You can see in the above code that you can define methods and use runtime functions in structs, and you can also use local and instance variables within the struct declaration.</p><h3 id="inst_in_struct">Instance Variables in Struct Declaration?</h3><p>You'll notice in the above example that the struct variable "g" is being set to <span class="inline2"><a href="../GML_Reference/Asset_Management/Sprites/Sprite_Instance_Variables/image_index.htm">image_index</a></span>, which is an instance variable. You might think that you'd need to use the <a href="Instance_Keywords.htm">keyword</a> <span class="inline">other</span> in this case to get the instance variable, but this is not necessary. Essentially, when you define a struct<strong>, all member variables on the left-hand side of the colon ":" are&nbsp;the&nbsp;<em>struct</em>&nbsp;variables, and the values and variables on the right-hand side use the scope of whatever is defining the struct</strong> (in this case, an instance).</p><p>Let's look at a simple&nbsp;example to illustrate this. Say you want to define a struct with the variables "x" and "y" and you want to set them to the&nbsp;<span class="inline2"><a href="../GML_Reference/Asset_Management/Instances/Instance_Variables/x.htm">x</a></span> and&nbsp;<span class="inline2"><a href="../GML_Reference/Asset_Management/Instances/Instance_Variables/y.htm">y</a></span> of the instance defining the struct. In practice the code would look like this:</p><p class="code">mystruct =<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;x : x,<br>&nbsp;&nbsp;&nbsp;&nbsp;y : y<br>};</p><p>In the above code the struct member variables <span class="inline">x</span>&nbsp;and <span class="inline">y</span>&nbsp;are being set to the values held in the instance variables&nbsp;<span class="inline2"><a href="../GML_Reference/Asset_Management/Instances/Instance_Variables/x.htm">x</a></span>&nbsp;and <span class="inline2"><a href="../GML_Reference/Asset_Management/Instances/Instance_Variables/y.htm">y</a></span>, since the right-hand side of the colon <span class="inline2">:</span> refers to the instance that is defining the struct. It is worth noting that this means you <em>cannot</em>&nbsp;use struct member variables for defining subsequent variables within the struct declaration. For example, the following would give you an error:</p><p class="code">mystruct =<br>{<br>&nbsp; &nbsp; a : 10,<br>&nbsp; &nbsp; b : 10,<br>&nbsp; &nbsp; c : a + b<br>}</p><p>The error occurs because the variables <span class="inline">a</span>&nbsp;and <span class="inline">b</span>&nbsp;are actually being evaluated at the scope of whatever is defining the struct (they are on the right-hand side of the colon <span class="inline2">:</span>), and are&nbsp;<em>not</em>&nbsp;the ones being defined within the struct itself.<strong></strong></p><p class="note" style="padding-left:20px"><span data-conref="../../assets/snippets/Tag_important.hts"><span class="important">IMPORTANT</span></span>&nbsp;You cannot use any built-in <strong>global variables</strong> as struct member names, e.g.:&nbsp;<span class="inline2"><a href="../GML_Reference/General_Game_Control/game_id.htm">game_id</a></span><font face="menlo, consolas, monospace"><b></b></font> or <span class="inline2"><a href="../GML_Reference/Debugging/fps.htm">fps</a></span>. You can find a full list of these global variables on&nbsp;<a href="Struct_Forbidden_Variables.htm">Struct Forbidden Variables</a>.</p><h3>Shorthand Initialisation&nbsp;of Variables With The Same Name</h3><p>Struct variables that you initialise with the value&nbsp;of an existing variable&nbsp;of the same name (a local or instance variable), can be written using a shorthand notation. Instead&nbsp;of having to write:</p><p class="code">var a = 12;<br>b = 14;<br><br>mystruct =&nbsp;<br>{<br>&nbsp; &nbsp; a : a,<br>&nbsp; &nbsp; b : b,<br>&nbsp; &nbsp; c : 101<br>}</p><p>You can write:&nbsp;</p><p class="code">var a = 12;<br>b = 14;<br><br>mystruct =&nbsp;<br>{<br>&nbsp; &nbsp; a,<br>&nbsp; &nbsp; b,<br>&nbsp; &nbsp; c: 101<br>}</p><p>In both cases <span class="inline2">mystruct.a</span>&nbsp;will be assigned the value <span class="inline2">12</span> and <span class="inline2">mystruct.b</span> the value <span class="inline2">14</span>, as it will look for a variable with the same name in the scope where the struct is being initialised.</p><h3>Accessing Struct Variables</h3><p>Once a struct has been defined, you can access the data within it using the "point" notation, like this:</p><p class="code">mystruct =<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;a : 20,<br>&nbsp;&nbsp;&nbsp;&nbsp;b : "Hello World"<br>}<br><br>mystring = mystruct.b + string(mystruct.a);</p><p>You can also perform operations on the variables within a struct or use them in functions, just as you would with any other variable. For example:</p><p class="code">mystruct.a += 1;<br>mystruct.b = mystruct.a + 20;<br>mydir = point_direction(mouse_x, mouse_y, mystruct.xx, mystruct.yy);</p><p>Finally, structs can have other structs nested inside them, like this:</p><p class="code">mystruct =<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;a :<br>&nbsp; &nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;aa : "This is an example"<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;b :<br>&nbsp; &nbsp; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;bb : "And another one"<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>};</p><p>To access such nested structs you would still use the point notation, like this:</p><p class="code">var _str = mystruct.a.aa + " " + mystruct.b.bb;<br>show_debug_message(_str);</p><p>Another way to access data in a struct is by using the&nbsp;<span class="inline2"><a href="Language_Features/with.htm">with</a></span>&nbsp;statement. So, for example, you could do this:</p><p class="code">with (mystruct)<br>{<br>&nbsp; &nbsp; a += other.x;<br>}</p><p>Using <span class="inline2">with</span> changes the scope of the code to the given struct where you can manipulate the member variables at the struct&nbsp;scope. Note that in the example we also use the <a href="Instance_Keywords.htm"><span class="inline">other</span> keyword</a>. This works just like in an instance when using <span class="inline2">with</span>&nbsp;and will reference the instance (or struct) that is actually running the code block.</p><p>A last way to access data in a struct is by using the struct accessor <span class="inline2"><a href="Accessors.htm#$">$</a></span>. This allows access to struct variables using strings, for both reading:&nbsp;</p><p class="code">var _value = mystruct[$ "x"];</p><p>and writing:&nbsp;</p><p class="code">mystruct[$ "x"] = 200;</p><p>If you need to use strings to access a struct variable, it is faster to <a href="../GML_Reference/Variable_Functions/variable_get_hash.htm">get its hash</a> and use that in <a href="../GML_Reference/Variable_Functions/struct_get_from_hash.htm">read</a>/<a href="../GML_Reference/Variable_Functions/struct_set_from_hash.htm">write</a> to the variable.</p><p>When a struct is no longer required it can be removed from memory using the <a href="Language_Features/delete.htm"><span class="inline">delete</span></a> operator, which flags the struct as being able to be garbage collected. This is not strictly required as the <a class="tooltip" title="The garbage collector is an automated tool that is part of the game code and is used to remove certain things (like arrays and structs) from memory when they are no longer referenced in your code, without the need for you to explicitly remove them.">garbage collector</a> may do this automatically if the struct is no longer referenced in your code, but it is good practice to do so and we recommend it (for example, call&nbsp;<span class="inline2"><a href="Language_Features/delete.htm">delete</a></span>&nbsp;in the <a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm">Clean Up event</a> of an instance to explicitly tell the garbage collector that an instance scope struct is to be deleted). Here is an example:</p><p class="code">// Create event<br>mystruct =<br>{<br>&nbsp; &nbsp; pos_x : x,<br>&nbsp; &nbsp; pos_y : y,<br>&nbsp; &nbsp; count : 1000<br>};<br><br>// Clean Up event<br>delete mystruct;</p><h2 id="constr">Constructor Functions</h2><p>You can also use <a href="Script_Functions.htm">script functions</a> or&nbsp;<a href="Method_Variables.htm">methods</a> to create functions that can be used to generate new structs, which requires the use of the <span class="inline">constructor</span> keyword for the function and the <a href="Language_Features/new.htm"><span class="inline">new</span></a> operator when creating a struct from such a function. See the following function:</p><p class="code">function Vector2(_x, _y) <strong>constructor</strong><br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;x = _x;<br>&nbsp;&nbsp;&nbsp;&nbsp;y = _y;<br><br>&nbsp; &nbsp; static Add = function(_vec2)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += _vec2.x;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += _vec2.y;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p><p>Or,&nbsp;using the method variable syntax:</p><p class="code">Vector2 = function(_x, _y) constructor<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;x = _x;<br>&nbsp;&nbsp;&nbsp;&nbsp;y = _y;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;static Add = function(_vec2)<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += _vec2.x;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += _vec2.y;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p><p>Here we are creating a function called&nbsp;<span class="inline">Vector2</span> and telling <span data-keyref="GameMaker Name">GameMaker</span> that this is a function used for creating structs&nbsp;by adding the <span class="inline">constructor</span> keyword after its definition. You can then call this constructor&nbsp;function like this:</p><p class="code">v2 = new Vector2(10, 10);</p><p>The variable <span class="inline">v2</span> will now contain a struct with the variables <span class="inline">x</span> and <span class="inline">y</span> and the <a href="Functions/Static_Variables.htm">static</a>&nbsp;<a href="Method_Variables.htm">method variable</a> <span class="inline">Add</span>.</p><p>You can also make use of optional arguments in your constructor functions:</p><p class="code">function Vector2(<strong>_x = 0, _y = 0</strong>) constructor<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;x = _x;<br>&nbsp;&nbsp;&nbsp;&nbsp;y = _y;<br>}</p><p>This constructor&nbsp;will now use <span class="inline">0</span> for the <span class="inline">_x</span> and <span class="inline">_y</span> arguments if they are not specified when the function is called. This means that you can create a new <span class="inline">Vector2</span> struct without having to specify any arguments:</p><p class="code">empty_vector = new Vector2();</p><h2>Inheritance</h2><p>Functions created this way will also support single <b>inheritance</b>, i.e.: you can create a constructor function that inherits data from another constructor function.</p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;When working with inheritance, you cannot use method variables to define the constructor function, only script functions.</p><p>For example, we created the&nbsp;<span class="inline">Vector2</span>&nbsp;constructor function above, so we can then use that as the "parent" for another constructor function, which we'll call&nbsp;<span class="inline">Vector3</span>:</p><p class="code">function <strong>Vector3(_x, _y, _z)</strong> <strong>:</strong> <strong>Vector2(_x, _y)</strong> constructor<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;z = _z;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;static Add = function( _vec3 )<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;x += _vec3.x;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;y += _vec3.y;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;z += _vec3.z;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p><p>As you can see, when defining the function we use a colon "<span class="inline">:</span>" to separate the new constructor from the parent&nbsp;constructor to be inherited from. The child constructor (<span class="inline">Vector3</span>) passes the <span class="inline">_x</span> and <span class="inline">_y</span> arguments into the parent (<span class="inline">Vector2</span>) constructor, which are used to run the parent's constructor first, after which the child's constructor is executed. This way the child constructor gets the parent's variables (<span class="inline">x</span> and <span class="inline">y</span>) and can also define its own (<span class="inline">z</span>).</p><p>You can also pass values into the parent constructor, so that a certain child constructor always provides the same values to its parent constructor:</p><p class="code">function item(damage) constructor<br>{<br>&nbsp;&nbsp; &nbsp;my_damage = damage;<br>}<br><br>function basic_sword() : item(10) constructor {}<br><br>var _basic_sword = new basic_sword();<br>show_debug_message(_basic_sword.my_damage); // Prints 10</p><p>This means that the damage of a basic sword will always be <span class="inline">10</span>, since it passes that value to its parent constructor irrespective of what its own arguments might be.</p><p>Note that assigning a default value to an argument in a child constructor will override the parent's default value for that argument. See the following example:</p><p class="code">function parent(value = 10) constructor<br>{<br>&nbsp;&nbsp; &nbsp;show_debug_message(value);<br>}<br><br>function child(value = 20) : parent(value) constructor<br>{<br>&nbsp;&nbsp; &nbsp;show_debug_message(value);<br>}<br><br>var _child = new child();</p><p>Both of these constructors will print <span class="inline">20</span> to the output log, as that was the default value for the argument set by the child constructor, and the same value was passed into the parent constructor.</p><p>For more details on the <span class="inline">new</span> and <span class="inline">delete</span> operators, please see the following pages:</p><ul class="colour"><li><a href="Language_Features/new.htm"><span class="inline">new</span></a></li><li><span class="inline"><a href="Language_Features/delete.htm"><span class="inline">delete</span></a></span></li></ul><h3>Checking Constructor Inheritance</h3><p>You can use&nbsp;<span class="inline3_func"><a href="../GML_Reference/Variable_Functions/is_instanceof.htm">is_instanceof</a></span>&nbsp;to check if a struct belongs to the given constructor, or has the constructor as a parent constructor.</p><div data-conref="../../assets/snippets/is_instanceof_example.hts"><p class="code">function item() constructor {}<br><br>function potion() : item() constructor {}<br><br>function enemy() constructor {}<br><br>var _potion = new potion();<br><br>show_debug_message(is_instanceof(_potion, potion)); // true (1)<br>show_debug_message(is_instanceof(_potion, item)); // true (1)<br>show_debug_message(is_instanceof(_potion, enemy)); // false (0)</p><p>The above code shows three constructors:&nbsp;<span class="inline2">item</span>, <span class="inline2">potion</span> which is a child of <span class="inline2">item</span>, and <span class="inline2">enemy</span>, which is a separate constructor.</p><p>It creates a struct from the <span class="inline2">potion</span> constructor. Using <span class="inline2">is_instanceof()</span>, we can check that the new struct:</p><ul class="colour"><li>is a <span class="inline2">potion</span></li><li>is an <span class="inline2">item</span></li><li>is not an <span class="inline2">enemy</span></li></ul><p>This way you can check whether a struct "is" something, as <strong>a potion is an item</strong>, so it returns <span class="inline2">true</span> for both constructors. However if wouldn't be true the other way around: <strong>an item is not a potion</strong>.</p></div><p>This functionality makes use of "static structs". See:&nbsp;<a href="Structs/Static_Structs.htm">Static Struct</a></p><h2>String Output</h2><p>One final thing to mention about structs is that you can change what is output to the console from them for debugging. By default, calling the function&nbsp;<span class="inline3_func"><a href="../GML_Reference/Debugging/show_debug_message.htm">show_debug_message</a></span> on a struct will output the contents of the struct (as shown above). However, it's possible to customise this message by adding a specifically named method to the struct called<span class="inline"><a id="A"></a> toString</span>:</p><p class="code">mystruct =<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;a : 20,<br>&nbsp;&nbsp;&nbsp;&nbsp;b : "Hello World",<br><br>&nbsp; &nbsp; toString&nbsp;: function()<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; return "This struct says " + b + ",&nbsp;" + string(a) + " times!";<br>&nbsp; &nbsp; }<br>}<br>show_debug_message(mystruct);</p><p>Now when the&nbsp;<span class="inline3_func"><a href="../GML_Reference/Debugging/show_debug_message.htm">show_debug_message</a></span> function is called, the <span class="inline">toString</span> method will be used to generate the output and - with the above example - you'll get:</p><p class="code">This struct says Hello World, 20 times!</p><p>Note that you can also call the&nbsp;<span class="inline3_func"><a href="../GML_Reference/Strings/string.htm">string</a></span>&nbsp;function on a struct reference and use that to display the contents - or the <span class="inline">toString</span> method - to the screen, or save it to a file, or whatever, e.g.:</p><p class="code">var _str = string(mystruct);<br>draw_text(32, 32, _str);</p><h2 id="constructors_structs_vs_objects_instances">Constructors &amp; Structs vs. Objects &amp; Instances</h2><p>Constructors and structs are similar to <a href="../../Quick_Start_Guide/Objects_And_Instances.htm">Objects And Instances</a>, as they also hold variables and methods that can be executed. There are, however, a couple of important differences between them:&nbsp;</p><ul class="Disc"><li>A struct is created by calling a constructor function using the&nbsp;<span class="inline2"><a href="Language_Features/new.htm">new</a></span>&nbsp;operator, by creating a struct literal <span class="inline2">{}</span>&nbsp;or returned by some function. An instance, on the other hand, is created from an object using&nbsp;<span class="inline3_func"><a href="../GML_Reference/Asset_Management/Instances/instance_create_depth.htm">instance_create_depth</a></span>&nbsp;or&nbsp;<span class="inline3_func"><a href="../GML_Reference/Asset_Management/Instances/instance_create_layer.htm">instance_create_layer</a></span>.</li><li>Structs are just variables and don't have events.&nbsp;<span data-keyref="GameMaker Name">GameMaker</span>&nbsp;executes events for all instances, but not for structs. Compared to an object's event, a struct's method never executes on its own, you have to call it yourself in your game's code. This can be from an&nbsp;<a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm">Object Event</a>, from a&nbsp;<a href="../GML_Reference/Time_Sources/Time_Sources.htm">Time Source</a>&nbsp;or from a more specific place where you can "tap into"&nbsp;<span data-keyref="GameMaker Name">GameMaker</span>'s game loop, such as the layer and camera begin/end scripts.</li><li>Structs can have static variables, object instances cannot.&nbsp;<a href="../../The_Asset_Editors/Object_Properties/Object_Variables.htm">Object Variables</a>&nbsp;are not the equivalent of static variables; they don't belong to the object, rather they provide default values for&nbsp;<a href="Variables/Instance_Variables.htm">Instance Variables</a> that are assigned to instances created from that object before the Create event runs.</li></ul><h2>Struct Functions</h2><p>Finally, there are a number of&nbsp;runtime functions that you can use on structs to get the variables they contain&nbsp;as well as a few other things. You can find them under&nbsp;<a href="../GML_Reference/Variable_Functions/Variable_Functions.htm#struct_functions">Struct Functions</a>.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="GML_Overview.htm">GML&nbsp;Overview</a></div><div style="float:right">Next:&nbsp;<a href="Structs/Static_Structs.htm">Static Struct</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>