<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,n){let o;o=n?e.attr(n):e.html();let s=t[removeHtml(o)];if(null!=s&&s.length){t=retHtml(o);let a=0;t&&t.forEach(function(e,t){var n=s.replace("{"+a+"}",e);s=n===s?s.replace("{}",e):n,a++}),n?e.attr(n,s):e.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Addressing Variables In Other Instances":"在其他实例中处理变量","By far the most common and practical method, however, is to use a&nbsp;{}variable{} on the left of the point, as long as the variable in question{} has stored a valid {}instance id{}{}. The following examples illustrate this.":"然而，到目前为止，最常见和实用的方法是在点左侧使用{}变量{}，只要有问题的变量{}存储了有效的{}实例id{}{}。下面的例子说明了这一点。","In practice it would look like this:":"在实践中，它看起来像这样。","In the above code for Example 1, there is an {}{}instance_exists(){}{}&nbsp;call in the code block. This is because using the point method to access or change another instances value will give an error and crash the game if the instance does not exist, and there is the possibility that this is the case in that example. We don't need the check however in Examples 2 and 3 because we {}know{} that the instance is there since in Example 2 we created it, and in Example 3, its the other instance in a collision event. However, if there is {}any{} possibility that the instance could be destroyed, deactivated, or otherwise removed from the room while using this method, you should {}always{} check beforehand using the {}instance_exists(){} function or the {}{}instance_number(){}{}&nbsp;function.":"在上面例1的代码中，有一个{}{}instance_exists(){}{}代码块的调用。这是因为使用点方法来访问或改变另一个实例的值，如果该实例不存在，就会出现错误并使游戏崩溃，而在这个例子中就有可能出现这种情况。然而在例2和例3中我们不需要检查，因为我们{}知道{}实例是存在的，因为在例2中我们创建了它，而在例3中，是碰撞事件中的另一个实例。然而，如果在使用这个方法时，有{}任何{}可能性，即实例可能被销毁、停用或以其他方式从房间中移除，你应该{}总是{}事先使用{}instance_exists(){}函数或{}{}instance_number(){}{}函数来检查。","In the above code for Example 1, there is an&nbsp;{}{}instance_exists{}{} call in the code block. This is because using the point method to access or change another instances value will give an error and crash the game if the instance does not exist, and there is the possibility that this is the case in that example. We don't need the check however in Examples 2 and 3 because we {}know{} that the instance is there since in Example 2 we created it, and in Example 3, its the other instance in a collision event. However, if there is {}any{} possibility that the instance could be destroyed, deactivated, or otherwise removed from the room while using this method, you should {}always{} check beforehand using the&nbsp;{}{}instance_exists{}{} function or the&nbsp;{}{}instance_number{}{} function.":"在上面示例 1 的代码中，代码块中有一个{}{}instance_exists{}{}调用。这是因为，如果该实例不存在，使用 point 方法访问或更改另一个实例值将给出错误并导致游戏崩溃，并且该示例中可能存在这种情况。然而，在示例 2 和 3 中，我们不需要进行检查，因为我们{}知道{}该实例存在，因为在示例 2 中我们创建了该实例，而在示例 3 中，它是碰撞事件中的另一个实例。但是，如果在使用此方法时存在实例被销毁、停用或以其他方式从房间中移除的{}任何{}可能性，您应该{}始终{}使用{}{}instance_exists{}{}函数或{}{}instance_number{}{}函数。","In the sections dedicated to {}variables{} you found out how to create and use variables within a single instance, or on a global scope, but what happens if you want one instance to access a variable in another, different instance? There are many cases when you may want to do this, for example in a collision with a bullet object, you may want to find out how much damage the bullet does by accessing a variable in the bullet, or you might want to stop the motion of all the balls in a puzzle, or you might want to move the main character to a particular position, or any number of other situations you typically come across in any game. Thankfully the GameMaker Language comes equipped with mechanisms to achieve this.":"在专门讨论{}变量{}的章节中，你发现了如何在单个实例中或在全局范围内创建和使用变量，但如果你想让一个实例访问另一个不同实例中的变量，会发生什么？有很多情况下你可能想这样做，例如在与子弹物体的碰撞中，你可能想通过访问子弹中的一个变量来了解子弹的伤害程度，或者你可能想在一个谜题中停止所有球的运动，或者你可能想把主角移动到一个特定的位置，或者你在任何游戏中通常遇到的任何其他情况。值得庆幸的是，GameMaker语言配备了实现这一目的的机制。","It is also important to note that you cannot use&nbsp;any function by itself as the left-hand side of an assignment. For example, the following code would give you an error:":"同样重要的是要注意，你不能使用任何函数本身作为赋值的左边。例如，下面的代码会给你一个错误。",'Note that you cannot use the special {}keyword{} "{}all{}" with this method to target all instances(eg: {}all.val = 10{} would give an error), but you {}can{} use the keywords "{}other{}" and "{}self{}" without issues. For example, using {}other{} in a {}collision event{}:':'注意，你不能在这个方法中使用特殊的{}关键字{}"{}all{}"来针对所有实例(例如 {}all.val= 10{}会出错)，但你{}可以{}使用关键字"{}other{}"和"{}self{}"，不会有问题。例如，在一个{}碰撞事件{}中使用{}other{}。',"Note that you cannot use the special {}keyword{}&nbsp;{}all{} with this method to target all instances (e.g.: {}all.val = 10;{} would give an error), but you {}can{} use the keywords {}other{} and {}self{} without issues. For example, using {}other{} in a {}collision event{}:":"请注意，您不能在此方法中使用特殊的 {} 关键字 {}{}all{} 来定位所有实例 (例如：{}all.val = 10;{} 会给出错误)，但您 {} 可以 {} 使用关键字 {}other{} 和 {}self{} 不会出现问题。例如，在 {} 碰撞事件{} 中使用 {}other{}：",'One of the most common methods of accessing or changing a variable in {}another {}instance is to use its object name as an identifier, and then use a point "{}.{}" to tell {}GameMaker{} that the variable being referenced should&nbsp;be assigned or changed within that specific object\'s instance. This is known as "dot notation", and its syntax is as follows:':'访问或改变{}另一个{}实例中的变量的最常见方法之一是使用其对象名称作为标识符，然后使用点"{}.{}"来告诉{}GameMaker{}，被引用的变量应该在该特定对象的实例中被分配或改变。这被称为 "点符号"，其语法如下。','One of the most common methods of accessing or changing a variable in {}another {}instance is to use its object name as an identifier, and then use a point {}.{} to tell {}GameMaker{} that the variable being referenced should&nbsp;be assigned or changed within that specific object\'s instance. This is known as "dot notation", and its syntax is as follows:':'在{}另一个{}实例中访问或更改变量的最常见方法之一是使用其对象名称作为标识符，然后使用点{}.{}告诉{}GameMaker{}该变量是引用应该在该特定对象的实例中分配或更改。这称为"点表示法"，其语法如下：',"The other way to reference variables in another instance is to use the GameMaker Language function {}with(){}, which is discussed in detail {}here{}:":"另一种引用另一个实例中的变量的方法是使用GameMaker语言函数{}with(){}，{}这里详细讨论过{}。","The other way to reference variables in another instance is to use the GameMaker Language statement {}with{}:&nbsp;":"在另一个实例中引用变量的另一种方法是使用 GameMaker 语言语句{}with{}：","The return value for the expression in that code example is an integer number (the unique ID value for the nearest instance) and so it must be enclosed in brackets {}( ){} to be used in this way and properly address the instance required. The above code would be correctly written as:":"该代码示例中表达式的返回值是一个整数(最近实例的唯一 ID 值)，因此必须将其括在方括号{}( ){}中才能以这种方式使用并正确寻址所需的实例。上面的代码可以正确写为：","The return value for the expression in that code example is an integer number (the unique ID value for the nearest instance) and so it must be enclosed in brackets {}(){} to be used in this way and properly address the instance required. The above code would be correctly written as:":"该代码示例中表达式的返回值是一个整数(最近实例的唯一Id值)，因此必须将其括在括号{}(){}中，才能以这种方式使用并正确处理所需的实例。上述代码将正确写入为：","These are all perfectly valid ways of reading, changing and setting variables in other instances, and work because the point is actually an {}operator{}. It takes a value as the left {}operand{} and a variable as the right operand, and returns the address of this particular variable in the indicated object or instance. All the object names, constants, IDs etc... simply represent values and these can be dealt with like any other value.":"这些都是读取、改变和设置其他实例中的变量的完全有效的方法，之所以有效是因为 点 实际上是一个{}操作符{}。它把一个值作为左{}操作数{}，把一个变量作为右操作数，并返回指定对象或实例中这个特定变量的地址。所有的对象名称、常量、ID等等......都只是代表值，这些都可以像其他值一样被处理。","These are all perfectly valid ways of reading, changing and setting variables in other instances, and work because the point is actually an {}operator{}. It takes a value as the left {}operand{} and a variable as the right operand, and returns the address of this particular variable in the indicated object or instance. All the object names, constants, IDs, etc., simply represent values and these can be dealt with like any other value.":"这些都是在其他实例中读取、更改和设置变量的完全有效的方法，并且之所以有效，是因为该点实际上是一个{}运算符{}。它采用一个值作为左{}操作数{}，一个变量作为右操作数，并返回指定对象或实例中该特定变量的地址。所有对象名称、常量、ID 等都简单地表示值，并且可以像处理任何其他值一样处理这些值。",'With the above code you are setting the speed of an instance of "{}obj_ball{}". However if you have more than one instance of the given object in the room, {}then it will apply to ALL of them equally{} - unless you are using {}HTML5{}, in which case it will affect only {}one{}, but you have no way of knowing which one it will affect - so if you need to access all instances of an object, you should be using {}{}with(){}{}, as that is 100% cross platform compatible. In general, this format should only be used when you have a single instance of the object in the room, or (as you will see in the next part) when you have a specific {}instance {}ID{}{}.':'通过上述代码，你正在设置"{}obj_ball{}"的一个实例的速度。然而，如果你在房间里有一个以上的对象实例，{}那么它将同样适用于所有对象{}--除非你使用{}HTML5{}，在这种情况下，它将只影响{}一个{}，但你无法知道它将影响哪一个--所以如果你需要访问一个对象的所有实例，你应该使用{}{}with(){}{}，因为那是100%跨平台兼容。一般来说，只有当你的房间里只有一个对象的实例，或者(正如你将在下一部分看到的)你有一个特定的{}实例{}ID{}{}时，才应该使用这种格式。',"With the above code you are setting the speed of an instance of {}obj_ball{}. However if you have more than one instance of the given object in the room, {}then it will apply to ALL of them equally{} - unless you are using {}HTML5{}, in which case it will affect only {}one{}, but you have no way of knowing which one it will affect - so if you need to access all instances of an object, you should be using {}{}with{}{}, as that is 100% cross-platform compatible. In general, this format should only be used when you have a single instance of the object in the room, or (as you will see in the next part) when you have a specific {}instance {}ID{}{}.":"通过上述代码，您可以设置{}obj_ball{}实例的速度。不过，如果房间中有多个给定对象的实例，{}那么它将同等地应用于所有实例{}- 除非您使用{}HTML5{}，在这种情况下，它将仅影响{}一个{}，但您无法知道它会影响哪一个 - 因此，如果您需要访问某个对象的所有实例，您应该使用{}{}with{}{}，因为这是 100% 跨平台的兼容的。一般来说，只有当您在房间中只有一个对象实例时，或者(正如您将在下一部分中看到的)当您有特定的{}实例{}ID{}{}时，才应使用此格式。","You can also access a single instance of an object when there are multiple instances within the room using the unique {}instance name{} to tell {}GameMaker{} exactly which instance we wish to address. The {}instance name constant{} is the unique identifying constant that is given to each and every instance added to a room in your game. You can find this constant by double clicking on an instance in the {}room editor{}:":"当房间内有多个实例时，您也可以使用唯一的{}实例名称{}来确切告诉{}GameMaker{}我们要处理的实例，从而访问该对象的单个实例。{}实例名称常量{}是游戏中添加到房间的每个实例的唯一标识常数。你可以在{}房间编辑器{}中双击一个实例来找到这个常量：","You can also access a single instance of an object when there are multiple instances within the room using the unique {}instance name{} to tell {}GameMaker{} exactly which instance we wish to address. The {}instance name constant{} is the unique identifying constant that is given to each and every instance added to a room in your game. You can find this constant by double-clicking on an instance in {}The Room Editor{}:":"当房间内有多个实例时，您还可以使用唯一的{}实例名称{}来访问对象的单个实例，以准确告知{}GameMaker{}我们希望访问哪个实例。{}实例名称常量{}是为添加到游戏房间中的每个实例指定的唯一标识常量。您可以通过双击{}房间编辑器{}中的实例来找到该常量：",'{}// This will affect all instances of the object "obj_Enemy"{}{} {}with{} (obj_Enemy){} {{} &nbsp; &nbsp; target = {}other{}.parent;{} }{} {} {}// This will affect one instance of the object "obj_Enemy"{}{} {}var{} _enemy = {}instance_nearest{}({}x{}, {}y{}, obj_Enemy);{} {}if{} {}instance_exists{}(_enemy){} {{} &nbsp; &nbsp; {}with{} (_enemy){} &nbsp; &nbsp; {{} &nbsp; &nbsp; &nbsp; &nbsp; target.{}x{} = {}mouse_x{};{} &nbsp; &nbsp; &nbsp; &nbsp; target.{}y{} = {}mouse_y{};{} &nbsp; &nbsp; }{} } ':'{}// 这将影响 "obj_Enemy"对象的所有实例{}{} {}with{} (obj_Enemy){} {{} &nbsp; &nbsp; target = {}other{}.parent;{} }{} {} {}// 这将影响 "obj_Enemy"对象的一个实例 {}{} {}var{} _enemy = {}instance_nearest{}({}x{}, {}y{}, obj_Enemy);{} {}if{} {}instance_exists{}(_enemy){} {{} &nbsp; &nbsp; {}with{} (_enemy){} &nbsp; &nbsp; {{} &nbsp; &nbsp; &nbsp; &nbsp; target.{}x{} = {}mouse_x{};{} &nbsp; &nbsp; &nbsp; &nbsp; target.{}y{} = {}mouse_y{};{} &nbsp; &nbsp; }{} } ',"{}Note that this name can be be edited and given a more descriptive name - although the name {}must{}&nbsp;be unique to the entire game -&nbsp;and it can be used as the left-hand side of the point:":"{}请注意，可以编辑此名称并赋予更描述性的名称-尽管名称{}必须{}对于整个游戏而言是唯一的-并且可以用作点的左侧:","{}{}NOTE{}{}&nbsp;In-game, this name is a handle to the instance. See&nbsp;{}Data Types{}&nbsp;for more info.":"{}{}注意{}{}在游戏中，此名称是实例的句柄。请参阅{}数据类型{}了解更多信息。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../..",gTopicId="8.2.1.1_3"</script><script type="text/javascript" src="../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Addressing Variables In Other Instances</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../assets/css/default.css" type="text/css"><script src="../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page outlining hoe to address variables in other instances"><meta name="rh-index-keywords" content="Addressing Variables In Other Instances"><meta name="search-keywords" content=""><meta name="brsnext" value="GameMaker_Language/GML_Overview/Expressions_And_Operators.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Language_Features/If_Else_and_Conditional_Operators.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Addressing Variables In Other Instances"><span>Addressing Variables In Other Instances</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>Addressing Variables In Other Instances</h1><p>In the sections dedicated to <a href="Variables_And_Variable_Scope.htm">variables</a> you found out how to create and use variables within a single instance, or on a global scope, but what happens if you want one instance to access a variable in another, different instance? There are many cases when you may want to do this, for example in a collision with a bullet object, you may want to find out how much damage the bullet does by accessing a variable in the bullet, or you might want to stop the motion of all the balls in a puzzle, or you might want to move the main character to a particular position, or any number of other situations you typically come across in any game. Thankfully the GameMaker Language comes equipped with mechanisms to achieve this.</p><p>One of the most common methods of accessing or changing a variable in <em>another</em> instance is to use its object name as an identifier, and then use a point <span class="inline2">.</span> to tell <span data-keyref="GameMaker Name">GameMaker</span> that the variable being referenced should&nbsp;be assigned or changed within that specific object's instance. This is known as "dot notation", and its syntax is as follows:</p><p class="code">&lt;object_id&gt;.&lt;<em>variable</em>&gt; = &lt;value&gt;;&nbsp;</p><p>In practice it would look like this:</p><p class="code">obj_ball.speed = 0;</p><p>With the above code you are setting the speed of an instance of <span class="inline2">obj_ball</span>. However if you have more than one instance of the given object in the room, <em>then it will apply to ALL of them equally</em> - unless you are using <b>HTML5</b>, in which case it will affect only <em>one</em>, but you have no way of knowing which one it will affect - so if you need to access all instances of an object, you should be using <span class="inline2"><a href="Language_Features/with.htm">with</a></span>, as that is 100% cross-platform compatible. In general, this format should only be used when you have a single instance of the object in the room, or (as you will see in the next part) when you have a specific <i>instance <b>ID</b></i>.</p><p>You can also access a single instance of an object when there are multiple instances within the room using the unique <b>instance name</b> to tell <span data-keyref="GameMaker Name">GameMaker</span> exactly which instance we wish to address. The <b>instance name constant</b> is the unique identifying constant that is given to each and every instance added to a room in your game. You can find this constant by double-clicking on an instance in <a href="../../The_Asset_Editors/Rooms.htm">The Room Editor</a>:</p><p><img alt="The instance constant in the room editor" class="center" src="../../assets/Images/Scripting_Reference/GML/Overview/Instance_Constant.png">Note that this name can be be edited and given a more descriptive name - although the name <em>must</em>&nbsp;be unique to the entire game -&nbsp;and it can be used as the left-hand side of the point:</p><p class="code">inst_4DB70D2.speed = 0;</p><div data-conref="../../assets/snippets/Note_Instance_Name_Stores_Handle_InGame.hts"><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;In-game, this name is a handle to the instance. See&nbsp;<a href="Data_Types.htm">Data Types</a>&nbsp;for more info.</p></div><p>By far the most common and practical method, however, is to use a&nbsp;<i>variable</i> on the left of the point, as long as the variable in question <i>has stored a valid <b>instance id</b></i>. The following examples illustrate this.</p><p class="code">// Example 1<br>var _inst = instance_position(mouse_x, mouse_y, all);<br>if (instance_exists(_inst))<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;_inst.speed = 0;<br>}<br><br>// Example 2<br>var _inst = instance_create_layer(mouse_x, mouse_y, "Enemies", obj_E_Parent);<br>_inst.direction = point_direction(_inst.x, _inst.y, x, y);<br>_inst.target = id;</p><p>In the above code for Example 1, there is an&nbsp;<span class="inline3_func"><a href="../GML_Reference/Asset_Management/Instances/instance_exists.htm">instance_exists</a></span> call in the code block. This is because using the point method to access or change another instances value will give an error and crash the game if the instance does not exist, and there is the possibility that this is the case in that example. We don't need the check however in Examples 2 and 3 because we <i>know</i> that the instance is there since in Example 2 we created it, and in Example 3, its the other instance in a collision event. However, if there is <i>any</i> possibility that the instance could be destroyed, deactivated, or otherwise removed from the room while using this method, you should <i>always</i> check beforehand using the&nbsp;<span class="inline3_func"><a href="../GML_Reference/Asset_Management/Instances/instance_exists.htm">instance_exists</a></span> function or the&nbsp;<span class="inline3_func"><a href="../GML_Reference/Asset_Management/Instances/instance_number.htm">instance_number</a></span> function.</p><p>Note that you cannot use the special <a href="Instance_Keywords.htm">keyword</a>&nbsp;<span class="inline2">all</span> with this method to target all instances (e.g.: <span class="inline2">all.val = 10;</span> would give an error), but you <i>can</i> use the keywords <span class="inline2">other</span> and <span class="inline2">self</span> without issues. For example, using <span class="inline2">other</span> in a <a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm">collision event</a>:</p><p class="code">// Example 3 other.hp -= 10;<br>if (other.hp &lt;= 0)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;other.sprite_index = spr_E_Dead;<br>}</p><p>It is also important to note that you cannot use&nbsp;any function by itself as the left-hand side of an assignment. For example, the following code would give you an error:</p><p class="code">instance_nearest(x, y, obj).speed = 0;</p><p>The return value for the expression in that code example is an integer number (the unique ID value for the nearest instance) and so it must be enclosed in brackets <span class="inline2">( )</span> to be used in this way and properly address the instance required. The above code would be correctly written as:</p><p class="code">(instance_nearest(x, y, obj)).speed = 0;<br><br>//or<br><br>var _inst = instance_nearest(x, y, obj);<br>_inst.speed = 0;</p><p>These are all perfectly valid ways of reading, changing and setting variables in other instances, and work because the point is actually an <i>operator</i>. It takes a value as the left <a class="tooltip" title="An operand is a term used to denote the values which can be manipulated using different operators. In the expression A + B + C, A, B and C are the operands.">operand</a> and a variable as the right operand, and returns the address of this particular variable in the indicated object or instance. All the object names, constants, IDs, etc., simply represent values and these can be dealt with like any other value.</p><p>The other way to reference variables in another instance is to use the GameMaker Language statement <a href="Language_Features/with.htm">with</a>:&nbsp;</p><p class="code">// This will affect all instances of the object "obj_Enemy"<br>with (obj_Enemy)<br>{<br>&nbsp; &nbsp; target = other.parent;<br>}<br><br>// This will affect one instance of the object "obj_Enemy"<br>var _enemy = instance_nearest(x, y, obj_Enemy);<br>if (instance_exists(_enemy))<br>{<br>&nbsp; &nbsp; with (_enemy)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; target.x = mouse_x;<br>&nbsp; &nbsp; &nbsp; &nbsp; target.y = mouse_y;<br>&nbsp; &nbsp; }<br>}</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="GML_Overview.htm">GML&nbsp;Overview</a></div><div style="float:right">Next:&nbsp;<a href="Expressions_And_Operators.htm">Expressions And Operators</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>