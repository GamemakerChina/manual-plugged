<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(t){return t=(t=(t=(t=t.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(t){return t.match(/(<([^>]+)>)/gi)},setTranslator=function(t,n,a){let e;e=a?t.attr(a):t.html();let l=n[removeHtml(e)];if(null!=l&&l.length){n=retHtml(e);let o=0;n&&n.forEach(function(t,n){var a=l.replace("{"+o+"}",t);l=a===l?l.replace("{}",t):a,o++}),a?t.attr(a,l):t.html(l)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){$(".header").length&&$(".header").append(`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`)},removeExtensionFromHash=function(t){return t.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")},$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption,blockquote").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption,.expandtext").each(function(){setTranslator($(this),json)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.1.2.0_1"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Static Struct</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Gurpreet S. Matharoo"><meta name="topic-comment" content="Page explaining static structs for constructor functions"><meta name="rh-index-keywords" content="Static Structs"><meta name="search-keywords" content="Static Structs, static_get, static_set, is_instanceof"><meta name="brsnext" value="GameMaker_Language/GML_Overview/Struct_Forbidden_Variables.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Structs.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Static Struct"><span>Static Struct</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Static Struct</span></h1><p>Every function has a "static struct", where its static variables are stored. You can get that struct using&nbsp;<span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/static_get.htm">static_get</a></span>:</p><p class="code">function counter()<br>{<br>&nbsp;&nbsp; &nbsp;static count = 0;<br>&nbsp;&nbsp; &nbsp;return count ++;<br>}<br><br>repeat (10)&nbsp;counter();<br><br>// Get static struct of counter()<br>var _static_counter = static_get(counter);<br><br>// Both of these read the same variable<br>show_debug_message(counter.count); // 10<br>show_debug_message(_static_counter.count); // 10</p><p>This is also true for <a href="../Structs.htm#constr">constructor functions</a>. Each constructor has a static struct, where its static variables and static methods are stored.</p><p>Every struct created from the constructor accesses its static variables from that static struct.</p><div data-conref="../../../assets/snippets/Note_Warning_Static_Struct_Call_Once.hts"><p class="note"><span data-conref="../../../assets/snippets/Tag_warning.hts"><span class="warning">WARNING</span></span>&nbsp;You can't access a static variable from a function that was never called, as static variables are initialised on the first call to a function. Trying to do so will give you an error and crash your game.</p></div><h2 id="h">Static Chain</h2><p>When you use constructor inheritance, those constructors form a "static chain" - a chain of static structs where each child links to its parent.</p><p>For example, let's say you have a constructor <span class="inline2">item</span>, and a constructor <span class="inline2">potion</span>&nbsp;which is a child of&nbsp;<span class="inline2">item</span>:</p><p class="code">function item() constructor {}<br><br>function potion() : item() constructor {}<br><br>var _potion = new potion();</p><p>You can get the static struct of <span class="inline2">potion</span> using <span class="inline2">static_get(potion)</span>&nbsp;- this is where the static variables for <span class="inline2">potion</span> are stored. Let's call this <span class="inline2">static_potion</span>.</p><p>Now, if you call <span class="inline2">static_get(static_potion)</span>, you will get the static struct for <span class="inline2">item</span>! This is the same struct you would get from <span class="inline2">static_get(item)</span>.</p><p class="code">function item () constructor {}<br>function potion () : item () constructor {}<br><br>var _potion = new potion();<br>var _static_potion = static_get(potion);<br><br>show_debug_message(static_get(item) == static_get(_static_potion)); // true (1)</p><p>This is because <span class="inline2">item</span> is the parent of the <span class="inline2">potion</span> constructor, so the static struct for <span class="inline2">item</span> is linked to the static struct for <span class="inline2">potion</span>.</p><p>The static structs of the top-level constructor functions, i.e. those that don't have a parent constructor, share the same parent struct. This struct is the "root" static struct, which has&nbsp;<span class="inline2">undefined</span>&nbsp;as its&nbsp;parent struct:&nbsp;</p><p class="code">var _static_item = static_get(item);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// the static struct of item<br>var _root = static_get(_static_item);&nbsp; &nbsp; &nbsp; &nbsp; // the static struct of all top-level static structs<br>var _must_be_undefined = static_get(_root);&nbsp; // undefined</p><p>This shared struct is the root parent struct of <em>all</em> structs and defines the default&nbsp;<span class="inline3_func">toString</span> function that's called when the struct is converted to string.</p><p>This means that you can get the full static chain of a struct as follows:</p><p class="code">static_chain = [];<br>var _node = static_get(potion);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // the static struct to start at<br>while (!is_undefined(_node))<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;array_push(static_chain, _node);<br>&nbsp;&nbsp; &nbsp;_node = static_get(_node);<br>};<br><br>array_foreach(static_chain, show_debug_message);&nbsp; &nbsp; &nbsp; &nbsp;// output the path to the root struct</p><h2>Same Variable Name in Parent &amp; Child Constructor</h2><p>As static variables belong to the constructor in which they're defined, it is possible to define a static variable in a child constructor with the same name as a static variable of the parent constructor. For example:&nbsp;</p><p class="code">function shape () constructor<br>{<br>&nbsp; &nbsp; static count = 0;<br>&nbsp; &nbsp; count++;<br>&nbsp; &nbsp;&nbsp;<br>&nbsp; &nbsp; static shapes = [];<br>&nbsp; &nbsp; array_push(shapes, self);<br>}<br>function rectangle () : shape () constructor<br>{<br>&nbsp; &nbsp;&nbsp;static count = 0;<br>&nbsp; &nbsp; count++;<br>}<br>function square () : rectangle () constructor<br>{<br>&nbsp; &nbsp; static count = 0;<br>&nbsp; &nbsp; count++;<br>}<br>function ellipse () : shape () constructor<br>{<br>&nbsp; &nbsp; static count = 0;<br>&nbsp; &nbsp; count++;<br>}</p><p>Each shape now has its own <span class="inline2">count</span>&nbsp;static variable that keeps track of the number of items of that shape. Child shapes will increment the <span class="inline2">count</span> of their parent shapes as well, as they run their parents' constructors in addition to their own.</p><p class="code">s1 = new shape();&nbsp; &nbsp; &nbsp; &nbsp; // Added 1 shape<br>s2 = new rectangle();&nbsp; &nbsp; // Added 1 rectangle (and therefore also 1 shape)<br>s3 = new square();&nbsp; &nbsp; &nbsp; &nbsp;// Added 1 square (and therefore also 1 rectangle and 1 shape)<br>s4 = new ellipse();&nbsp; &nbsp; &nbsp; // Added 1 ellipse (and therefore also 1 shape)<br><br>show_debug_message($"Number of shapes: {shape.count}");&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 4<br>show_debug_message($"Number of rectangles: {rectangle.count}");&nbsp; // 2<br>show_debug_message($"Number of squares: {square.count}");&nbsp; &nbsp; &nbsp; &nbsp; // 1<br>show_debug_message($"Number of ellipses: {ellipse.count}");&nbsp; &nbsp; &nbsp; // 1</p><h2 id="h2">How the Dot Operator Looks Up a Variable Name</h2><p>Let's say you're looking for a specific variable in a struct, using the dot operator (i.e. <span class="inline2">struct.variable_name</span>).</p><p>If the struct contains a non-static variable with that name, the dot operator returns that variable. If it doesn't, the dot operator returns the first variable in the static chain with that name, checking the current static struct, and then traversing back the entire static chain, if needed, until a variable with that name is encountered.&nbsp;If the variable name cannot be found anywhere in the static chain,&nbsp;<span data-keyref="GameMaker Name">GameMaker</span>&nbsp;will throw an error.</p><p>For example:</p><p class="code">function root() constructor<br>{<br>&nbsp; &nbsp; static show = function()<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; show_debug_message("root");<br>&nbsp; &nbsp; }<br>}<br><br>function child() : root() constructor { }<br><br>function child_with_static_func() : root() constructor<br>{<br>&nbsp; &nbsp; static show = function()<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; show_debug_message("child_with_static_func");<br>&nbsp; &nbsp; }<br>}<br><br>function child_with_func() : root() constructor<br>{<br>&nbsp; &nbsp; show = function()<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; show_debug_message("child_with_func");<br>&nbsp; &nbsp; }<br>}<br><br>child1 = new child();<br>child1.show();<br><br>child2 = new child_with_static_func();<br>child2.show();<br><br>child3 = new child_with_func();<br>child3.show();</p><p>The following happens in the above code:&nbsp;</p><ul class="colour"><li><span class="inline2">child1</span>&nbsp;is a <span class="inline2">child</span>, which has no <span class="inline3_func">show()</span> method of its own but inherits from <span class="inline2">root</span>. <span class="inline3_func">root.show()</span> is called and <span class="inline2">"root"</span> is output.</li><li><span class="inline2">child2</span> is a <span class="inline2">child_with_static_func</span>, which has a static <span class="inline2">show()</span>&nbsp;method. This method is called, which outputs <span class="inline2">"child_with_static_func"</span>.</li><li><span class="inline2">child3</span> is a <span class="inline2">child_with_func</span>, which inherits from <span class="inline2">root</span> but also has its own (non-static)&nbsp;<span class="inline3_func">show()</span> method. It calls its own <span class="inline3_func">show()</span> method, outputting <span class="inline2">"child_with_func"</span>.</li></ul><h2>Parent's Static Variable or Method</h2><p>In certain situations you may want to access a static variable or method of the parent constructor from within the child constructor. To achieve this, you can go up the static chain and access the parent's static variable:&nbsp;</p><p class="code">function parent() constructor<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;static init = function() { show_debug_message("Parent Innit?"); }<br>}<br><br>function child() : parent() constructor<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;static init = function()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var _static = static_get(self);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var _static_parent = static_get(_static);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_static_parent.init(); // Calls the parent's init()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_debug_message("Child Innit!");<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p><h2>Checking Inheritance</h2><p>You can use&nbsp;<span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/is_instanceof.htm">is_instanceof</a></span>&nbsp;to check if a struct belongs to the given constructor, or has the constructor as a parent.</p><p>This is done by checking if your struct has the given constructor's static struct anywhere in its static chain.</p><div data-conref="../../../assets/snippets/is_instanceof_example.hts"><p class="code">function item() constructor {}<br><br>function potion() : item() constructor {}<br><br>function enemy() constructor {}<br><br>var _potion = new potion();<br><br>show_debug_message(is_instanceof(_potion, potion)); // true (1)<br>show_debug_message(is_instanceof(_potion, item)); // true (1)<br>show_debug_message(is_instanceof(_potion, enemy)); // false (0)</p><p>The above code shows three constructors:&nbsp;<span class="inline2">item</span>, <span class="inline2">potion</span> which is a child of <span class="inline2">item</span>, and <span class="inline2">enemy</span>, which is a separate constructor.</p><p>It creates a struct from the <span class="inline2">potion</span> constructor. Using <span class="inline2">is_instanceof()</span>, we can check that the new struct:</p><ul class="colour"><li>is a <span class="inline2">potion</span></li><li>is an <span class="inline2">item</span></li><li>is not an <span class="inline2">enemy</span></li></ul><p>This way you can check whether a struct "is" something, as <strong>a potion is an item</strong>, so it returns <span class="inline2">true</span> for both constructors. However if wouldn't be true the other way around: <strong>an item is not a potion</strong>.</p></div><h2 id="h1">Changing The Static Struct</h2><p>The function&nbsp;<span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/static_set.htm">static_set</a></span>&nbsp;is provided to let you change the static struct of a function (constructor or not). This way you can change what static variables are available to a constructor and its structs, and also change the "static chain" that a constructor belongs to.</p><p>The recommended use-case for this function is deserialisation. If you're loading structs from JSON, those structs won't belong to any constructors, however you can change that by using&nbsp;<span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/static_set.htm">static_set</a></span>&nbsp;to "apply" a constructor to a struct, so that that struct receives its shared static variables and you can run&nbsp;<span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/is_instanceof.htm">is_instanceof</a></span>&nbsp;to check its kind.</p><div data-conref="../../../assets/snippets/static_set_example.hts"><p class="code">var _potion = json_parse(_json_string);<br><br>show_debug_message(is_instanceof(_potion, potion)); // false (0)<br><br>var _static_potion = static_get(potion);<br>static_set(_potion, _static_potion);<br><br>show_debug_message(is_instanceof(_potion, potion)); // true (1)</p><p>In the code above, upon loading the potion struct from a JSON string, it's only created as a simple struct and doesn't belong to a constructor, nor does it have any static variables.</p><p>After applying the static struct for <span class="inline2">potion</span> to it (which is a constructor), it becomes an instance of <span class="inline2">potion</span> (as tested with <span class="inline2">is_instanceof()</span>) and also gets any static variables and static methods contained in the <span class="inline2">potion</span> constructor.</p></div><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../Structs.htm">Structs</a></div><div style="float:right">Next:&nbsp;<a href="../Struct_Forbidden_Variables.htm">Struct Forbidden Variables</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>