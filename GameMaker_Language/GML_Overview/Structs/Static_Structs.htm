<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../../assets/import/main.css"><script>let str;removeHtml=function(t){return t=(t=(t=(t=t.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(t){return t.match(/(<([^>]+)>)/gi)},setTranslator=function(t,o,a){let n;n=a?t.attr(a):t.html();let s=o[removeHtml(n)];if(null!=s&&s.length){o=retHtml(n);let e=0;o&&o.forEach(function(t,o){var a=s.replace("{"+e+"}",t);s=a===s?s.replace("{}",t):a,e++}),a?t.attr(a,s):t.html(s)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var t=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(t):($(".topic-header").append(t),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(t){return t.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"After applying the static struct for {}potion{} to it (which is a constructor), it becomes an instance of {}potion{} (as tested with {}is_instanceof(){}) and also gets any static variables and static methods contained in the {}potion{} constructor.":"在将 {}potion{} 的静态结构应用于它之后，它将成为 {}potion{} 的实例 (如用 {}is_instanceof(){} 测试的那样)，并且还获得包含在 {}potion{} 构造函数中的任何静态变量和静态方法。","After applying the static struct for {}potion{} to it, it becomes an instance of {}potion{} (as tested with {}{}is_instanceof{}(){}) and also gets any static variables and static methods contained in the {}potion{} constructor.":"在将 {}potion{} 的静态结构应用于它之后，它将成为 {}potion{} 的实例 (如用 {}{}is_instanceof{}(){} 测试的那样)，并且还获得包含在 {}potion{} 构造函数中的任何静态变量和静态方法。","As static variables belong to the constructor in which they're defined, it is possible to define a static variable in a child constructor with the same name as a static variable of the parent constructor. For example:&nbsp;":"由于静态变量属于定义它们的构造函数，因此可以在子构造函数中定义与父构造函数的静态变量同名的静态变量。例如：","Changing The Static Struct":"改变静态结构","Checking Inheritance":"检查多重继承","Each shape now has its own {}count{}&nbsp;static variable that keeps track of the number of items of that shape. Child shapes will increment the {}count{} of their parent shapes as well, as they run their parents' constructors in addition to their own.":"现在，每个形状都有自己的{}count{}静态变量，用于跟踪该形状的项目数量。子形状也会增加其父形状的{}计数{}，因为它们除了运行自己的构造函数之外，还运行父形状的构造函数。",'Every function has a "static struct", where its static variables are stored. You can get that struct using&nbsp;{}{}static_get{}{}:':'每个函数都有一个"静态结构"，其中存储了它的静态变量。您可以使用{}{}static_get{}{}获取该结构：',"Every struct created from the constructor accesses its static variables from that static struct.":"从构造函数创建的每个结构都从该静态结构访问其静态变量。","For example, let's say you have a constructor {}item{}, and a constructor {}potion{}&nbsp;which is a child of&nbsp;{}item{}:":"例如，假设您有一个构造函数 {}item{}，以及一个构造函数 {}potion{}，它是 {}item{} 的子级：","How the Dot Operator Looks Up a Variable Name":"点运算符如何查找变量名称","If the struct contains a non-static variable with that name, the dot operator returns that variable. If it doesn't, the dot operator returns the first variable in the static chain with that name, checking the current static struct, and then traversing back the entire static chain, if needed, until a variable with that name is encountered.&nbsp;If the variable name cannot be found anywhere in the static chain,&nbsp;{}GameMaker{}&nbsp;will throw an error.":"如果该结构包含具有该名称的非静态变量，则点运算符返回该变量。如果没有，点运算符返回静态​​链中具有该名称的第一个变量，检查当前静态结构，然后根据需要遍历整个静态链，直到遇到具有该名称的变量。如果在静态链中的任何位置都找不到变量名称，{}GameMaker{}将抛出错误。","In certain situations you may want to access a static variable or method of the parent constructor from within the child constructor. To achieve this, you can go up the static chain and access the parent's static variable:&nbsp;":"在某些情况下，您可能希望从子构造函数中访问父构造函数的静态变量或方法。为了实现这一点，您可以沿着静态链向上访问父级的静态变量：","In the code above, upon loading the potion struct from a JSON string, it's only created as a simple struct and doesn't belong to a constructor, nor does it have any static variables.":"在上面的代码中，从 JSON 字符串加载 potion 结构时，它只被创建为一个简单的结构，不属于构造函数，也没有任何静态变量。","In the code above, upon loading the potion struct, it's only created as a simple struct and doesn't belong to a constructor, nor does it have any static variables.":"在上面的代码中，在加载 potion 结构时，它只被创建为一个简单的结构，不属于构造函数，也没有任何静态变量。","It creates a struct from the {}potion{} constructor. Using {}is_instanceof(){}, we can check that the new struct:":"它从 {}potion{} 构造函数创建一个结构。使用 {}is_instanceof(){}，我们可以检查新结构：","Let's say you're looking for a specific variable in a struct, using the dot operator (i.e. {}struct.variable_name{}).":"假设您正在使用点运算符(即{}struct.variable_name{})在结构体中查找特定变量。","Now, if you call {}static_get(static_potion){}, you will get the static struct for {}item{}! This is the same struct you would get from {}static_get(item){}.":"现在，如果您调用 {}static_get(static_potion){}，您将获得 {}item{} 的静态结构！这与您从 {}static_get(item){} 获得的结构相同。","Parent's Static Variable or Method":"父级的静态变量或方法","Same Variable Name in Parent &amp; Child Constructor":"父级和父级中的变量名称相同子构造函数","Static Chain":"静态链","The above code shows three constructors:&nbsp;{}item{}, {}potion{} which is a child of {}item{}, and {}enemy{}, which is a separate constructor.":"上面的代码显示了三个构造函数：{}item{}，{}potion{}，它是 {}item{} 的子类，以及 {}enemy{}，它是一个单独的构造函数。","The following happens in the above code:&nbsp;":"上面的代码中发生了以下情况：",'The function&nbsp;{}{}static_set{}{}&nbsp;is provided to let you change the static struct of a function (constructor or not). This way you can change what static variables are available to a constructor and its structs, and also change the "static chain" that a constructor belongs to.':'函数 {}{}static_set{}{} 允许您更改函数的静态结构 (构造函数或非构造函数)。通过这种方式，您可以更改构造函数及其结构可用的静态变量，还可以更改构造函数所属的 " 静态链"。',"The recommended use-case for this function is deserialisation. If you're loading structs from JSON, those structs won't belong to any constructors, however you can change that by using&nbsp;{}{}static_set{}{}&nbsp;to \"apply\" a constructor to a struct, so that that struct receives its shared static variables and you can run&nbsp;{}{}is_instanceof{}{}&nbsp;to check its kind.":'此函数的推荐用例是反序列化。如果您从 JSON 加载结构，那么这些结构将不属于任何构造函数，但是您可以通过使用 {}{}static_set{}{} 将构造函数 " 应用 " 到一个结构，以便该结构接收其共享的静态变量，并且您可以运行 {}{}is_instanceof{}{} 来检查其类型。','The static structs of the top-level constructor functions, i.e. those that don\'t have a parent constructor, share the same parent struct. This struct is the "root" static struct, which has&nbsp;{}undefined{}&nbsp;as its&nbsp;parent struct:&nbsp;':'顶级构造函数的静态结构(即那些没有父构造函数的静态结构)共享相同的父结构。该结构是"根"静态结构，其父结构为{}undefined{}：',"This is also true for {}constructor functions{}. Each constructor has a static struct, where its static variables and static methods are stored.":"对于{}构造函数{}也是如此。每个构造函数都有一个静态结构，其中存储了它的静态变量和静态方法。","This is because {}item{} is the parent of the {}potion{} constructor, so the static struct for {}item{} is linked to the static struct for {}potion{}.":"这是因为 {}item{} 是 {}potion{} 构造函数的父级，因此 {}item{} 的静态结构链接到 {}potion{} 的静态结构。","This is done by checking if your struct has the given constructor's static struct anywhere in its static chain.":"这是通过检查结构是否在其静态链中的任何位置具有给定构造函数的静态结构来完成的。","This means that you can get the full static chain of a struct as follows:":"这意味着您可以获取结构的完整静态链，如下所示：","This shared struct is the root parent struct of {}all{} structs and defines the default&nbsp;{}toString{} function that's called when the struct is converted to string.":"此共享结构是{}所有{}结构的根父结构，并定义在结构转换为字符串时调用的默认{}toString{}函数。",'This way you can check whether a struct "is" something, as {}a potion is an item{}, so it returns {}true{} for both constructors. However if wouldn\'t be true the other way around: {}an item is not a potion{}.':'通过这种方式，您可以检查结构是否"是"某物，因为 {}potion 是 item{}，因此它为两个构造函数返回 {}true{}。然而，如果不是真的，反过来：{} item 不是 potion {}。','When you use constructor inheritance, those constructors form a "static chain" - a chain of static structs where each child links to its parent.':'当您使用构造函数继承时，这些构造函数形成一个"静态链" -- 一个静态结构链，其中每个子级都链接到其父级。',"You can get the static struct of {}potion{} using {}static_get(potion){}&nbsp;- this is where the static variables for {}potion{} are stored. Let's call this {}static_potion{}.":"您可以使用 {}static_get(potion){} 获取 {}potion{} 的静态结构-这是存储 {}potion{} 的静态变量的位置。让我们将其称为 {}static_potion{}。","You can use&nbsp;{}{}is_instanceof{}{}&nbsp;to check if a struct belongs to the given constructor, or has the constructor as a parent.":"您可以使用 {}{}is_instanceof{}{} 来检查结构是否属于给定的构造函数，或者是否将该构造函数作为父构造函数。","is a {}potion{}":"是一个 {}potion{}","is an {}item{}":"是一个 {}item{}","is not an {}enemy{}":"不是一个 {}enemy{}","{}Static Struct{}":"{}静态结构{}",'{}child1{}&nbsp;is a {}child{}, which has no {}show(){} method of its own but inherits from {}root{}. {}root.show(){} is called and {}"root"{} is output.':'{}child1{}是一个{}child{}，它没有自己的{}show(){}方法，但继承自{}root{}。调用{}root.show(){}并输出{}"root"{}。','{}child2{} is a {}child_with_static_func{}, which has a static {}show(){}&nbsp;method. This method is called, which outputs {}"child_with_static_func"{}.':'{}child2{}是一个{}child_with_static_func{}，它具有静态{}show(){}方法。调用此方法会输出{}"child_with_static_func"{}。','{}child3{} is a {}child_with_func{}, which inherits from {}root{} but also has its own (non-static)&nbsp;{}show(){} method. It calls its own {}show(){} method, outputting {}"child_with_func"{}.':'{}child3{}是一个{}child_with_func{}，它继承自{}root{}，但也有自己的(非静态){}show(){}方法。它调用自己的{}show(){}方法，输出{}"child_with_func"{}。',"{}{}WARNING{}{}&nbsp;You can't access a static variable from a function that was never called, as static variables are initialised on the first call to a function. Trying to do so will give you an error and crash your game.":"{}{}警告{}{}您无法从从未调用过的函数访问静态变量，因为静态变量是在第一次调用函数时初始化的。尝试这样做将会出现错误并导致游戏崩溃。","{}{}{}Static{} Struct{}{}":"{}{}{}静态{}结构{}{}"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(t){json_global=t}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../../..",gTopicId="8.2.1.2.0_1"</script><script type="text/javascript" src="../../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Static Struct</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../../assets/css/default.css" type="text/css"><script src="../../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Gurpreet S. Matharoo"><meta name="topic-comment" content="Page explaining static structs for constructor functions"><meta name="rh-index-keywords" content="Static Structs"><meta name="search-keywords" content="Static Structs, static_get, static_set, is_instanceof"><meta name="brsnext" value="GameMaker_Language/GML_Overview/Struct_Forbidden_Variables.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Structs.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Static Struct"><span>Static Struct</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Static Struct</span></h1><p>Every function has a "static struct", where its static variables are stored. You can get that struct using&nbsp;<span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/static_get.htm">static_get</a></span>:</p><p class="code">function counter()<br>{<br>&nbsp;&nbsp; &nbsp;static count = 0;<br>&nbsp;&nbsp; &nbsp;return count ++;<br>}<br><br>repeat (10)&nbsp;counter();<br><br>// Get static struct of counter()<br>var _static_counter = static_get(counter);<br><br>// Both of these read the same variable<br>show_debug_message(counter.count); // 10<br>show_debug_message(_static_counter.count); // 10</p><p>This is also true for <a href="../Structs.htm#constr">constructor functions</a>. Each constructor has a static struct, where its static variables and static methods are stored.</p><p>Every struct created from the constructor accesses its static variables from that static struct.</p><div data-conref="../../../assets/snippets/Note_Warning_Static_Struct_Call_Once.hts"><p class="note"><span data-conref="../../../assets/snippets/Tag_warning.hts"><span class="warning">WARNING</span></span>&nbsp;You can't access a static variable from a function that was never called, as static variables are initialised on the first call to a function. Trying to do so will give you an error and crash your game.</p></div><h2 id="h">Static Chain</h2><p>When you use constructor inheritance, those constructors form a "static chain" - a chain of static structs where each child links to its parent.</p><p>For example, let's say you have a constructor <span class="inline2">item</span>, and a constructor <span class="inline2">potion</span>&nbsp;which is a child of&nbsp;<span class="inline2">item</span>:</p><p class="code">function item() constructor {}<br><br>function potion() : item() constructor {}<br><br>var _potion = new potion();</p><p>You can get the static struct of <span class="inline2">potion</span> using <span class="inline2">static_get(potion)</span>&nbsp;- this is where the static variables for <span class="inline2">potion</span> are stored. Let's call this <span class="inline2">static_potion</span>.</p><p>Now, if you call <span class="inline2">static_get(static_potion)</span>, you will get the static struct for <span class="inline2">item</span>! This is the same struct you would get from <span class="inline2">static_get(item)</span>.</p><p class="code">function item () constructor {}<br>function potion () : item () constructor {}<br><br>var _potion = new potion();<br>var _static_potion = static_get(potion);<br><br>show_debug_message(static_get(item) == static_get(_static_potion)); // true (1)</p><p>This is because <span class="inline2">item</span> is the parent of the <span class="inline2">potion</span> constructor, so the static struct for <span class="inline2">item</span> is linked to the static struct for <span class="inline2">potion</span>.</p><p>The static structs of the top-level constructor functions, i.e. those that don't have a parent constructor, share the same parent struct. This struct is the "root" static struct, which has&nbsp;<span class="inline2">undefined</span>&nbsp;as its&nbsp;parent struct:&nbsp;</p><p class="code">var _static_item = static_get(item);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// the static struct of item<br>var _root = static_get(_static_item);&nbsp; &nbsp; &nbsp; &nbsp; // the static struct of all top-level static structs<br>var _must_be_undefined = static_get(_root);&nbsp; // undefined</p><p>This shared struct is the root parent struct of <em>all</em> structs and defines the default&nbsp;<span class="inline3_func">toString</span> function that's called when the struct is converted to string.</p><p>This means that you can get the full static chain of a struct as follows:</p><p class="code">static_chain = [];<br>var _node = static_get(potion);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // the static struct to start at<br>while (!is_undefined(_node))<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;array_push(static_chain, _node);<br>&nbsp;&nbsp; &nbsp;_node = static_get(_node);<br>};<br><br>array_foreach(static_chain, show_debug_message);&nbsp; &nbsp; &nbsp; &nbsp;// output the path to the root struct</p><h2>Same Variable Name in Parent &amp; Child Constructor</h2><p>As static variables belong to the constructor in which they're defined, it is possible to define a static variable in a child constructor with the same name as a static variable of the parent constructor. For example:&nbsp;</p><p class="code">function shape () constructor<br>{<br>&nbsp; &nbsp; static count = 0;<br>&nbsp; &nbsp; count++;<br>&nbsp; &nbsp;&nbsp;<br>&nbsp; &nbsp; static shapes = [];<br>&nbsp; &nbsp; array_push(shapes, self);<br>}<br>function rectangle () : shape () constructor<br>{<br>&nbsp; &nbsp;&nbsp;static count = 0;<br>&nbsp; &nbsp; count++;<br>}<br>function square () : rectangle () constructor<br>{<br>&nbsp; &nbsp; static count = 0;<br>&nbsp; &nbsp; count++;<br>}<br>function ellipse () : shape () constructor<br>{<br>&nbsp; &nbsp; static count = 0;<br>&nbsp; &nbsp; count++;<br>}</p><p>Each shape now has its own <span class="inline2">count</span>&nbsp;static variable that keeps track of the number of items of that shape. Child shapes will increment the <span class="inline2">count</span> of their parent shapes as well, as they run their parents' constructors in addition to their own.</p><p class="code">s1 = new shape();&nbsp; &nbsp; &nbsp; &nbsp; // Added 1 shape<br>s2 = new rectangle();&nbsp; &nbsp; // Added 1 rectangle (and therefore also 1 shape)<br>s3 = new square();&nbsp; &nbsp; &nbsp; &nbsp;// Added 1 square (and therefore also 1 rectangle and 1 shape)<br>s4 = new ellipse();&nbsp; &nbsp; &nbsp; // Added 1 ellipse (and therefore also 1 shape)<br><br>show_debug_message($"Number of shapes: {shape.count}");&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 4<br>show_debug_message($"Number of rectangles: {rectangle.count}");&nbsp; // 2<br>show_debug_message($"Number of squares: {square.count}");&nbsp; &nbsp; &nbsp; &nbsp; // 1<br>show_debug_message($"Number of ellipses: {ellipse.count}");&nbsp; &nbsp; &nbsp; // 1</p><h2 id="h2">How the Dot Operator Looks Up a Variable Name</h2><p>Let's say you're looking for a specific variable in a struct, using the dot operator (i.e. <span class="inline2">struct.variable_name</span>).</p><p>If the struct contains a non-static variable with that name, the dot operator returns that variable. If it doesn't, the dot operator returns the first variable in the static chain with that name, checking the current static struct, and then traversing back the entire static chain, if needed, until a variable with that name is encountered.&nbsp;If the variable name cannot be found anywhere in the static chain,&nbsp;<span data-keyref="GameMaker Name">GameMaker</span>&nbsp;will throw an error.</p><p>For example:</p><p class="code">function root() constructor<br>{<br>&nbsp; &nbsp; static show = function()<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; show_debug_message("root");<br>&nbsp; &nbsp; }<br>}<br><br>function child() : root() constructor { }<br><br>function child_with_static_func() : root() constructor<br>{<br>&nbsp; &nbsp; static show = function()<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; show_debug_message("child_with_static_func");<br>&nbsp; &nbsp; }<br>}<br><br>function child_with_func() : root() constructor<br>{<br>&nbsp; &nbsp; show = function()<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; show_debug_message("child_with_func");<br>&nbsp; &nbsp; }<br>}<br><br>child1 = new child();<br>child1.show();<br><br>child2 = new child_with_static_func();<br>child2.show();<br><br>child3 = new child_with_func();<br>child3.show();</p><p>The following happens in the above code:&nbsp;</p><ul class="colour"><li><span class="inline2">child1</span>&nbsp;is a <span class="inline2">child</span>, which has no <span class="inline3_func">show()</span> method of its own but inherits from <span class="inline2">root</span>. <span class="inline3_func">root.show()</span> is called and <span class="inline2">"root"</span> is output.</li><li><span class="inline2">child2</span> is a <span class="inline2">child_with_static_func</span>, which has a static <span class="inline2">show()</span>&nbsp;method. This method is called, which outputs <span class="inline2">"child_with_static_func"</span>.</li><li><span class="inline2">child3</span> is a <span class="inline2">child_with_func</span>, which inherits from <span class="inline2">root</span> but also has its own (non-static)&nbsp;<span class="inline3_func">show()</span> method. It calls its own <span class="inline3_func">show()</span> method, outputting <span class="inline2">"child_with_func"</span>.</li></ul><h2>Parent's Static Variable or Method</h2><p>In certain situations you may want to access a static variable or method of the parent constructor from within the child constructor. To achieve this, you can go up the static chain and access the parent's static variable:&nbsp;</p><p class="code">function parent() constructor<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;static init = function() { show_debug_message("Parent Innit?"); }<br>}<br><br>function child() : parent() constructor<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;static init = function()<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var _static = static_get(self);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var _static_parent = static_get(_static);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;_static_parent.init(); // Calls the parent's init()<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;show_debug_message("Child Innit!");<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p><h2>Checking Inheritance</h2><p>You can use&nbsp;<span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/is_instanceof.htm">is_instanceof</a></span>&nbsp;to check if a struct belongs to the given constructor, or has the constructor as a parent.</p><p>This is done by checking if your struct has the given constructor's static struct anywhere in its static chain.</p><div data-conref="../../../assets/snippets/is_instanceof_example.hts"><p class="code">function item() constructor {}<br><br>function potion() : item() constructor {}<br><br>function enemy() constructor {}<br><br>var _potion = new potion();<br><br>show_debug_message(is_instanceof(_potion, potion)); // true (1)<br>show_debug_message(is_instanceof(_potion, item)); // true (1)<br>show_debug_message(is_instanceof(_potion, enemy)); // false (0)</p><p>The above code shows three constructors:&nbsp;<span class="inline2">item</span>, <span class="inline2">potion</span> which is a child of <span class="inline2">item</span>, and <span class="inline2">enemy</span>, which is a separate constructor.</p><p>It creates a struct from the <span class="inline2">potion</span> constructor. Using <span class="inline2">is_instanceof()</span>, we can check that the new struct:</p><ul class="colour"><li>is a <span class="inline2">potion</span></li><li>is an <span class="inline2">item</span></li><li>is not an <span class="inline2">enemy</span></li></ul><p>This way you can check whether a struct "is" something, as <strong>a potion is an item</strong>, so it returns <span class="inline2">true</span> for both constructors. However if wouldn't be true the other way around: <strong>an item is not a potion</strong>.</p></div><h2 id="h1">Changing The Static Struct</h2><p>The function&nbsp;<span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/static_set.htm">static_set</a></span>&nbsp;is provided to let you change the static struct of a function (constructor or not). This way you can change what static variables are available to a constructor and its structs, and also change the "static chain" that a constructor belongs to.</p><p>The recommended use-case for this function is deserialisation. If you're loading structs from JSON, those structs won't belong to any constructors, however you can change that by using&nbsp;<span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/static_set.htm">static_set</a></span>&nbsp;to "apply" a constructor to a struct, so that that struct receives its shared static variables and you can run&nbsp;<span class="inline3_func"><a href="../../GML_Reference/Variable_Functions/is_instanceof.htm">is_instanceof</a></span>&nbsp;to check its kind.</p><div data-conref="../../../assets/snippets/static_set_example.hts"><p class="code">var _potion = json_parse(_json_string);<br><br>show_debug_message(is_instanceof(_potion, potion)); // false (0)<br><br>var _static_potion = static_get(potion);<br>static_set(_potion, _static_potion);<br><br>show_debug_message(is_instanceof(_potion, potion)); // true (1)</p><p>In the code above, upon loading the potion struct from a JSON string, it's only created as a simple struct and doesn't belong to a constructor, nor does it have any static variables.</p><p>After applying the static struct for <span class="inline2">potion</span> to it (which is a constructor), it becomes an instance of <span class="inline2">potion</span> (as tested with <span class="inline2">is_instanceof()</span>) and also gets any static variables and static methods contained in the <span class="inline2">potion</span> constructor.</p></div><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="../Structs.htm">Structs</a></div><div style="float:right">Next:&nbsp;<a href="../Struct_Forbidden_Variables.htm">Struct Forbidden Variables</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>