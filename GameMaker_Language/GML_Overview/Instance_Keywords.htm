<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,n){let s;s=n?e.attr(n):e.html();let o=t[removeHtml(s)];if(null!=o&&o.length){t=retHtml(s);let a=0;t&&t.forEach(function(e,t){var n=o.replace("{"+a+"}",e);o=n===o?o.replace("{}",e):n,a++}),n?e.attr(n,o):e.html(o)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={'A collision event can only happen between {}two {}instances. You {}can{} have multiple collisions between multiple instances, but they are all resolved by {}GameMaker{} on a 1-on-1 basis, with the "self" instance that has the collision event and the "other" instance that is colliding with it.':'碰撞事件只能发生在{}两个{}实例之间。{}可以{}在多个实例之间有多个碰撞，但{}GameMaker{}会以1对1的方式解决这些冲突，具有冲突事件的"self"实例和与其冲突的"other"实例。',"All instances currently active in the room.":"房间中当前处于活动状态的所有实例。","Collision Event":"碰撞事件","Constructor Function":"构造函数","Create Event":"创建事件","Do note that in events other than the&nbsp;collision event, when outside of any function calls and {}with(){} blocks, {}other{} simply returns the struct for the current instance.":"请注意，在碰撞事件之外的事件中，当在任何函数调用和{}with(){}块之外时，{}other{}只是返回当前实例的结构。",'For example, let\'s say {}Object2{} has a method that references {}self{} and {}other{}. This method is then called in {}Object1{}. Since the method was created in {}Object2{}, it is&nbsp;{}bound{}&nbsp;to it and will always use the {}Object2{}&nbsp;instance as the "self", no matter which instance calls it. In such a case, the calling instance becomes&nbsp;{}other{}.':"例如，假设{}Object2{}有一个引用{}self{}和{}other{}的方法。然后在{}Object1{}中调用该方法。由于方法是在{}Object2{}中创建的，所以它与{}绑定{} 并始终使用{}Object2{} 实例作为“self”，无论哪个实例调用它。在这种情况下，调用实例变成 {}other{}。","For this, the player will need to have a collision event with {}obj_Bullet{}, and within that event use {}other{} to read variables from the colliding bullet instance:":"为此，玩家需要与{}obj_Bullet{}发生碰撞事件，并在该事件中使用{}other{}从碰撞项目符号实例读取变量：","However, you do not need to use {}other{} to read variables from the instance as any variables you reference directly will be read from that instance's scope, as described {}in this section{} of the manual. You would only need to use this if you wanted to store a reference to that instance's struct.":"但是，您不需要使用{}other{}从实例中读取变量，因为您直接引用的任何变量都将从该实例的作用域中读取，如手册{}本节{}中所述。只有当您希望存储对该实例的结构的引用时，才需要使用此方法。","If the function returns an instance, the code between the curly braces {}{ }{} will run once. If the functions returns {}noone{}, the code won't be executed.":"如果函数返回一个实例，则大括号{}{ }{}之间的代码将运行一次。如果函数返回{}noone{}，则不会执行代码。","Imagine you have a player instance, multiple enemy instances and multiple bullet instances that the enemy can fire at you. You can assign each enemy a single bullet instance but with a different damage variable randomly assigned to it when created, for example:":"想象一下，你有一个玩家实例，多个敌人实例和多个子弹实例，敌人可以向你开火。您可以为每个敌人指定一个项目符号实例，但在创建时会随机指定不同的损坏变量，例如：","In this example you can see that we have a {}local{} variable called {}val{} and we want it to set the {}instance{} variable with the same name in the newly created object instance. To identify the instance variable correctly and tell {}GameMaker{} to set it in the instance calling the code block, we use the {}self{} keyword. In most cases you can also use the {}id{} built-in&nbsp;instance variable instead of {}self{}, but {}self{} offers certain benefits. To start with, it is faster for the compiler to identify the instance (or struct) using {}self{} rather than {}id{}, as the {}id{} value goes through the instance lookup table while {}self{} does not.&nbsp;Secondly, for those people making extensions, it is very useful to ensure the correct scoping of variables, since it is possible that a project which uses an extension may have a global scope variable or something&nbsp;with the same name as a variable in the extension.":"在此示例中，您可以看到我们有一个名为{}val{}的{}local{}变量，我们希望它在新创建的对象实例中设置名称相同的{}实例{}变量。要正确识别实例变量并告诉{}GameMaker{}在调用代码块的实例中设置它，我们使用{}self{}关键字。在大多数情况下，您还可以使用{}id{}内置实例变量而不是{}self{}，但{}self{}具有一定的优势。首先，编译器使用{}self{}而不是{}id{}来标识实例(或结构)的速度更快，因为{}id{}值会经过实例查找表，而{}self{}不会。其次，对于那些进行扩展的人来说，确保变量的正确范围非常有用，因为使用扩展的项目可能具有全局范围变量或与扩展中的变量具有相同名称的东西。","In this example you can see that we have a {}local{} variable called {}val{} and we want it to set the {}instance{} variable with the same name in the newly created object instance. To identify the instance variable correctly and tell {}GameMaker{} to set it in the instance calling the code block, we use the {}self{} keyword. In most cases you can also use the&nbsp;{}{}id{}{} built-in&nbsp;instance variable instead of {}self{}, but {}self{} offers certain benefits. To start with, it is faster for the compiler to identify the instance (or struct) using {}self{} rather than {}id{}, as the {}id{} value goes through the instance lookup table while {}self{} does not.&nbsp;Secondly, for those people making extensions, it is very useful to ensure the correct scoping of variables, since it is possible that a project which uses an extension may have a global scope variable or something&nbsp;with the same name as a variable in the extension.":"在此示例中，您可以看到我们有一个名为 {}val{} 的 {} 本地{} 变量，我们希望它在新创建的对象实例中设置同名的 {}instance{} 变量。为了正确识别实例变量并告诉 {}GameMaker{} 在调用代码块的实例中设置它，我们使用 {}self{} 关键字。在大多数情况下，您还可以使用 {}{}id{}{} 内置实例变量来代替 {}self{}，但 {}self{} 具有一定的优势。首先，编译器使用 {}self{} 识别实例 (或结构) 比使用 {}id{} 更快，因为 {}id{} 值会遍历实例查找表，而 {}self{} 才不是。其次，对于那些进行扩展的人来说，确保变量的正确作用域非常有用，因为使用扩展的项目可能具有全局作用域变量或与扩展中的变量同名的变量。","In this example, the function {}instance_nearest(){} will return either {}noone{} or the unique ID of the nearest found instance. Basically, any time that you need to check for an instance, you can expect to get either {}noone{} or a unique instance ID returned.":"在此示例中，函数{}instance_nearest(){}将返回{}noone{}或最近找到的实例的唯一ID。基本上，任何需要检查实例的时候，都可以获得{}noone{}或返回唯一的实例ID。","In this example, the function&nbsp;{}{}instance_nearest{}{} will return either {}noone{} or the nearest found instance. Basically, any time that you need to check for an instance, you can expect to get either {}noone{} or an instance returned.":"在此示例中，函数{}{}instance_nearest{}{}将返回{}noone{}或最近找到的实例。基本上，任何时候您需要检查实例时，都可能会得到{}noone{}或返回一个实例。","Instance Keywords":"实例关键字","Instance Method":"实例方法","It is also worth noting that {}self{} can also be used within {}structs{}&nbsp;- under very specific circumstances - to reference member variables for the struct.":"还值得注意的是，在非常特定的情况下，{}self{}也可以在{}结构{}&nbsp;中使用，以引用结构的成员变量。","It may seem odd, but many times while programming your games will you find the need to check if there are no instances found at a location, in a collision, etc.&nbsp;In those cases you would use this keyword to check for nothing, something like this:":"这可能看起来很奇怪，但很多时候，在对游戏进行编程时，您会发现需要检查在某个位置、碰撞等情况下是否没有找到实例。在这些情况下，您将使用此关键字来检查任何内容，例如这：","It may seem odd, but many times while programming your games will you find the need to check if there are no instances found at a location, or in a collision etc... In those cases you would use this keyword to check for nothing, something like this:":"这可能看起来很奇怪，但很多时候，在编程游戏时，您会发现需要检查是否在某个位置找不到实例，或者在碰撞中等等……在这些情况下，您可以使用此关键字进行空检查，例如：","No instance at all.":"没有任何实例。","Note that all the given keywords are represented by&nbsp;{}negative integer values{} internally, so care must be taken when assigning or checking variable values against or with these keywords, as you may get unexpected results later as {}GameMaker{} interprets the value you have used as something else. You should also note that using the integer values directly instead of the keywords in your code is {}not recommended at all{} and could cause issues later on.":"注意，所有给定的关键字在内部都是由&nbsp;{}负整数值{}表示的，所以在分配或检查变量值时必须注意这些关键字，因为{}GameMaker{}可能会在以后得到意想不到的结果，因为你已经使用了其他值。您还应该注意，在您的代码中直接使用整数值而不是关键字是完全不建议使用{}的，{}可能会在以后引起问题。","Scope doesn't change inside a struct declaration, so&nbsp;{}other{} refers to the same scope as&nbsp;{}self{} (the {}current{} scope), meaning the struct or instance that's initialising the struct:":"结构体声明内的作用域不会更改，因此{}other{}引用与{}self{}相同的作用域({}当前{}作用域)，即初始化该结构体的结构体或实例：","Struct Declaration":"结构声明",'The above code will deduct the amount stored in the {}other{} instance\'s "damage" variable from the player\'s "hp" variable, then it will check to see if the "hp" is lower than or equal to 0. If it is then it will destroy the player instance. Please note that&nbsp;the other instance must have the variable being checked or else an error will be thrown.':"以上代码将从玩家的“hp”变量中扣除{}other{}实例的“伤害”变量，然后它将检查“hp”是否小于或等于0。如果是，那么它将破坏玩家实例。请注意，另一个实例必须有被检查的变量，否则将抛出错误。","The above code will deduct the amount stored in the {}other{} instance's {}damage{} variable from the player's {}hp{} variable, then it will check to see if the {}hp{} is lower than or equal to 0. If it is then it will destroy the player instance. Please note that&nbsp;the other instance must have the variable being checked or else an error will be thrown.":"上述代码将从玩家的 {}hp{} 变量中扣除 {}other{} 实例的 {}damage{} 变量中存储的金额，然后检查 {}hp{} 是否低于或等于为 0。如果是，那么它将销毁玩家实例。请注意，另一个实例必须检查该变量，否则将引发错误。","The above code will set the speed of all instances in the room to 0. You can also use {}all{} within functions to target or check all instances in the room for example:":"上述代码将房间中所有实例的速度设置为0。您还可以在函数内使用{}all{}来锁定或检查房间中的所有实例，例如：","The instance/struct which is executing the current block of code.":"正在执行当前代码块的实例/结构。","The other instance involved in a collision event, in a {}with{} function or in a function.":"碰撞事件中涉及的另一个实例，在{}with{}函数中或在函数中。","The same will apply to a method that is bound to a struct.":"这同样适用于绑定到结构的方法。","The special keyword {}other{} has multiple ways that it can be used to reference a specific instance (and in some cases, a struct): it can be used in a {}with{} statement (explained&nbsp;{}here{}),&nbsp;in a {}collision event{}, or in a function. This section is going to explain the last two use cases.":"特殊关键字{}other{}有多种方法可以用来引用特定实例(在某些情况下，还可以引用结构):它可以在{}with{}语句中使用(在{}这里解释{})，在{}碰撞事件{}中使用或在函数中使用。本节将解释最后两个用例。","The special keyword {}other{} has multiple ways that it can be used to reference a specific instance or struct: it can be used in a&nbsp;{}{}with{}{} statement,&nbsp;in a {}collision event{}, or in a function. This section is going to explain the last two use cases.":"特殊关键字{}other{}有多种方式用于引用特定实例或结构：它可以在{}{}with{}{}语句、{}碰撞事件{}中使用，或在一个函数中。本节将解释最后两个用例。","The variable {}a{} is an existing variable of {}the_struct{}&nbsp;so it can be assigned to directly inside the {}with{}. What the expression on the right-hand side refers to can be found by checking the dot operators one by one.&nbsp;{}other{}&nbsp;refers to the scope that came before, i.e. before entering the {}with{} statement, so the instance scope. The instance's {}the_thing{}&nbsp;variable stores the value&nbsp;{}self{}, which refers to the {}current{} scope, which was just found to be that of the instance. Its&nbsp;{}my_val{}&nbsp;variable stores the value {}5{}, which is finally assigned to the struct's variable {}a{}. The final value of the_struct is therefore {}{a : 5, b : 5}{}.":"变量{}a{}是{}the_struct{}的现有变量，因此可以直接将其赋值给{}with{}内部。右边的表达式指的是什么，可以通过一一检查点运算符来找到。{}other{}指之前的作用域，即在输入{}with{}语句之前，即实例作用域。实例的{}the_thing{}变量存储值{}self{}，该值引用{}当前{}范围，刚刚发现该范围是实例的范围。其{}my_val{}变量存储值{}5{}，该值最终分配给结构体的变量{}a{}。因此 the_struct 的最终值为{}{a : 5, b : 5}{}。","This can&nbsp;also be useful in combination with a&nbsp;{}{}with{}{} statement:&nbsp;":"这也可以与{}{}with{}{}语句结合使用：","This code is executed when an instance of an object is created. The instance receives a variable&nbsp;{}my_val{}&nbsp;that's assigned the value {}5{} and a variable&nbsp;{}the_thing{}&nbsp;that's assigned the value {}self{}. It also receives a variable {}the_struct{}, with variables {}a{} set to {}4{} and {}b{} set to {}5{}. Next, the scope is changed to that of the struct using a&nbsp;{}{}with{}{} statement. Between the curly braces {}{ }{},&nbsp; the scope is that of the struct. The following line of code is then executed:&nbsp;":"当创建对象的实例时执行此代码。该实例接收分配了值{}5{}的变量{}my_val{}和分配了值{}self{}的变量{}the_thing{}。它还接收变量{}the_struct{}，其中变量{}a{}设置为{}4{}，{}b{}设置为{}5{}。接下来，使用{}{}with{}{}语句将范围更改为结构体的范围。在大括号{}{ }{}之间，范围是结构体的范围。然后执行以下代码行：","This keyword is used to tell {}GameMaker{} that a function is to be applied, or to check, all active instances within a room (deactivated instances will not be checked or accessed). You {}cannot{} use {}all{} to access or set variables in other instances using the point method (see {}here{}), but you {}can {}use it when calling {}{}with(){}{}, for example:":"这个关键字用来告诉{}GameMaker{}一个函数将被应用，或者检查房间内的所有活动实例(未激活的实例将不会被检查或访问)。你{}不能{}使用{}all{}来使用point方法访问或设置其他实例中的变量(参见{}这里的{})，但是你{}可以在用(){}{}调用{}{}时使用{}，例如:","This keyword is used to tell {}GameMaker{} that a function is to be applied, or to check, all active instances within a room (deactivated instances will not be checked or accessed). You {}cannot{} use {}all{} to access or set variables in other instances using the point method (see {}here{}), but you {}can {}use it when using&nbsp;{}{}with{}{}, for example:":"该关键字用于告诉 {}GameMaker{} 要应用某个函数，或者检查房间内的所有活动实例 (不会检查或访问停用的实例)。您 {} 不能 {} 使用 {}all{} 来使用 point 方法访问或设置其他实例中的变量 (请参阅 {} 此处 {})，但您 {} 可以 {} 在使用 {}{}with{}{} 时使用它， 例如：",'This keyword refers to the "other" instance involved in a collision event, or to the instance or struct that\'s executing a&nbsp;{}{}with{}{}&nbsp;statement{}{}{} {}{}{}or calls a function.{} More generally,&nbsp;{}other{}&nbsp;always refers to the{}&nbsp;scope through which the current scope was accessed{}&nbsp;or, put differently, the scope you were previously in&nbsp;or the scope where you came from.':'此关键字指的是碰撞事件中涉及的"其他"实例，或者是执行{}{}with{}{}语句{}{}{}{}{}{}或调用函数的实例或结构体.{}更一般地说，{}other{}始终指访问当前作用域的作用域{}，或者换句话说，指您之前所在的作用域或您来自的作用域。',"This keyword refers to the {}current scope{}, which is the instance or struct that is executing the current block of code.":"该关键字指的是{}当前作用域{}，即正在执行当前代码块的实例或结构。",'This would cause the instance to first print its own object name&nbsp;("Object2") and then the object name of the calling instance ("Object1").':'这将导致实例首先打印自己的对象名(" Object 2")，然后打印调用实例的对象名(" Object 1")。',"To make certain things easier in {}GameMaker{}, you can use one of several {}instance keywords{} in your code (whether GML or GML Visual). These keywords are used primarily to identify instances - and in some cases structs - under different situations, and each one is explained in the text below.":"为了在{}GameMaker{}中简化某些事情，你可以在代码中使用几个{}实例关键字{}中的一个(无论是GML还是GML Visual)。这些关键字主要用于识别不同情况下的实例(在某些情况下是结构)，每个关键字在下面的文本中进行解释。","To make certain things easier in {}GameMaker{}, you can use one of several {}instance keywords{} in your code (whether {}GML Code{}&nbsp;or {}GML Visual{}). These keywords are used to identify instances and structs. Each one is explained in the text below.":"为了简化{}GameMaker{}中的某些操作，您可以在代码中使用多个{}实例关键字{}之一(无论是{}GML Code{}还是{}GML Visual{})。这些关键字用于标识实例和结构。下面的文字中对每一项进行了解释。","Using {}other{} within another instance's {}method{} refers to the instance that called that method.":"在另一个实例的{}方法{}中使用{}other{}会引用调用该方法的实例。","When used inside a struct declaration, {}other{} refers to the instance that is initialising the struct:":"在结构声明内部使用时，{}other{}引用正在初始化结构的实例：","When used within a constructor function, {}other{} will reference the instance or struct that is calling that function,&nbsp;however this is not recommended for general use as any external data that a constructor needs to use should be passed in as arguments.":"在构造函数中使用时，{}other{}将引用调用该函数的实例或结构，但不建议将其用于一般用途，因为构造函数需要使用的任何外部数据都应作为参数传入。","When used within a constructor function, {}other{} will reference the instance that is calling that function,&nbsp;however this is not recommended for general use as any external data that a constructor needs to use should be passed in as arguments.":"在构造函数中使用时，{}other{}将引用正在调用该函数的实例，但不建议在一般情况下使用该实例，因为构造函数需要使用的任何外部数据都应作为参数传入。","You can also assign {}noone{} as a value to a variable to store the result of such a function:&nbsp;":"您还可以将{}noone{}作为值分配给变量来存储此类函数的结果：","You can also assign {}self{} as a value to a variable. That what {}self{} references is only determined when you use it to look up a variable. For example:&nbsp;":"您还可以将{}self{}作为值分配给变量。仅当您使用{}self{}查找变量时才能确定其引用的内容。例如：","You can assign values to variables, or even create new ones, using {}other{} in the collision event, like this:":"您可以在碰撞事件中使用{}其他{}为变量指定值，甚至创建新值，如下所示：","You can see how we set its variables using the dot notation&nbsp;as outlined in the section on {}Addressing Variables In Other Instances{}. This will give each bullet instance a different damage value, but how will the player detect the damage that it has to take when it's hit by a bullet?":"您可以看到我们如何使用点符号设置其变量，如{}其他实例中的寻址变量{}一节所述。这将为每个项目符号实例提供不同的损坏值，但玩家如何检测它在被子弹击中时必须承受的损坏？","will throw an error, since here {}my_val{} is looked up on {}the_struct{}'s \"self\". However, {}the_struct{} doesn't have a {}my_val{} variable!":'会引发错误，因为此处是在{}the_struct{}的"self"上查找{}my_val{}。但是，{}the_struct{}没有{}my_val{}变量！',"{}Instance Keywords{}":"{}实例关键字{}","{}NOTE{}: The Collision event is the only event that has a special meaning for the {}other{} keyword. In all other events and scripts, the behaviour of {}other{} will be defined by the context it is being used in (such as a {}with() {}block, a function, struct declaration, etc.).":'{}注意{}："碰撞"事件是唯一对{}other{}关键字具有特殊含义的事件。在所有其他事件和脚本中，{}other{}的行为将由它正在使用的上下文定义(例如{}with(){}块、函数、结构声明等)。',"{}NOTE{}: The&nbsp;{}self{}&nbsp;keyword is {}not {}a shortcut for the actual ID value of an instance or struct and should only be used in the context explained above. If you require the ID {}value {}for an instance then you need to use&nbsp;{}self.id{}, eg:":"{}注意{}: {}self{} 关键字{}不是{}实例或结构的实际ID值的快捷方式，应该只在上面解释的上下文中使用。如果你需要一个实例的ID{}值{}，那么你需要使用 {}self.id{},例如:","{}all{} is a very useful keyword and can be used in numerous situations within your code and actions, often cutting down on the amount of code you need to write to achieve a desired effect.":"{}all{}是一个非常有用的关键字，可以在代码和操作中的许多情况下使用，通常会减少需要编写的代码量以达到所需的效果。","{}self{} can also be used within {}structs{}&nbsp;- except under some specific circumstances - to reference member variables for the struct. It can also be used within constructor functions to reference the struct being generated from the constructor.":"除了在某些特定情况下，还可以在{}结构{}中使用 {0}self{1} 来引用结构的成员变量。它还可以在构造函数中使用，以引用从构造函数生成的结构。","{}self{} can be used to identify the current struct or instance that is in scope in the current block of code. For example:":"{}self{}可用于标识当前代码块中范围内的当前结构或实例。例如：","{}self{} is used in the same way with&nbsp;{}structs{}&nbsp;to reference member variables of the struct. It can also be used within constructor functions to reference the struct being generated from the constructor.":"{}self{}与{}structs{}的使用方式相同，用于引用结构体的成员变量。它还可以在构造函数中使用来引用从构造函数生成的结构。","{}{}NOTE{}{}&nbsp;If you're not in a collision event and don't change scope using the dot notation&nbsp;{}.{} or a&nbsp;{}{}with{}{}&nbsp;statement,&nbsp;{}other{} simply refers to the current scope, i.e. it refers to the same thing as&nbsp;{}self{}.":"{}{}注意{}{}如果您没有处于碰撞事件中并且不使用点符号{}.{}或{}{}with{}{}语句更改范围，则{}其他{}仅指当前作用域，即它与{}self{}指的是同一事物。","{}{}NOTE{}{}&nbsp;The Collision event is the only event that has a special meaning for the {}other{} keyword. In all other events and scripts, the behaviour of {}other{} will be defined by the context it is being used in (such as a {}with() {}block, a function, struct declaration, etc.).":'{}{}注意{}{}："碰撞"事件是唯一对 {}other{} 关键字具有特殊含义的事件。在所有其他事件和脚本中，{}other{} 的行为将由它正在使用的上下文定义(例如 {}with(){} 块、函数、结构声明等)。',"{}{}NOTE{}{}&nbsp;The Collision event is the only event that has a special meaning for the {}other{} keyword. In all other events and scripts, the behaviour of {}other{} will be defined by the context it is being used in (such as a {}with(){} block, a function, struct declaration, etc.).":"{}{} 注意 {}{} 碰撞事件是唯一对 {}other{} 关键字具有特殊含义的事件。在所有其他事件和脚本中，{}other{} 的行为将由其使用的上下文 (例如 {}with(){} 块、函数、结构声明等) 定义。","{}{}NOTE{}{}&nbsp;The given keywords are represented by&nbsp;{}negative integer values{} internally, so care must be taken when assigning or checking variable values against or with these keywords, as you may get unexpected results later as {}GameMaker{} interprets the value you have used as something else. You should also note that using the integer values directly instead of the keywords in your code is {}not recommended at all{} and could cause issues later on.":"{}{}注意{}{}给定的关键字在内部由{}负整数值{}表示，因此在针对这些关键字或使用这些关键字分配或检查变量值时必须小心，因为稍后您可能会得到意外的结果，因为{}GameMaker{}将您使用的值解释为其他值。您还应该注意，{}完全不建议{}在代码中直接使用整数值而不是关键字，并且可能会在以后引起问题。","{}{}NOTE{}{}&nbsp;The&nbsp;{}self{}&nbsp;keyword is {}not {}a shortcut for the actual ID value of an instance or struct and should only be used in the context explained above. If you require the ID {}value {}for an instance then you need to use {}self.id{}, e.g.:":"{}{} 注意{}{}{}self{} 关键字 {} 不是 {} 实例或结构的实际 ID 值的快捷方式，只能在上述上下文中使用。如果您需要实例的 ID{} 值 {}，则需要使用 {}self.id{}，例如：","{}{}NOTE{}{}&nbsp;The&nbsp;{}self{}&nbsp;keyword is {}not {}a shortcut for the actual ID value of an instance or struct and should only be used in the context explained above. If you require the ID {}value {}for an instance then you need to use&nbsp;{}self.id{}, eg:":"{}{}注意{}{}: {}self{} 关键字{}不是{}实例或结构的实际ID值的快捷方式，应该只在上面解释的上下文中使用。如果你需要一个实例的ID{}值{}，那么你需要使用 {}self.id{},例如:","{}{}all{}{}{}{}all{}{}":"{}{}all{}{}{}{}all{}{} 全部","{}{}noone{}{}{}{}noone{}{}":"{}{}noone{}{}{}{}noone{}{} 无","{}{}other{}{}{}{}other{}{}":"{}{}other{}{}{}{}other{}{} 另一个","{}{}self{}{}{}{}self{}{}":"{}{}self{}{}{}{}self{}{} 自身"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../..",gTopicId="8.2.1.2_2"</script><script type="text/javascript" src="../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Instance Keywords</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../assets/css/default.css" type="text/css"><script src="../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Mark Alexander"><meta name="topic-comment" content="Page outlining the different instance &quot;keywords&quot;"><meta name="rh-index-keywords" content="Instance Keywords,noone,self,other,all"><meta name="search-keywords" content="self,all,noone,other,instance keywords"><meta name="brsnext" value="GameMaker_Language/GML_Overview/Evaluation_Order.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Commenting_Code.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Instance Keywords"><span>Instance Keywords</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1><span data-field="title" data-format="default">Instance Keywords</span></h1><p>To make certain things easier in <span data-keyref="GameMaker Name">GameMaker</span>, you can use one of several <b>instance keywords</b> in your code (whether <span data-keyref="GML_Code">GML Code</span>&nbsp;or <span data-keyref="GML_Visual">GML Visual</span>). These keywords are used to identify instances and structs. Each one is explained in the text below.</p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;The given keywords are represented by&nbsp;<strong>negative integer values</strong> internally, so care must be taken when assigning or checking variable values against or with these keywords, as you may get unexpected results later as <span data-keyref="GameMaker Name">GameMaker</span> interprets the value you have used as something else. You should also note that using the integer values directly instead of the keywords in your code is <b>not recommended at all</b> and could cause issues later on.</p><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down" href="#self"><span data-open-text="true" data-skip-index="true"><span class="inline">self</span></span><span data-close-text="true"><span class="inline">self</span></span></a></p><div class="droptext" data-targetname="drop-down"><table><colgroup><col><col></colgroup><tbody><tr><th>Keyword</th><th>Description</th></tr><tr><td><span class="inline">self</span></td><td>This keyword refers to the <strong>current scope</strong>, which is the instance or struct that is executing the current block of code.</td></tr></tbody></table><p class="dropspot"><span class="inline2">self</span> can be used to identify the current struct or instance that is in scope in the current block of code. For example:</p><p class="code">var val = 100;<br>with (instance_create_layer(x, y, "Instances", obj_Fire))<br>{<br>&nbsp; &nbsp; self.val = val;<br>}</p><p class="dropspot">In this example you can see that we have a <i>local</i> variable called <span class="inline2">val</span> and we want it to set the <i>instance</i> variable with the same name in the newly created object instance. To identify the instance variable correctly and tell <span data-keyref="GameMaker Name">GameMaker</span> to set it in the instance calling the code block, we use the <span class="inline2">self</span> keyword. In most cases you can also use the&nbsp;<span class="inline2"><a href="../GML_Reference/Asset_Management/Instances/Instance_Variables/id.htm">id</a></span> built-in&nbsp;instance variable instead of <span class="inline2">self</span>, but <span class="inline2">self</span> offers certain benefits. To start with, it is faster for the compiler to identify the instance (or struct) using <span class="inline2">self</span> rather than <span class="inline2">id</span>, as the <span class="inline2">id</span> value goes through the instance lookup table while <span class="inline2">self</span> does not.&nbsp;Secondly, for those people making extensions, it is very useful to ensure the correct scoping of variables, since it is possible that a project which uses an extension may have a global scope variable or something&nbsp;with the same name as a variable in the extension.</p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;The&nbsp;<span class="inline2">self</span>&nbsp;keyword is <strong>not</strong> a shortcut for the actual ID value of an instance or struct and should only be used in the context explained above. If you require the ID <strong>value</strong> for an instance then you need to use <span class="inline2">self.id</span>, e.g.:</p><p class="code">var myID = id;<br>with (all)<br>{<br>&nbsp; &nbsp; if (self.id == myID)<br>&nbsp; &nbsp; {<br>&nbsp; &nbsp; &nbsp; &nbsp; // do something<br>&nbsp; &nbsp; }<br>}</p><p class="dropspot"><span class="inline2">self</span> is used in the same way with&nbsp;<a href="Structs.htm">structs</a>&nbsp;to reference member variables of the struct. It can also be used within constructor functions to reference the struct being generated from the constructor.</p><p class="dropspot">You can also assign <span class="inline2">self</span> as a value to a variable. What <span class="inline2">self</span> references is only determined when you use it to look up a variable. For example:&nbsp;</p><p class="code_heading">Create Event</p><p class="code">my_val = 5;<br>the_thing = self;<br><br>the_struct =&nbsp;<br>{<br>&nbsp; &nbsp; a: 4,<br>&nbsp; &nbsp; b: 5<br>}<br><br>with(the_struct)<br>{<br>&nbsp; &nbsp; a = other.the_thing.my_val;<br>}<br><br>show_debug_message(the_struct);&nbsp; //&nbsp;{ a : 5, b : 5 }</p><p class="dropspot">This code is executed when an instance of an object is created. The instance receives a variable&nbsp;<span class="inline2">my_val</span>&nbsp;that's assigned the value <span class="inline2">5</span> and a variable&nbsp;<span class="inline2">the_thing</span>&nbsp;that's assigned the value <span class="inline2">self</span>. It also receives a variable <span class="inline2">the_struct</span>, with variables <span class="inline2">a</span> set to <span class="inline2">4</span> and <span class="inline2">b</span> set to <span class="inline2">5</span>. Next, the scope is changed to that of the struct using a&nbsp;<span class="inline2"><a href="Language_Features/with.htm">with</a></span> statement. Between the curly braces <span class="inline2">{ }</span>,&nbsp; the scope is that of the struct. The following line of code is then executed:&nbsp;</p><p class="code">a = other.the_thing.my_val;</p><p class="dropspot">The variable <span class="inline2">a</span> is an existing variable of <span class="inline2">the_struct</span>&nbsp;so it can be assigned to directly inside the <span class="inline2">with</span>. What the expression on the right-hand side refers to can be found by checking the dot operators one by one.&nbsp;<span class="inline2">other</span>&nbsp;refers to the scope that came before, i.e. before entering the <span class="inline2">with</span> statement, so the instance scope. The instance's <span class="inline2">the_thing</span>&nbsp;variable stores the value&nbsp;<span class="inline2">self</span>, which refers to the <strong>current</strong> scope, which was just found to be that of the instance. Its&nbsp;<span class="inline2">my_val</span>&nbsp;variable stores the value <span class="inline2">5</span>, which is finally assigned to the struct's variable <span class="inline2">a</span>. The final value of <span class="inline2">the_struct</span> is therefore <span class="inline2">{a : 5, b : 5}</span>.</p><p class="dropspot">Note that doing:&nbsp;</p><p class="code">with(the_struct)<br>{<br>&nbsp; &nbsp; a = the_thing.my_val;<br>}</p><p class="dropspot">will throw an error, since here <span class="inline2">my_val</span> is looked up on <span class="inline2">the_struct</span>'s "self". However, <span class="inline2">the_struct</span> doesn't have a <span class="inline2">my_val</span> variable!</p><p class="dropspot">&nbsp;</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down1" href="#"><span data-open-text="true" data-skip-index="true"><span class="inline">other</span></span><span data-close-text="true"><span class="inline">other</span></span></a></p><div class="droptext" data-targetname="drop-down1"><table><colgroup><col><col></colgroup><tbody><tr><th>Keyword</th><th>Description</th></tr><tr><td><span class="inline">other</span></td><td>This keyword refers to the "other" instance involved in a collision event, or to the instance or struct that's executing a&nbsp;<span class="inline2"><a href="Language_Features/with.htm">with</a></span>&nbsp;statement<font face="menlo, consolas, monospace"><span style="font-size:17px"><b></b></span></font> or calls a function.<br>More generally,&nbsp;<span class="inline2">other</span>&nbsp;always refers to the<strong>&nbsp;scope through which the current scope was accessed</strong>&nbsp;or, put differently, the scope you were previously in&nbsp;or the scope where you came from.</td></tr></tbody></table><p class="dropspot">The special keyword <span class="inline2">other</span> has multiple ways that it can be used to reference a specific instance or struct: it can be used in a&nbsp;<span class="inline2"><a href="Language_Features/with.htm">with</a></span> statement,&nbsp;in a <a href="../../The_Asset_Editors/Object_Properties/Object_Events.htm">collision event</a>, or in a function. This section is going to explain the last two use cases.</p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;If you're not in a collision event and don't change scope using the dot notation&nbsp;<span class="inline2">.</span> or a&nbsp;<span class="inline2"><a href="Language_Features/with.htm">with</a></span>&nbsp;statement,&nbsp;<span class="inline2">other</span> simply refers to the current scope, i.e. it refers to the same thing as&nbsp;<span class="inline2">self</span>.</p><h2 class="dropspot">Collision Event</h2><p class="dropspot">A collision event can only happen between <strong>two</strong> instances. You <i>can</i> have multiple collisions between multiple instances, but they are all resolved by <span data-keyref="GameMaker Name">GameMaker</span> on a 1-on-1 basis, with the "self" instance that has the collision event and the "other" instance that is colliding with it.</p><p class="dropspot">Imagine you have a player instance, multiple enemy instances and multiple bullet instances that the enemy can fire at you. You can assign each enemy a single bullet instance but with a different damage variable randomly assigned to it when created, for example:</p><p class="code">var bullet;<br>bullet = instance_create_layer(x, y, "Bullets", obj_Bullet);<br>bullet.damage = 5 + irandom(5);<br>bullet.speed = 8;<br>bullet.direction = point_direction(x, y, obj_Player.x, obj_Player.y);</p><p class="dropspot">You can see how we set its variables using the dot notation&nbsp;as outlined in the section on <a href="Addressing_Variables_In_Other_Instances.htm">Addressing Variables In Other Instances</a>. This will give each bullet instance a different damage value, but how will the player detect the damage that it has to take when it's hit by a bullet?</p><p class="dropspot">For this, the player will need to have a collision event with <span class="inline2">obj_Bullet</span>, and within that event use <span class="inline2">other</span> to read variables from the colliding bullet instance:</p><p class="code">hp -= other.damage;<br>if (hp &lt;= 0) instance_destroy();</p><p class="dropspot">The above code will deduct the amount stored in the <i>other</i> instance's <span class="inline2">damage</span> variable from the player's <span class="inline2">hp</span> variable, then it will check to see if the <span class="inline2">hp</span> is lower than or equal to 0. If it is then it will destroy the player instance. Please note that&nbsp;the other instance must have the variable being checked or else an error will be thrown.</p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;The Collision event is the only event that has a special meaning for the <span class="inline2">other</span> keyword. In all other events and scripts, the behaviour of <span class="inline2">other</span> will be defined by the context it is being used in (such as a <span class="inline2">with()</span> block, a function, struct declaration, etc.).</p><p class="dropspot">You can assign values to variables, or even create new ones, using <span class="inline2">other</span> in the collision event, like this:</p><p class="code">// add ten to the other instance's "mana" variable<br>other.mana += 10;<br>// set the other instance variable "hit" to true, creating the variable if it doesn't already exist<br>other.hit = true;</p><h2 class="dropspot">Struct Declaration</h2><p class="dropspot">Scope doesn't change inside a struct declaration, so&nbsp;<span class="inline2">other</span> refers to the same scope as&nbsp;<span class="inline2">self</span> (the <strong>current</strong> scope), meaning the struct or instance that's initialising the struct:</p><p class="code">var _struct =<br>{<br>&nbsp; &nbsp; parent_instance : other<br>}<br><br>show_debug_message(_struct.parent_instance == self);<br>// This prints '1' (true) meaning that both sides refer to the same instance</p><p class="dropspot">However, you do not need to use <span class="inline2">other</span> to read variables from the instance as any variables you reference directly will be read from that instance's scope, as described <a href="Structs.htm#inst_in_struct">in this section</a> of the manual. You would only need to use this if you wanted to store a reference to that instance's struct.</p><h2 class="dropspot">Instance Method</h2><p class="dropspot">Using <span class="inline2">other</span> within another instance's <a href="Method_Variables.htm">method</a> refers to the instance that called that method.</p><p class="dropspot">For example, let's say <span class="inline2">Object2</span> has a method that references <span class="inline2">self</span> and <span class="inline2">other</span>. This method is then called in <span class="inline2">Object1</span>. Since the method was created in <span class="inline2">Object2</span>, it is&nbsp;<strong>bound</strong>&nbsp;to it and will always use the <span class="inline2">Object2</span>&nbsp;instance as the "self", no matter which instance calls it. In such a case, the calling instance becomes&nbsp;<span class="inline2">other</span>.</p><p class="code">//&nbsp;In Object2<br>my_method = function()<br>{<br>&nbsp; &nbsp; show_debug_message(object_get_name(self.object_index));<br>&nbsp; &nbsp; show_debug_message(object_get_name(other.object_index));<br>}<br><br>// In Object1<br>Object2.my_method();</p><p class="dropspot">This would cause the instance to first print its own object name&nbsp;("Object2") and then the object name of the calling instance ("Object1").</p><p class="dropspot">The same will apply to a method that is bound to a struct.</p><h2 class="dropspot">Constructor Function</h2><p class="dropspot">When used within a constructor function, <span class="inline2">other</span> will reference the instance or struct that is calling that function,&nbsp;however this is not recommended for general use as any external data that a constructor needs to use should be passed in as arguments.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down2" href="#"><span data-open-text="true" data-skip-index="true"><span class="inline">all</span></span><span data-close-text="true"><span class="inline">all</span></span></a></p><div class="droptext" data-targetname="drop-down2"><table><colgroup><col><col></colgroup><tbody><tr><th>Keyword</th><th>Description</th></tr><tr><td><span class="inline">all</span></td><td>All instances currently active in the room.</td></tr></tbody></table><p class="dropspot">This keyword is used to tell <span data-keyref="GameMaker Name">GameMaker</span> that a function is to be applied, or to check, all active instances within a room (deactivated instances will not be checked or accessed). You <b>cannot</b> use <span class="inline2">all</span> to access or set variables in other instances using the point method (see <a href="Addressing_Variables_In_Other_Instances.htm">here</a>), but you <strong>can</strong> use it when using&nbsp;<span class="inline2"><a href="Language_Features/with.htm">with</a></span>, for example:</p><p class="code">with (all)<br>{<br>&nbsp; &nbsp; speed = 0;<br>}</p><p class="dropspot">The above code will set the speed of all instances in the room to 0. You can also use <span class="inline2">all</span> within functions to target or check all instances in the room for example:</p><p class="code">// Check a point for any active instance in the room<br>inst = instance_position(mouse_x, mouse_y, all);<br><br>// Check all instances for a collision along a line<br>if collision_line(x, y, mouse_x, mouse_y, all, false, true) {}<br><br>// Add all instances in the room into a motion planning grid<br>mp_grid_add_instances(grid, all, false);</p><p class="dropspot"><span class="inline2">all</span> is a very useful keyword and can be used in numerous situations within your code and actions, often cutting down on the amount of code you need to write to achieve a desired effect.</p><p class="dropspot">&nbsp;</p></div><p><a class="dropspot" data-rhwidget="DropSpot" data-target="drop-down3" href="#"><span data-open-text="true" data-skip-index="true"><span class="inline">noone</span></span><span data-close-text="true"><span class="inline">noone</span></span></a></p><div class="droptext" data-targetname="drop-down3"><table><colgroup><col><col></colgroup><tbody><tr><th>Keyword</th><th>Description</th></tr><tr><td><span class="inline">noone</span></td><td>No instance at all.</td></tr></tbody></table><p class="dropspot">It may seem odd, but many times while programming your games will you find the need to check if there are no instances found at a location, in a collision, etc.&nbsp;In those cases you would use this keyword to check for nothing, something like this:</p><p class="code">if (instance_nearest(x, y, obj_enemy) != noone)<br>{<br>&nbsp; &nbsp; //do something as there is an enemy instance near<br>}</p><p class="dropspot">In this example, the function&nbsp;<span class="inline3_func"><a href="../GML_Reference/Asset_Management/Instances/instance_nearest.htm">instance_nearest</a></span> will return either <span class="inline2" id="">noone</span> or the nearest found instance. Basically, any time that you need to check for an instance, you can expect to get either <span class="inline2" id="">noone</span> or an instance returned.</p><p class="dropspot">This can&nbsp;also be useful in combination with a&nbsp;<span class="inline2"><a href="Language_Features/with.htm">with</a></span> statement:&nbsp;</p><p class="code">with (instance_nearest(x, y, obj_enemy))<br>{<br>&nbsp; &nbsp; //do something as there is an enemy instance near<br>}</p><p class="dropspot">If the function returns an instance, the code between the curly braces <span class="inline2">{ }</span> will run once. If the function returns <span class="inline2">noone</span>, the code won't be executed.</p><p class="dropspot">You can also assign <span class="inline2">noone</span> as a value to a variable to store the result of such a function:&nbsp;</p><p class="code_heading">Create Event</p><p class="code">ins_last_collided_with = noone;</p><p class="code_heading">Collision Event</p><p class="code">ins_last_collided_with = other.id;</p><p class="dropspot">&nbsp;</p></div><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="GML_Overview.htm">GML&nbsp;Overview</a></div><div style="float:right">Next:&nbsp;<a href="Evaluation_Order.htm">Evaluation Order</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>