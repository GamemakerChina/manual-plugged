<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,n){let o;o=n?e.attr(n):e.html();let i=t[removeHtml(o)];if(null!=i&&i.length){t=retHtml(o);let a=0;t&&t.forEach(function(e,t){var n=i.replace("{"+a+"}",e);i=n===i?i.replace("{}",e):n,a++}),n?e.attr(n,i):e.html(i)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={"Additional functions for the script can be added using the same format as shown above, one after the other within the script asset.":"可以使用如上所示的相同格式在脚本资源中一个接一个地添加脚本的附加函数。","Also see:&nbsp;{}Script Functions vs. Methods{}":"另请参阅：{}脚本函数与方法{}","Arguments passed into a function can also be accessed through the {}argumentN{} variables ({}argument0, argument1, etc.{}) or the {}{}argument[]{}{} array ({}argument[0], argument[1], etc.{}).":"还可以通过 {}argumentN{} 变量 ({}argument0、argument1 等 {}) 或 {}{}argument[]{}{} 数组 ({}argument[0] 、参数 [1] 等 {})。","Convert the script index into a {}method{} before passing it as an argument":"将脚本索引转换为{}方法{}，然后将其作为参数传递","Creating Functions":"创建函数","For example, consider this code, called from an instance's event:":"例如，考虑从实例的事件调用的以下代码：","Functions can also make use of static variables, which maintain their values throughout every function call. Please {}read this page{} for more information.":"函数还可以使用静态变量，这些变量在每次函数调用期间都保持其值。请{}阅读此页面{}了解更多信息。","Functions in scripts can also return a value, just as runtime functions can, and as such they can be used in expressions. For this you would use the {}{}return{}{} statement:":"脚本中的函数也可以返回值，就像运行时函数一样，因此它们可以在表达式中使用。为此，您可以使用{}{}return{}{}语句：","Here are two things you can do to work around this:":"您可以采取以下两项措施来解决此问题：","However, you can still name a script the same as a function that you define in it and call the script, e.g. if you want one function per script (which can be useful for making reusable libraries so all functions are shown in the Asset Browser). When doing this, it is important to understand how script references behave to avoid code errors, due to the way {}GameMaker{} stores asset references.":"但是，您仍然可以将脚本命名为与您在其中定义的函数相同的名称并调用该脚本，例如如果您想要每个脚本一个函数(这对于制作可重用库非常有用，因此所有函数都显示在资源浏览器中)。执行此操作时，由于{}GameMaker{}存储资源引用的方式，了解脚本引用的行为方式以避免代码错误非常重要。","If an argument is not given to a function, its value will be&nbsp;{}undefined{}. You can use this to define&nbsp;{}optional{}&nbsp;arguments, and check whether an argument is passed in or not by checking if it is equal to {}undefined{}. However, you can also explicitly define a default value for an argument which will be used instead of {}undefined{}&nbsp;when it is not passed in.":"如果未向函数提供参数，则其值将为{}未定义{}。您可以使用它来定义{}可选{}参数，并通过检查参数是否等于{}未定义{}来检查参数是否已传入。不过，您也可以显式定义参数的默认值，当未传入该参数时，将使用该默认值来代替{}undefined{}。","If the {}dir{} argument is not passed in when calling the above function, then its value will default to {}90{}, moving the instance in an upward direction.":"如果调用上述函数时未传入{}dir{}参数，则其值将默认为{}90{}，将实例向上移动。","In general, however, you would use the {}first {}form for script functions as it will define the function as specifically being a script function, meaning that it will be {}global {}in {}scope{}, be assigned a {}script index{}, and not require the {}global{} prefix to identify it since the compiler will recognise it as a script function.":"不过，一般来说，您会为脚本函数使用{}第一个{}形式，因为它将将该函数定义为专门的脚本函数，这意味着它将在{4}作用域{5}中{}全局{}，并被分配{}脚本索引{}，并且不需要{}全局{}前缀来识别它，因为编译器会将其识别为脚本函数。","In the above case, not only have we defined the functions {}Foo{} and {}Bar{} but also the variable {}blah{} and all of them are considered to have been created in the {}global{} scope. The functions don't need the {}global{} keyword to be recognized as the compiler understands that these functions are part of the script, but if you wanted to access {}blah{} then you would need to do:":"在上述示例中，我们不仅定义了函数{}Foo{}和{}Bar{}，还定义了变量{}blah{}，并且所有这些都被视为在{}global{}范围内创建。这些函数不需要{}global{}关键字来识别，因为编译器知道这些函数是脚本的一部分，但如果您想访问{}blah{}，则需要执行以下操作：","Index-Based Arguments":"基于索引的参数",'It is important to understand that script {}names{} are {}independent of the functions that they contain{}, so you can name your scripts in a more "common sense" way, i.e.: all your AI functions could go in a script "{}Enemy_AI{}" and contain functions like {}ai_target_pos(){}, {}ai_alert_level(){}, {}ai_state(){}, etc.':'请务必了解脚本{}名称{}{}独立于它们包含的函数{}，因此您可以用更"常识"的方式命名您的脚本，即：您的所有 AI 函数都可以采用脚本"{}Enemy_AI{}"并包含{}ai_target_pos(){}、{}ai_alert_level(){}、{}ai_state(){}等函数。','It should be noted that the {}{}execution of the function ends at the return statement{}{}, meaning that any code which comes after {}return {}has been called {}will not be run{}. Here is a short example function from a function called "{}sqr_calc{}" which calculates the square of whatever value is passed to it, and in case the given value is not a real number, it uses {}return{} to end the function early so the actual calculation never runs:':'应该注意的是，{}{}函数的执行在 return 语句{}{}处结束，这意味着{}return{}被调用之后的任何代码{}都不会运行{}。下面是一个来自名为"{}sqr_calc{}"的函数的简短示例函数，该函数计算传递给它的任何值的平方，如果给定值不是实数，它会使用{}return{}结束尽早调用该函数，因此实际计算永远不会运行：',"Note how all these constants are set up outside of any&nbsp;function call, meaning they will be initialised before everything else and at a {}global {}scope. This means that if you want to use a script&nbsp;to initialise variables on an {}instance {}scope then you must wrap them in a function, for example:":"请注意所有这些常量是如何在任何函数调用之外设置的，这意味着它们将在其他所有操作之前并在{}全局{}范围内进行初始化。这意味着，如果您想使用脚本来初始化{}实例{}范围内的变量，则必须将它们包装在函数中，例如：","Note that if you create a script function with&nbsp;{}no{}&nbsp;return value then in your code check for one, you will get the value {}undefined{}&nbsp;by default.":"请注意，如果您创建的脚本函数{}没有{}返回值，那么在您的代码中检查是否有返回值，默认情况下您将获得值{}未定义{}。","One final thing to note about script functions is that if you are developing for {}Web {}(ie: targeting {}HTML5{}), then there is an additional function protocol that you can use when adding functions to scripts, which is to prefix a function name with {}gmcallback_{}, for example:":"关于脚本函数，最后需要注意的一点是，如果您正在针对{}Web{}进行开发(即：以{}HTML5{}为目标)，则在向脚本添加函数时可以使用一个附加函数协议，即在函数名称前加上{}gmcallback_{}前缀，例如：","Optional Arguments":"可选参数","Parameters/Arguments":"参数/参数","Return Value":"返回值","Script Functions And Variables":"脚本函数和变量","Script Names vs. Function Names":"脚本名称与函数名称","Script Scope":"脚本范围","Script assets&nbsp;are essentially a collection of one or more user defined functions or variables that you write yourself as snippets of code in the {}Script Editor{}. The functions you define in a script can resolve expressions, return values or do anything else that the GameMaker Language permits, just like the built in {}runtime functions{}.":"脚本资源本质上是一个或多个用户定义的函数或变量的集合，您可以在{}脚本编辑器{}中将这些函数或变量自己编写为代码片段。您在脚本中定义的函数可以解析表达式、返回值或执行 GameMaker 语言允许的任何其他操作，就像内置的{}运行时函数{}一样。",'Script functions&nbsp;should generally be used if you have a block of code that you use in more than one place or object, or when you want a block of code to be used across multiple objects in a modular fashion. Using scripts to define functions means that you can change the function just once when required and the change will be "picked up" by every object that has a call to the function.':'如果您有在多个位置或多个对象中使用的代码块，或者您希望以模块化方式跨多个对象使用代码块，则通常应使用脚本函数。使用脚本定义函数意味着您只需在需要时更改函数一次，并且调用该函数的每个对象都会"接收"该更改。','Scripts can also be very handy from an organisational point of view, as they permit you to create groups of functions that belong to a certain category - for example, you might have several functions all related to collisions between instances in your game, so you would create a "{}Collision_Functions{}" script and store all these functions together in it.':'从组织的角度来看，脚本也非常方便，因为它们允许您创建属于特定类别的函数组 - 例如，您可能有几个与游戏中实例之间的碰撞相关的函数，因此您可以创建一个"{}Collision_Functions{}"脚本并将所有这些函数一起存储在其中。','So, scripts can be used to generate macros, enums and global variables before the game starts so they are ready for use at any time, and they can also be used to create "unbound" methods (user-defined functions) that can be used in your game like GML runtime functions.':'因此，脚本可用于在游戏开始之前生成宏、枚举和全局变量，以便随时使用它们，并且它们还可以用于创建可以使用的"未绑定"方法(用户定义的函数)在您的游戏中，例如 GML 运行时函数。',"Static Variables":"静态变量","That said, we recommend that you {}always explicitly type global variables{} when creating them in scripts to prevent any issues later. Scripts are also an ideal place to define any {}Macros{} or {}Enums{} ({}constants{}), as adding them to a script outside of a function also means that they will be created for use before the game code actually starts running. Below is an example of a script that is creating different global scope values for a game:":"也就是说，我们建议您在脚本中创建全局变量时{}始终显式键入全局变量{}，以防止以后出现任何问题。脚本也是定义任何{}宏{}或{}枚举{}({}常量{})的理想位置，因为将它们添加到函数外部的脚本中也意味着将在游戏之前创建它们以供使用代码实际上开始运行。下面是为游戏创建不同全局范围值的脚本示例：",'The above code is attempting to call a script called {}myscript{}&nbsp;within a method, which in this case will fail. This is because the inline function is actually using the {}index{} for the script asset and {}not {}actually calling the script function - e.g.: if the script index resolves to "4", essentially the function is calling {}4(arg){}, which makes no sense.':'上述代码尝试在方法内调用名为{}myscript{}的脚本，在本例中将会失败。这是因为内联函数实际上使用脚本资源的{}索引{}，而不是实际调用脚本函数 - 例如：如果脚本索引解析为"4"，则该函数本质上是调用{}4(arg){}，这没有意义。',"The default&nbsp;value of an optional variable can be an&nbsp;expression, so for example, you can use variables and call functions while defining an optional variable. Note that such an expression will only be executed&nbsp;if its&nbsp;optional argument is not provided in the function call. See the following example of a logging function:":"可选变量的默认值可以是表达式，因此，例如，您可以在定义可选变量时使用变量和调用函数。请注意，只有在函数调用中未提供其可选参数时，才会执行此类表达式。请参阅以下日志记录功能示例：","This function takes three arguments, where the&nbsp;first argument defaults to a string constant,&nbsp;the second argument defaults to an instance variable (in the scope of the calling instance) and the third argument defaults to an expression calling a function to retrieve the current date and time. This function can now be called with up to three&nbsp;arguments,&nbsp;as seen in the following example:":"该函数采用三个参数，其中第一个参数默认为字符串常量，第二个参数默认为实例变量(在调用实例的范围内)，第三个参数默认为调用函数以检索当前日期和时间。现在可以使用最多三个参数调用此函数，如以下示例所示：","This function takes two arguments and applies their values to the instance's {}speed{} and {}direction{} variables. It can now be called like any runtime function and arguments can be passed into it:":"该函数接受两个参数，并将它们的值应用于实例的{}速度{}和{}方向{}变量。现在可以像任何运行时函数一样调用它，并且可以将参数传递给它：",'This leads us to the final and most important thing to know about scripts and the functions they contain: scripts are parsed on a {}global{} level and will be {}compiled at the very start of the game{}. This means that {}technically{} all functions in a script are "unbound"&nbsp;{}method variables{}, and any variables declared outside of a function in the script will be considered {}global variables{}. For example, consider this script:':'这让我们了解了有关脚本及其包含的函数的最后也是最重要的一点：脚本在{}全局{}级别进行解析，并将{}在游戏一开始就进行编译{}。这意味着，{}技术上{}脚本中的所有函数都是"未绑定的"{}方法变量{}，并且脚本中函数外部声明的任何变量都将被视为{}全局变量{}。例如，考虑这个脚本：',"This {}print(){} function loops through all the passed arguments, and adds them to a string variable. That string is then printed to the output log.":"此{}print(){}函数循环遍历所有传递的参数，并将它们添加到字符串变量中。然后将该字符串打印到输出日志中。","To call a script function from within a piece of code, just use it the same way as when calling any runtime function - that is, write the function name with the parameter values in parentheses. So, the above script would be called like this:":"要从一段代码中调用脚本函数，只需使用与调用任何运行时函数相同的方式即可 - 即，在括号中写入函数名称和参数值。因此，上面的脚本将被这样调用：",'To create a function in GML Visual, use&nbsp;{}Declare A New Function{}. Enable its "Temp" option to create a method variable (second syntax shown above).':'要在 GML Visual 中创建函数，请使用{}声明新函数{}。启用其"Temp"选项来创建方法变量(上面显示的第二种语法)。',"Use&nbsp;{}{}script_execute{}{}&nbsp;to call the passed script reference":"使用{}{}script_execute{}{}调用传递的脚本引用","Using the above function name would mean that the function {}gmcallback_create_button(){} will not be obfuscated and so can be used in JavaScript extensions and other areas of your game, for example, when using the {}{}clickable_*{}{}&nbsp;functions.":"使用上述函数名称意味着函数{}gmcallback_create_button(){}不会被混淆，因此可以在 JavaScript 扩展和游戏的其他区域中使用，例如，在使用{}{}clickable_*{}{}功能。","Using the second form will instead be generating a global scope {}method variable{}, and as such it will {}not {}be recognised as a script function by the IDE and will require the use of the {}global{} prefix when being referenced&nbsp;in your code.":"使用第二种形式将生成一个全局范围的{}方法变量{}，因此它{}不会被 IDE 识别为脚本函数，并且需要使用{}global{}前缀在您的代码中引用时。","We also recommend that you add comments to define the properties of the function (see the section on {}JSDoc Comments{} for more details), such that a simple script would look like this:":"我们还建议您添加注释来定义函数的属性(有关更多详细信息，请参阅有关{}JSDoc 注释{}的部分)，这样简单的脚本将如下所示：","When creating a script with functions in it, the functions must be created using the following formats:":"创建包含函数的脚本时，必须使用以下格式创建函数：","You can assign such a default value to a parameter using the equal ({}={}) sign, making it an optional variable:":"您可以使用等号({}={}) 将此类默认值分配给参数，使其成为可选变量：","You can define your own parameters/arguments for a function, which will be available to the function as local variables and can be used for any purpose within that function:":"您可以为函数定义自己的参数/参数，这些参数/参数将作为局部变量提供给函数，并且可用于该函数内的任何目的：","You can get the number of arguments passed into the function using {}{}argument_count{}{}, thus allowing a variable number of arguments to be passed in.":"您可以使用{}{}argument_count{}{}获取传递到函数中的参数数量，从而允许传入可变数量的参数。","You can now call this function with as many strings as you like, which will all be joined together.":"现在，您可以使用任意数量的字符串来调用此函数，这些字符串将全部连接在一起。","{}NOTE{}&nbsp;Keep in mind that if your script is {}completely empty{}, it will not be loaded into the compiled game and will become non-existent; meaning that trying to reference such a script asset will crash your game. Note that this only applies to scripts that are completely empty, so even if your script only contains&nbsp;comments, it will still be included in the compiled game.":"{}注意{}请记住，如果您的脚本{}完全为空{}，则它不会加载到已编译的游戏中，并且将变得不存在;这意味着尝试引用此类脚本资源将使您的游戏崩溃。请注意，这仅适用于完全空的脚本，因此即使您的脚本仅包含注释，它仍然会包含在编译的游戏中。",'{}NOTE{}&nbsp;You can check this by using both forms in a script and then calling the runtime&nbsp;function {}typeof(){} on each of them. One will be classed as a "number" - since it returns a script index ID - and the other will be classed as a "method".':'{}注意{}您可以通过在脚本中使用这两种表单，然后对每个表单调用运行时函数{}typeof(){}来进行检查。一个将被归类为"数字" - 因为它返回脚本索引 ID - 另一个将被归类为"方法"。',"{}TIP{}&nbsp;You can omit arguments from function calls and they will default to {}undefined{}&nbsp;(or the default value for that argument as defined by the function).{} {} For example, writing&nbsp;{}my_func(0,,,1){} is the same as writing&nbsp;{}my_func(0, undefined, undefined, 1){}. ":"{}提示{}您可以省略函数调用中的参数，它们将默认为{}undefined{}(或函数定义的该参数的默认值)。{}{}例如，编写{}my_func(0 ,,,1){}与编写{}my_func(0, undefined, undefined, 1){}相同。","{}{}NOTE{}{}&nbsp;When using your own functions from scripts in the code editor, you can press{}&nbsp;{}{} or click the middle mouse button {}{}&nbsp;{}on the function name to open the script that contains it for editing directly.":"{}{}注意{}{}当在代码编辑器中的脚本中使用您自己的函数时，您可以按{}{}{}或在函数名称上单击鼠标中键{}{}{}以打开脚本包含它以供直接编辑。"},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../..",gTopicId="8.2.1.1_5"</script><script type="text/javascript" src="../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Script Functions And Variables</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../assets/css/default.css" type="text/css"><script src="../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Gurpreet S. Matharoo"><meta name="topic-comment" content="Page outlining the use of scripts to create functions and global variables and macros"><meta name="rh-index-keywords" content="Script Functions And Variables"><meta name="search-keywords" content="user defined functions,script functions,gmcallback_,gmcallback"><meta name="brsnext" value="GameMaker_Language/GML_Overview/Method_Variables.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Expressions_And_Operators.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Script Functions And Variables"><span>Script Functions And Variables</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>Script Functions And Variables</h1><p>Script assets&nbsp;are essentially a collection of one or more user defined functions or variables that you write yourself as snippets of code in the <a href="../../The_Asset_Editors/Scripts.htm">Script Editor</a>. The functions you define in a script can resolve expressions, return values or do anything else that the GameMaker Language permits, just like the built in <a href="Runtime_Functions.htm">runtime functions</a>.</p><p>Script functions&nbsp;should generally be used if you have a block of code that you use in more than one place or object, or when you want a block of code to be used across multiple objects in a modular fashion. Using scripts to define functions means that you can change the function just once when required and the change will be "picked up" by every object that has a call to the function.</p><p>Scripts can also be very handy from an organisational point of view, as they permit you to create groups of functions that belong to a certain category - for example, you might have several functions all related to collisions between instances in your game, so you would create a "<span class="inline">Collision_Functions</span>" script and store all these functions together in it.</p><p>Also see:&nbsp;<a href="Script_Functions_vs_Methods.htm">Script Functions vs. Methods</a></p><h2>Creating Functions</h2><p>When creating a script with functions in it, the functions must be created using the following formats:</p><p class="code"><span>function name( parameter1, parameter2, ... )<br>{</span><br><span>&nbsp; &nbsp; statement1;</span><br><span>&nbsp; &nbsp; statement2;</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;...</span><br><span>}</span></p><p>or:</p><p class="code">name =&nbsp;function( parameter1, parameter2, ... )<br><span>{</span><br><span>&nbsp; &nbsp; statement1;</span><br><span>&nbsp; &nbsp; statement2;</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;...</span><br><span>}</span></p><p class="note">To create a function in GML Visual, use&nbsp;<a href="../../Drag_And_Drop/Drag_And_Drop_Reference/Common/Declare_A_New_Function.htm">Declare A New Function</a>. Enable its "Temp" option to create a method variable (second syntax shown above).</p><p>In general, however, you would use the <em>first</em> form for script functions as it will define the function as specifically being a script function, meaning that it will be <strong>global</strong> in <a href="Variables_And_Variable_Scope.htm">scope</a>, be assigned a <strong>script index</strong>, and not require the <span class="inline">global</span> prefix to identify it since the compiler will recognise it as a script function.</p><p>Using the second form will instead be generating a global scope <a href="Method_Variables.htm">method variable</a>, and as such it will <em>not</em> be recognised as a script function by the IDE and will require the use of the <span class="inline">global</span> prefix when being referenced&nbsp;in your code.</p><p class="note"><span class="note">NOTE</span>&nbsp;You can check this by using both forms in a script and then calling the runtime&nbsp;function <a href="../GML_Reference/Variable_Functions/typeof.htm">typeof()</a> on each of them. One will be classed as a "number" - since it returns a script index ID - and the other will be classed as a "method".</p><h2>Parameters/Arguments</h2><p>You can define your own parameters/arguments for a function, which will be available to the function as local variables and can be used for any purpose within that function:</p><p class="code">function move(<strong>spd, dir</strong>)<br>{<br>&nbsp;&nbsp; &nbsp;speed = <strong>spd</strong>;<br>&nbsp;&nbsp; &nbsp;direction = <strong>dir</strong>;<br>}</p><p>This function takes two arguments and applies their values to the instance's <span class="inline">speed</span> and <span class="inline">direction</span> variables. It can now be called like any runtime function and arguments can be passed into it:</p><p class="code">var _mouse_dir = point_direction(x, y, mouse_x, mouse_y);<br><br><strong>move(4, _mouse_dir);</strong></p><h2>Index-Based Arguments</h2><p>Arguments passed into a function can also be accessed through the <span class="inline">argumentN</span> variables (<em>argument0, argument1, etc.</em>) or the <a href="Variables/Builtin_Global_Variables/argument.htm"><span class="inline">argument[]</span></a> array (<em>argument[0], argument[1], etc.</em>).</p><p>You can get the number of arguments passed into the function using <a href="Variables/Builtin_Global_Variables/argument_count.htm"><span class="inline">argument_count</span></a>, thus allowing a variable number of arguments to be passed in.</p><p class="code">function print(){<br>&nbsp;&nbsp; &nbsp;var _str = "";<br><br>&nbsp;&nbsp; &nbsp;for (var i = 0; i &lt; argument_count; i ++)<br>&nbsp;&nbsp; &nbsp;{<br>&nbsp;&nbsp; &nbsp;&nbsp;&nbsp; &nbsp;_str += string(argument[i]);<br>&nbsp;&nbsp; &nbsp;}<br><br>&nbsp;&nbsp; &nbsp;show_debug_message(_str);<br>}<br><br>// In an object<br>print("Player : ", current_time, " : ", id, " : fired");</p><p>This <span class="inline2">print()</span> function loops through all the passed arguments, and adds them to a string variable. That string is then printed to the output log.</p><p>You can now call this function with as many strings as you like, which will all be joined together.</p><h2>Optional Arguments</h2><p>If an argument is not given to a function, its value will be&nbsp;<span class="inline">undefined</span>. You can use this to define&nbsp;<em>optional</em>&nbsp;arguments, and check whether an argument is passed in or not by checking if it is equal to <span class="inline">undefined</span>. However, you can also explicitly define a default value for an argument which will be used instead of <span class="inline">undefined</span>&nbsp;when it is not passed in.</p><p>You can assign such a default value to a parameter using the equal (<span class="inline">=</span>) sign, making it an optional variable:</p><p class="code">function move(spd, <strong>dir = 90</strong>)<br>{<br>&nbsp;&nbsp; &nbsp;speed = spd;<br>&nbsp;&nbsp; &nbsp;direction = dir;<br>}</p><p>If the <span class="inline">dir</span> argument is not passed in when calling the above function, then its value will default to <span class="inline">90</span>, moving the instance in an upward direction.</p><p class="note"><span class="tip">TIP</span>&nbsp;You can omit arguments from function calls and they will default to <span class="inline">undefined</span>&nbsp;(or the default value for that argument as defined by the function).<br><br>For example, writing&nbsp;<span class="inline">my_func(0,,,1)</span> is the same as writing&nbsp;<span class="inline">my_func(0, undefined, undefined, 1)</span>.</p><hr><p>The default&nbsp;value of an optional variable can be an&nbsp;expression, so for example, you can use variables and call functions while defining an optional variable. Note that such an expression will only be executed&nbsp;if its&nbsp;optional argument is not provided in the function call. See the following example of a logging function:</p><p class="code">function log(text = "Log", object = object_index, time = date_datetime_string(date_current_datetime()))<br>{<br>&nbsp;&nbsp; &nbsp;var _string = "[" + string(time) + "] ";<br>&nbsp;&nbsp; &nbsp;_string += object_get_name(object) + ": ";<br>&nbsp;&nbsp; &nbsp;_string += text;<br>&nbsp;&nbsp; &nbsp;<br>&nbsp;&nbsp; &nbsp;show_debug_message(_string);<br>}</p><p>This function takes three arguments, where the&nbsp;first argument defaults to a string constant,&nbsp;the second argument defaults to an instance variable (in the scope of the calling instance) and the third argument defaults to an expression calling a function to retrieve the current date and time. This function can now be called with up to three&nbsp;arguments,&nbsp;as seen in the following example:</p><p class="code">log();<br>// Prints:&nbsp;[09-Jun-21 12:34:37 PM] Object1: Log<br><br>log("Player Shot", obj_player, 10);<br>// Prints:&nbsp;[10] obj_player: Player Shot</p><h2>JSDoc</h2><p>We also recommend that you add comments to define the properties of the function (see the section on <a href="../../The_Asset_Editors/Code_Editor_Properties/JSDoc_Script_Comments.htm">JSDoc Comments</a> for more details), such that a simple script would look like this:</p><p class="code">/// @function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;log(message);<br>/// @param {string}&nbsp; message&nbsp;&nbsp;The message to show<br>/// @description&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Show a message whenever the function is called.<br><br>function log(message)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;show_debug_message(message);<br>}</p><p>Additional functions for the script can be added using the same format as shown above, one after the other within the script asset.</p><p><img alt="Multiple Functions In One Script" class="center" src="../../assets/Images/Scripting_Reference/GML/Overview/Multiple_Functions_Scripts.png"></p><h2>Return Value</h2><p>Functions in scripts can also return a value, just as runtime functions can, and as such they can be used in expressions. For this you would use the <a href="Language_Features/return.htm"><span class="inline">return</span></a> statement:</p><p class="code">return &lt;expression&gt;</p><p>It should be noted that the <strong><i>execution of the function ends at the return statement</i></strong>, meaning that any code which comes after <strong>return</strong> has been called <i>will not be run</i>. Here is a short example function from a function called "<span class="inline">sqr_calc</span>" which calculates the square of whatever value is passed to it, and in case the given value is not a real number, it uses <strong>return</strong> to end the function early so the actual calculation never runs:</p><p class="code">/// @function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sqr_calc(val);<br>/// @param {real}&nbsp;&nbsp;val &nbsp;The value to calculate the square of<br>/// @description&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Calculate the square of the given value<br><br>function sqr_calc(val)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;if (!is_real(val))<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return (val&nbsp;* val);<br>}</p><p>Note that if you create a script function with&nbsp;<em>no</em>&nbsp;return value then in your code check for one, you will get the value <span class="inline">undefined</span>&nbsp;by default.</p><p>To call a script function from within a piece of code, just use it the same way as when calling any runtime function - that is, write the function name with the parameter values in parentheses. So, the above script would be called like this:</p><p class="code">if (keyboard_check_pressed(vk_enter))<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;val = scr_sqr(amount);<br>}</p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;When using your own functions from scripts in the code editor, you can press<span>&nbsp;<img alt="F1 Icon" class="icon" height="20" src="../../assets/Images/Icons/Icon_f1.png" width="55"></span>or click the middle mouse button <span><img alt="MMB Icon" class="icon" src="../../assets/Images/Icons/Icon_MMB.png">&nbsp;</span>on the function name to open the script that contains it for editing directly.</p><h2>Script Names vs. Function Names</h2><p>It is important to understand that script <i>names</i> are <b>independent of the functions that they contain</b>, so you can name your scripts in a more "common sense" way, i.e.: all your AI functions could go in a script "<span class="inline">Enemy_AI</span>" and contain functions like <span class="inline2">ai_target_pos()</span>, <span class="inline2">ai_alert_level()</span>, <span class="inline2">ai_state()</span>, etc.</p><p>However, you can still name a script the same as a function that you define in it and call the script, e.g. if you want one function per script (which can be useful for making reusable libraries so all functions are shown in the Asset Browser). When doing this, it is important to understand how script references behave to avoid code errors, due to the way <span data-keyref="GameMaker Name">GameMaker</span> stores asset references.</p><p>For example, consider this code, called from an instance's event:</p><p class="code">function indirectCall(func, arg)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;func(arg);<br>}<br><br>indirectCall(myscript, arg);</p><p>The above code is attempting to call a script called <span class="inline2">myscript</span>&nbsp;within a method, which in this case will fail. This is because the inline function is actually using the <em>index</em> for the script asset and <strong>not</strong> actually calling the script function - e.g.: if the script index resolves to "4", essentially the function is calling <span class="inline2">4(arg)</span>, which makes no sense.</p><p>Here are two things you can do to work around this:</p><ol><li>Convert the script index into a <a href="../GML_Reference/Variable_Functions/method.htm">method</a> before passing it as an argument</li><li>Use&nbsp;<span class="inline3_func"><a href="../GML_Reference/Asset_Management/Scripts/script_execute.htm">script_execute</a></span>&nbsp;to call the passed script reference</li></ol><p>Both ways are shown below:</p><p class="code">// 1<br>function indirectCall(func, arg)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;func(arg);<br>}<br><br>indirectCall(method(undefined, myscript), arg);<br><br>// 2<br>function indirectCall(func, arg)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;script_execute(func, arg);<br>}<br><br>indirectCall(myscript, arg);</p><div data-conref="../../assets/snippets/Script_empty_reference_error.hts"><p class="note"><span class="note">NOTE</span>&nbsp;Keep in mind that if your script is <strong>completely empty</strong>, it will not be loaded into the compiled game and will become non-existent; meaning that trying to reference such a script asset will crash your game. Note that this only applies to scripts that are completely empty, so even if your script only contains&nbsp;comments, it will still be included in the compiled game.</p></div><h2>Script Scope</h2><p>This leads us to the final and most important thing to know about scripts and the functions they contain: scripts are parsed on a <b>global</b> level and will be <strong>compiled at the very start of the game</strong>. This means that <em>technically</em> all functions in a script are "unbound"&nbsp;<a href="Method_Variables.htm">method variables</a>, and any variables declared outside of a function in the script will be considered <a href="Variables/Global_Variables.htm">global variables</a>. For example, consider this script:</p><p class="code">function Foo()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;// Do something<br>}<br>blah = 10;<br>function Bar()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;// Do something else<br>}</p><p>In the above case, not only have we defined the functions <span class="inline">Foo</span> and <span class="inline">Bar</span> but also the variable <span class="inline">blah</span> and all of them are considered to have been created in the <b>global</b> scope. The functions don't need the <span class="inline">global</span> keyword to be recognized as the compiler understands that these functions are part of the script, but if you wanted to access <span class="inline">blah</span> then you would need to do:</p><p class="code">val = global.blah;</p><p>That said, we recommend that you <b>always explicitly type global variables</b> when creating them in scripts to prevent any issues later. Scripts are also an ideal place to define any <strong>Macros</strong> or <strong>Enums</strong> (<a href="Variables/Constants.htm">constants</a>), as adding them to a script outside of a function also means that they will be created for use before the game code actually starts running. Below is an example of a script that is creating different global scope values for a game:</p><p class="code">/// Initialise All Global Scope Values And Constants<br>global.player_score = 0;<br>global.player_hp = 100;<br>global.pause = false;<br>global.music = true;<br>global.sound = true;<br><br>enum rainbowcolors<br>{<br>&nbsp; &nbsp; red,<br>&nbsp; &nbsp; orange,<br>&nbsp; &nbsp; yellow,<br>&nbsp; &nbsp; green,<br>&nbsp; &nbsp; blue,<br>&nbsp; &nbsp; indigo,<br>&nbsp; &nbsp; violet<br>}<br><br>#macro weapon_num&nbsp;3<br>#macro weapon_gun&nbsp;0<br>#macro weapon_bomb&nbsp;1<br>#macro weapon_knife 2</p><p>Note how all these constants are set up outside of any&nbsp;function call, meaning they will be initialised before everything else and at a <em>global</em> scope. This means that if you want to use a script&nbsp;to initialise variables on an <em>instance</em> scope then you must wrap them in a function, for example:</p><p class="code">/// @function&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init_enemy();<br>/// @description&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Initialise enemy instance vars<br><br>function init_enemy()<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;hp = 100;<br>&nbsp;&nbsp;&nbsp;&nbsp;dmg = 5;<br>&nbsp;&nbsp;&nbsp;&nbsp;mana = 50;<br>}</p><p>So, scripts can be used to generate macros, enums and global variables before the game starts so they are ready for use at any time, and they can also be used to create "unbound" methods (user-defined functions) that can be used in your game like GML runtime functions.</p><p>One final thing to note about script functions is that if you are developing for <strong>Web</strong> (ie: targeting <strong>HTML5</strong>), then there is an additional function protocol that you can use when adding functions to scripts, which is to prefix a function name with <span class="inline">gmcallback_</span>, for example:</p><p class="code">gmcallback_create_button</p><p>Using the above function name would mean that the function <span class="inline">gmcallback_create_button()</span> will not be obfuscated and so can be used in JavaScript extensions and other areas of your game, for example, when using the <a href="../GML_Reference/Web_And_HTML5/Web_And_HTML5.htm"><span class="inline">clickable_*</span></a>&nbsp;functions.</p><h2>Static Variables</h2><p>Functions can also make use of static variables, which maintain their values throughout every function call. Please <a href="Functions/Static_Variables.htm">read this page</a> for more information.</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="GML_Overview.htm">GML&nbsp;Overview</a></div><div style="float:right">Next: <a href="Method_Variables.htm">Method Variables</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>