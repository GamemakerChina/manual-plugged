<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><script type="text/javascript" src="../../assets/import/jquery-3.6.1.min.js"></script><script type="text/javascript" src="../../assets/import/layer/layer.js"></script><script type="text/javascript" src="../../assets/import/pangu.min.js"></script><link rel="stylesheet" type="text/css" href="../../assets/import/layer/layui_btn.css"><link rel="stylesheet" type="text/css" href="../../assets/import/layer/layui_col.css"><link rel="stylesheet" type="text/css" href="../../assets/import/layer/theme/default/layer.css"><link rel="stylesheet" type="text/css" href="../../assets/import/main.css"><script>let str;removeHtml=function(e){return e=(e=(e=(e=e.replace(/(<([^>]+)>)/gi,"{}")).replace(/\r\n/g,"\n")).replace(/\n/g,"")).replace(/ {2,}/g," ")},retHtml=function(e){return e.match(/(<([^>]+)>)/gi)},setTranslator=function(e,t,n){let o;o=n?e.attr(n):e.html();let i=t[removeHtml(o)];if(null!=i&&i.length){t=retHtml(o);let a=0;t&&t.forEach(function(e,t){var n=i.replace("{"+a+"}",e);i=n===i?i.replace("{}",e):n,a++}),n?e.attr(n,i):e.html(i)}},noTranslationState=function(){return"true"==window.localStorage.getItem("noTranslationState")},noTranslationStateToggle=function(){window.localStorage.setItem("noTranslationState",!noTranslationState())},addNoTranslationStateButton=function(){var e=`
		
		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		window.location.replace('gmmt://'+document.location.hash)
		"
		>打开编辑器</button>

		<button style="
			float: right;
			font-size: 16px;
			padding: 4px 12px;
		"
		onclick="
		noTranslationStateToggle();
		location.reload();
    	event.stopPropagation();
		"
		>切换翻译</button>
		`;$(".header").length?$(".header").append(e):($(".topic-header").append(e),$(".topic-header button").css("position","relative").css("top","44px"))},removeExtensionFromHash=function(e){return e.replaceAll("#t=","").replaceAll("%2F","/").replaceAll(".htm","")};let json_global,json_file={'A method variable is essentially a variable that has had a function assigned to it, "binding" the function to an instance and enabling you to use the variable to refer to the function - much like you use a {}runtime function name{} to refer to a built-in GML function. The variable used can be {}local{}, {}instance{} or {}global{} in scope (see {}here{}&nbsp;for more information on variable scope).':'方法变量本质上是一个被分配了一个函数的变量，将该函数 "绑定 "到一个实例上，使你能够使用该变量来引用该函数--就像你使用{}运行时函数名{}来引用GML内置函数一样。使用的变量在范围上可以是{}局部{}、{}实例{}或{}全局{}(关于变量范围的更多信息见{}这里{})。',"Also see:&nbsp;{}Script Functions vs. Methods{}":"另请参阅：{}脚本函数与方法对比{}","Below we list a few helper functions associated with method variables:":"下面我们列出了一些与方法变量关联的帮助器函数：","Below you can see three simple examples of creating a method variable using different scopes:":"下面您可以看到使用不同范围创建方法变量的三个简单示例：","Creating Methods":"创建方法",'In general, however, you would use the {}first {}form for methods, and the second form for defining {}script functions{}, since the second form will also assign a script index to the function name while the first form will be a "true" method (and require the use of the {}global{} prefix if used to define a scripted function).':'然而，一般来说，你会用{}第一种{}形式来定义方法，而用第二种形式来定义{}脚本函数{}，因为第二种形式也会给函数名分配一个脚本索引，而第一种形式则是一个 "真 "方法(如果用来定义脚本函数，需要使用{}global{}前缀)。',"Method Variables":"方法变量","Methods can also make use of static variables, which maintain their values throughout every function call. Please {}read this page{} for more information.":"方法还可以利用静态变量，静态变量在每次函数调用过程中都保持其值。请{}阅读此页面{}了解更多信息。","Methods, just like script functions, can also take optional arguments that have default values for when they're not passed in:":"方法与脚本函数一样，也可以采用可选参数，这些参数在未传入时具有默认值：","Note that if an argument is not passed in, and it does not have a default value, then it will be equal to {}undefined{}.":"请注意，如果未传入参数并且没有默认值，则它将等于{}undefined{}。","Notice that in the above code, the various parameters that are given as inputs for the function are all named and these names are what should be used within the function to refer to the different inputs. Also note that you can use the {}{}return{}{} statement to return a value from a function for use elsewhere in your code, and that&nbsp;a function with&nbsp;{}no{}&nbsp;return value defined, will return&nbsp;{}undefined{}.by default.":"请注意，在上面的代码中，作为函数输入给出的各种参数都被命名了，这些名称应该在函数中用来指代不同的输入。另请注意，您可以使用{}{}return{}{}语句从函数返回一个值以供代码的其他地方使用，默认情况下，定义了{}no{}返回值的函数将返回{}undefined{}。","Once created, the method variable can be used just as you would a runtime function or a script function, for example:":"创建方法变量后，可以像使用运行时函数或脚本函数一样使用，例如：","So, keep in mind that - in general -&nbsp;we will always be referring to functions that have {}not {}been defined with a script index when we are talking about methods and method&nbsp;variables.&nbsp;":"因此，请记住，一般来说，当我们谈论方法和方法变量时，我们总是指那些{}没有{}用脚本索引定义过的函数。","The above function takes three arguments, where the last two are optional. If they are not passed in when the function is called, then they'll use the instance's {}x{} and {}y{} coordinates by default.":"上面的函数接受三个参数，其中最后两个是可选的。如果在调用函数时未传入这些坐标，则默认情况下它们将使用实例的{}x{}和{}y{}坐标。","The syntax for creating a method variable is as follows:":"创建方法变量的语法如下：",'To create a function in GML Visual, use&nbsp;{}Declare A New Function{}. Enable its "Temp" option to create a method variable (first syntax shown above).':'要在GML  Visual中创建函数，请使用{}声明新函数{}。启用其"Temp"选项以创建方法变量(上面显示的第一个语法)。',"Variables created within a function will follow the same rules as normal and will be scoped according to the keyword used or the scope of the function call. In the above example, we use {}var{}&nbsp;so the array variable is in the {}local {}scope of the function. If we didn't use the keyword, then the variable would have been created on the scope of the instance that called the function.":"在函数中创建的变量将遵循与正常情况相同的规则，并且将根据使用的关键字或函数调用的范围来确定范围。在上面的示例中，我们使用{}var{}，因此数组变量位于函数的{}局部{}范围内。如果不使用关键字，则会在调用函数的实例范围内创建变量。",or:"或",'{}NOTE{}&nbsp;While the variable will be in the chosen scope, the actual function will be bound to the scope that it was initially defined in. For example, {}script functions{} are all global scope and "unbound" (ie: they are not associated with any instances), but if you have a script function that creates another function as a method variable within it and then you call this script function&nbsp;from an instance, the function used within the script will {}be bound to the instance variable as a method{}. In general this is not something you ever need to think about but for more complex operations with method variables it\'s worth taking into consideration. This also applies when using other constructs like {}{}with{}{} - when you create a method variable inside a with, the function will be bound to the instance that is currently in scope.':'{}注意{} 虽然变量会在选择的作用域中，但实际的函数会被绑定到它最初定义的作用域中。例如，{}脚本函数{}都是全局范围和 "非绑定"(即：它们不与任何实例相关联)，但如果你有一个脚本函数，在其中创建了另一个函数作为方法变量，然后你从一个实例中调用这个脚本函数，脚本中使用的函数将{}作为一个方法{}绑定到实例变量。一般来说，这不是你需要考虑的问题，但对于使用方法变量的更复杂的操作来说，这是值得考虑的。这也适用于使用其他结构，比如{}{}with{}{}--当你在with里面创建一个方法变量时，该函数将被绑定到当前范围内的实例。','{}NOTE{}&nbsp;You can check this by using both forms in project and then calling the runtime function {}typeof(){} on each of them. One will be classed as a "number" - since it returns a script index ID - and the other will be classed as a "method".':'{}注意{}您可以通过在项目中同时使用这两个表单，然后在每个表单上调用运行时函数{}typeof(){}来检查此问题。一个将被分类为"数字"-因为它返回脚本索引Id-，而另一个将被分类为"方法"。','{}{}NOTE{}{}&nbsp;To create a function in GML Visual, use&nbsp;{}Declare A New Function{}. Enable its "Temp" option to create a method variable (first syntax shown above).':'{}{}注意{}{}要在 GML Visual 中创建函数，请使用{}声明新函数{}。启用其"Temp"选项来创建方法变量(上面显示的第一个语法)。'},get_json_global=$.ajax({url:"/global.json",type:"GET",dataType:"json",async:!1,success:function(e){json_global=e}});$(function(){if(addNoTranslationStateButton(),noTranslationState())return!1;$("div.footer a,h4,caption").each(function(){setTranslator($(this),json_global)}),$("p,h1,h2,h3,td,li,a,div.dropspotnote,figcaption").each(function(){setTranslator($(this),json_file)}),$("th,.warning,.important,.optional").each(function(){setTranslator($(this),json_global)}),$(".header").length&&(window.setInterval(function(){$("#toc-panel a:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)}),$(".GlossDefinitionText:not('isTranslate')").each(function(){$(this).addClass("isTranslate"),setTranslator($(this),json_global)})},250),console.log("成功啦!现在正在疯狂翻译菜单中!")),$(".tooltip").each(function(){setTranslator($(this),json_global,"title")})}),document.addEventListener("DOMContentLoaded",()=>{pangu.autoSpacingPage()})</script><script type="text/javascript" language="JavaScript">function reDo(){innerWidth==origWidth&&innerHeight==origHeight||location.reload()}4==parseInt(navigator.appVersion)&&"Netscape"==navigator.appName&&(origWidth=innerWidth,origHeight=innerHeight,onresize=reDo),onerror=null</script><style type="text/css">p.WebHelpNavBar{text-align:right}</style><script type="text/javascript">gCommonRootRelPath=gRootRelPath="../..",gTopicId="8.2.1.1_6"</script><script type="text/javascript" src="../../template/scripts/rh.min.js"></script><script type="text/javascript" src="../../template/scripts/common.min.js"></script><script type="text/javascript" src="../../template/scripts/topic.min.js"></script><script type="text/javascript" src="../../template/scripts/topicwidgets.min.js"></script><script type="text/javascript" src="../../whxdata/projectsettings.js"></script><link rel="stylesheet" type="text/css" href="../../template/styles/topic.min.css"><link rel="stylesheet" type="text/css" href="../../template/Charcoal_Grey/topicheader.css"><meta name="topic-status" content="Draft"><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Method Variables</title><meta name="generator" content="Adobe RoboHelp 2022"><link rel="stylesheet" href="../../assets/css/default.css" type="text/css"><script src="../../assets/scripts/main_script.js" type="module"></script><meta name="rh-authors" content="Gurpreet S. Matharoo"><meta name="topic-comment" content="Page outlining the use of Method Variables"><meta name="rh-index-keywords" content="Method Variables"><meta name="search-keywords" content="Method Variables,methods,method"><meta name="brsnext" value="GameMaker_Language/GML_Overview/Script_Functions_vs_Methods.htm"><meta name="brsprev" value="GameMaker_Language/GML_Overview/Script_Functions.htm"></head><body><div class="topic-header rh-hide" id="rh-topic-header"><div class="logo"></div><div class="nav"><div class="title" title="Method Variables"><span>Method Variables</span></div><div class="gotohome" title="Click here to see this page in full context"><a href="#" onclick="rh._.goToFullLayout()">Click here to see this page in full context</a></div></div></div><div class="topic-header-shadow rh-hide" id="rh-topic-header-shadow"></div><h1>Method Variables</h1><p>A method variable is essentially a variable that has had a function assigned to it, "binding" the function to an instance and enabling you to use the variable to refer to the function - much like you use a <a href="Runtime_Functions.htm">runtime function name</a> to refer to a built-in GML function. The variable used can be <em>local</em>, <em>instance</em> or <em>global</em> in scope (see <a href="Variables_And_Variable_Scope.htm">here</a>&nbsp;for more information on variable scope).</p><p>Also see:&nbsp;<a href="Script_Functions_vs_Methods.htm">Script Functions vs. Methods</a></p><h2>Creating Methods</h2><p>The syntax for creating a method variable is as follows:</p><p class="code">name =&nbsp;function( parameter1, parameter2, ... )<br><span>{</span><br><span>&nbsp; &nbsp; statement1;</span><br><span>&nbsp; &nbsp; statement2;</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;...</span><br><span>}</span></p><p>or</p><p class="code"><span>function name( parameter1, parameter2, ... )<br>{</span><br><span>&nbsp; &nbsp; statement1;</span><br><span>&nbsp; &nbsp; statement2;</span><br><span>&nbsp;&nbsp;&nbsp;&nbsp;...</span><br><span>}</span></p><p class="note"><span data-conref="../../assets/snippets/Tag_note.hts"><span class="note">NOTE</span></span>&nbsp;To create a function in GML Visual, use&nbsp;<a href="../../Drag_And_Drop/Drag_And_Drop_Reference/Common/Declare_A_New_Function.htm">Declare A New Function</a>. Enable its "Temp" option to create a method variable (first syntax shown above).</p><p>In general, however, you would use the <em>first</em> form for methods, and the second form for defining <a href="Script_Functions.htm">script functions</a>, since the second form will also assign a script index to the function name while the first form will be a "true" method (and require the use of the <a href="Variables/Global_Variables.htm">global</a> prefix if used to define a scripted function).</p><p class="note"><span class="note">NOTE</span>&nbsp;You can check this by using both forms in project and then calling the runtime function <a href="../GML_Reference/Variable_Functions/typeof.htm">typeof()</a> on each of them. One will be classed as a "number" - since it returns a script index ID - and the other will be classed as a "method".</p><p>So, keep in mind that - in general -&nbsp;we will always be referring to functions that have <em>not</em> been defined with a script index when we are talking about methods and method&nbsp;variables.&nbsp;</p><p>Below you can see three simple examples of creating a method variable using different scopes:</p><p class="code">// Local<br>var _debug = function(message)<br>{<br>&nbsp; &nbsp; show_debug_message(message);<br>}<br><br>// Instance<br>do_maths = function(val1, val2, val3)<br>{<br>&nbsp; &nbsp; return (val1 * val2) - val3;<br>}<br><br>// Global<br>global.pd = function(_x1, _y1, _x2, _y2);<br>{<br>&nbsp; &nbsp; return point_distance(_x1, _y1, _x2, _y2);<br>}</p><p>Notice that in the above code, the various parameters that are given as inputs for the function are all named and these names are what should be used within the function to refer to the different inputs. Also note that you can use the <span class="inline"><a href="Language_Features/return.htm">return</a></span> statement to return a value from a function for use elsewhere in your code, and that&nbsp;a function with&nbsp;<em>no</em>&nbsp;return value defined, will return&nbsp;<span class="inline">undefined</span>.by default.</p><p class="note"><span class="note">NOTE</span>&nbsp;While the variable will be in the chosen scope, the actual function will be bound to the scope that it was initially defined in. For example, <a href="Script_Functions.htm">script functions</a> are all global scope and "unbound" (ie: they are not associated with any instances), but if you have a script function that creates another function as a method variable within it and then you call this script function&nbsp;from an instance, the function used within the script will <strong>be bound to the instance variable as a method</strong>. In general this is not something you ever need to think about but for more complex operations with method variables it's worth taking into consideration. This also applies when using other constructs like <a href="Language_Features/with.htm"><span class="inline">with</span></a> - when you create a method variable inside a with, the function will be bound to the instance that is currently in scope.</p><p>Once created, the method variable can be used just as you would a runtime function or a script function, for example:</p><p class="code">create_vec = function(_x1, _y1, _x2, _y2);<br>{<br>&nbsp; &nbsp; var _array;<br>&nbsp; &nbsp; _array[0] = point_distance(_x1, _y1, _x2, _y2);<br>&nbsp; &nbsp; _array[1] = point_direction(_x1, _y1, _x2, _y2);<br>&nbsp; &nbsp; return _array;<br>}<br><br>vec = create_vec(x, y, mouse_x, mouse_y);</p><p>Variables created within a function will follow the same rules as normal and will be scoped according to the keyword used or the scope of the function call. In the above example, we use <span class="inline">var</span>&nbsp;so the array variable is in the <em>local</em> scope of the function. If we didn't use the keyword, then the variable would have been created on the scope of the instance that called the function.</p><p>Methods, just like script functions, can also take optional arguments that have default values for when they're not passed in:</p><p class="code">create_attachment = function(_attachment, <strong>_x = x</strong>, <strong>_y = y</strong>)<br>{<br>&nbsp; &nbsp; return instance_create_layer(_x, _y, layer, _attachment);<br>}</p><p>The above function takes three arguments, where the last two are optional. If they are not passed in when the function is called, then they'll use the instance's <span class="inline">x</span> and <span class="inline">y</span> coordinates by default.</p><p>Note that if an argument is not passed in, and it does not have a default value, then it will be equal to <span class="inline">undefined</span>.</p><p>Methods can also make use of static variables, which maintain their values throughout every function call. Please <a href="Functions/Static_Variables.htm">read this page</a> for more information.</p><p>Below we list a few helper functions associated with method variables:</p><ul class="colour"><li><a href="../GML_Reference/Variable_Functions/is_method.htm">is_method</a></li><li><a href="../GML_Reference/Variable_Functions/method.htm">method</a></li><li><a href="../GML_Reference/Variable_Functions/method_get_self.htm">method_get_self</a></li><li><a href="../GML_Reference/Variable_Functions/method_get_index.htm">method_get_index</a></li><li><a href="../GML_Reference/Variable_Functions/method_call.htm">method_call</a></li></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><div class="footer"><div class="buttons"><div class="clear"><div style="float:left">Back: <a href="GML_Overview.htm">GML&nbsp;Overview</a></div><div style="float:right">Next:&nbsp;<a href="Script_Functions_vs_Methods.htm">Script Functions vs. Methods</a></div></div></div><h5><span data-keyref="Copyright Notice">© Copyright YoYo Games Ltd. 2024 All Rights Reserved</span></h5></div></body></html>